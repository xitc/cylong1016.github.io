<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>笑话人生</title>
  
  <subtitle>年华易逝 懂得珍惜</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.cylong.com/"/>
  <updated>2020-05-30T13:48:24.000Z</updated>
  <id>http://www.cylong.com/</id>
  
  <author>
    <name>cylong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>三数之和</title>
    <link href="http://www.cylong.com/blog/2020/05/30/three-sum/"/>
    <id>http://www.cylong.com/blog/2020/05/30/three-sum/</id>
    <published>2020-05-30T13:48:24.000Z</published>
    <updated>2020-05-30T13:48:24.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c，使得 a + b + c = 0？请你找出所有满足条件且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p><strong>示例:</strong></p><blockquote><p>给定数组 nums = [-1, 0, 1, 2, -1, -4]，<br>满足要求的三元组集合为：<br>[[-1, 0, 1], [-1, -1, 2]]</p></blockquote><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p> 之前做过<a href="https://leetcode-cn.com/problems/two-sum" title="两数之和 | 力扣（LeetCode）" target="_blank" rel="noopener">两数之和</a>这道题，所以第一想法就是转化成两次两数之和解决，思路就是先求 b + c 两数之和 z，再求 a + z 两数之和等于0，也就是相反数。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 求出两数之和的组合，和为-nums[i]</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; twoSumList = twoSum(nums, i + <span class="number">1</span>, -nums[i]);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; list : twoSumList) &#123;</span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">            Collections.sort(list);</span><br><span class="line">            result.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.stream().distinct().collect(Collectors.toList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; nums.length; i++) &#123;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">            list.add(nums[map.get(complement)]);</span><br><span class="line">            result.add(list);</span><br><span class="line">            <span class="comment">// 去重，防止重复执行超时</span></span><br><span class="line">            map.remove(nums[i]);</span><br><span class="line">            map.remove(complement);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 其实这道题有更好的解法，受之前两数之和的影响，两数之和的那道题，是没法给数组排序的，因为输出是数组下标，而这道题，输出是三元组，可以进行数组排序的，以下是来自LeetCode的题解：</p><ul><li>首先对数组进行排序，排序后固定一个数 nums[i]，再使用左右指针指向 nums[i] 后面的两端，数字分别为 nums[L] 和 nums[R]，计算三个数的和 sum 判断是否满足为 0，满足则添加进结果集。</li><li>如果 nums[i]大于 0，则三数之和必然无法等于 0，结束循环。</li><li>如果 nums[i] == nums[i−1]，则说明该数字重复，会导致结果重复，所以应该跳过。</li><li>当 sum == 0 时，nums[L] == nums[L+1] 则会导致结果重复，应该跳过，L++。</li><li><p>当 sum == 0 时，nums[R] == nums[R−1] 则会导致结果重复，应该跳过，R−−。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">   List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   <span class="keyword">int</span> len = nums.length;</span><br><span class="line">   <span class="keyword">if</span> (nums == <span class="keyword">null</span> || len &lt; <span class="number">3</span>)</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   Arrays.sort(nums);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">       <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">break</span>; <span class="comment">// 如果当前数字大于0，则三数之和一定大于0，所以结束循环</span></span><br><span class="line">       <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">           <span class="keyword">continue</span>; <span class="comment">// 去重</span></span><br><span class="line">       <span class="keyword">int</span> L = i + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> R = len - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">           <span class="keyword">int</span> sum = nums[i] + nums[L] + nums[R];</span><br><span class="line">           <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">               res.add(Arrays.asList(nums[i], nums[L], nums[R]));</span><br><span class="line">               <span class="keyword">while</span> (L &lt; R &amp;&amp; nums[L] == nums[L + <span class="number">1</span>])</span><br><span class="line">                   L++; <span class="comment">// 去重</span></span><br><span class="line">               <span class="keyword">while</span> (L &lt; R &amp;&amp; nums[R] == nums[R - <span class="number">1</span>])</span><br><span class="line">                   R--; <span class="comment">// 去重</span></span><br><span class="line">               L++;</span><br><span class="line">               R--;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>)</span><br><span class="line">               L++;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>)</span><br><span class="line">               R--;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode-cn.com/problems/3sum" title="三数之和 | 力扣（LeetCode）" target="_blank" rel="noopener">三数之和 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/3sum/solution/hua-jie-suan-fa-15-san-shu-zhi-he-by-guanpengchn/" title="三数之和 | 题解 | guanpengchn]" target="_blank" rel="noopener">三数之和 | 题解 | guanpengchn</a></p></blockquote><hr><blockquote><p>文章标题：<a href="http://www.cylong.com/blog/2020/05/30/three-sum/" title="三数之和">三数之和</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href="http://www.cylong.com/blog/2020/05/30/three-sum/" title="三数之和">http://www.cylong.com/blog/2020/05/30/three-sum/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c，使得 a + b + c = 0？请你找出所有满足条件且不重复的三元组。&lt;/p&gt;
&lt;p&gt;注意：答案中不可以包含重复的三元组。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定数组 nums = [-1, 0, 1, 2, -1, -4]，&lt;br&gt;满足要求的三元组集合为：&lt;br&gt;[[-1, 0, 1], [-1, -1, 2]]&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.cylong.com/categories/LeetCode/"/>
    
    
      <category term="java" scheme="http://www.cylong.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://www.cylong.com/tags/leetcode/"/>
    
      <category term="学习笔记" scheme="http://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Z 字形变换</title>
    <link href="http://www.cylong.com/blog/2019/12/30/zigzag-conversion/"/>
    <id>http://www.cylong.com/blog/2019/12/30/zigzag-conversion/</id>
    <published>2019-12-30T07:03:27.000Z</published>
    <updated>2019-12-30T07:03:27.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L   C   I   R</span><br><span class="line">E T O E S I I G</span><br><span class="line">E   D   H   N</span><br></pre></td></tr></table></figure></p><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。</p><p><strong>示例 1:</strong></p><blockquote><p>输入: s = “LEETCODEISHIRING”, numRows = 3<br>输出: “LCIRETOESIIGEDHN”</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>输入: s = “LEETCODEISHIRING”, numRows = 4<br>输出: “LDREOEIIECIHNTSG”</p></blockquote><p>解释:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">L     D     R</span><br><span class="line">E   O E   I I</span><br><span class="line">E C   I H   N</span><br><span class="line">T     S     G</span><br></pre></td></tr></table></figure></p><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先我们可以知道numRows为行数，输出的时候我们只要把每行的字符按顺序输出即可，其实上面的输出，为了美观，使用了空格，当我们把空格拿掉，就转换成了下面的输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L C I R</span><br><span class="line">E T O E S I I G</span><br><span class="line">E D H N</span><br></pre></td></tr></table></figure></p><p>那么我们只要知道第i个字符，要放到哪一行即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numRows &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;List&lt;Character&gt;&gt; zList = <span class="keyword">new</span> ArrayList&lt;&gt;(numRows);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">        zList.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> j; <span class="comment">// 判断字符放到哪一行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        <span class="comment">// 多少字母为一个循环</span></span><br><span class="line">        <span class="keyword">int</span> cycle = numRows + numRows - <span class="number">2</span>;</span><br><span class="line">        j = i % cycle;</span><br><span class="line">        j = Math.min(cycle - j, j);</span><br><span class="line">        zList.get(j).add(c);</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder sBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">        zList.get(i).forEach(sBuilder::append);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sBuilder.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方解法和我的思路差不多，只不过他细节上处理的比我好，行数是 <code>numRows</code> 和 <code>len(s)</code> 的较小值，其每行数据没有使用<code>List&lt;Character&gt;</code>，而是使用StringBuilder，另外使用了方向变量<code>goingDown</code>来判断此时在哪一行。以下是官方解法：</p><p>我们可以使用 <code>min(numRows, len(s))</code> 个列表来表示 Z 字形图案中的非空行。从左到右迭代 s，将每个字符添加到合适的行。可以使用当前行和当前方向这两个变量对合适的行进行跟踪。只有当我们向上移动到最上面的行或向下移动到最下面的行时，当前方向才会发生改变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numRows == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    List&lt;StringBuilder&gt; rows = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Math.min(numRows, s.length()); i++)</span><br><span class="line">        rows.add(<span class="keyword">new</span> StringBuilder());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> curRow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> goingDown = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">        rows.get(curRow).append(c);</span><br><span class="line">        <span class="keyword">if</span> (curRow == <span class="number">0</span> || curRow == numRows - <span class="number">1</span>)</span><br><span class="line">            goingDown = !goingDown;</span><br><span class="line">        curRow += goingDown ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StringBuilder ret = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (StringBuilder row : rows)</span><br><span class="line">        ret.append(row);</span><br><span class="line">    <span class="keyword">return</span> ret.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode-cn.com/problems/zigzag-conversion/" title="Z 字形变换 | 力扣（LeetCode）" target="_blank" rel="noopener">Z 字形变换 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/zigzag-conversion/solution/z-zi-xing-bian-huan-by-leetcode/" title="Z 字形变换 | 题解" target="_blank" rel="noopener">Z 字形变换 | 题解</a></p></blockquote><blockquote><p>文章标题：<a href="http://www.cylong.com/blog/2019/12/30/zigzag-conversion/" title="Z 字形变换">Z 字形变换</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href="http://www.cylong.com/blog/2019/12/30/zigzag-conversion/" title="Z 字形变换">http://www.cylong.com/blog/2019/12/30/zigzag-conversion/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;L   C   I   R&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;E T O E S I I G&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;E   D   H   N&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: s = “LEETCODEISHIRING”, numRows = 3&lt;br&gt;输出: “LCIRETOESIIGEDHN”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: s = “LEETCODEISHIRING”, numRows = 4&lt;br&gt;输出: “LDREOEIIECIHNTSG”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解释:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;L     D     R&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;E   O E   I I&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;E C   I H   N&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;T     S     G&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.cylong.com/categories/LeetCode/"/>
    
    
      <category term="java" scheme="http://www.cylong.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://www.cylong.com/tags/leetcode/"/>
    
      <category term="学习笔记" scheme="http://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>两数之和</title>
    <link href="http://www.cylong.com/blog/2019/11/06/two-sum/"/>
    <id>http://www.cylong.com/blog/2019/11/06/two-sum/</id>
    <published>2019-11-06T14:59:38.000Z</published>
    <updated>2019-11-06T14:59:38.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p><strong>示例:</strong></p><blockquote><p>给定 nums = [2, 7, 11, 15], target = 9<br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p></blockquote><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>使用哈希表将会使问题特别简单，首先，我们将使用一次遍历将数组中的元素加入到Map中，key是当前元素的值，value是当前元素的索引。接下来，我们进行第二次遍历，第二次遍历我们将查找当前元素的目标元素（target−nums[i]）是否在Map中，如果在，即找到目标值，返回两个元素的索引。注意一点的是，目标元素不能是当前元素！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, map.get(complement)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，我们把上面的两步合成一步，只用一次遍历即可完成，当遍历到第i个值后，我们把此元素的需要的目标值保存到Map中，后续遍历，找到目标的值，即完成遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(nums.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(nums[i])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(nums[i]), i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(target - nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode-cn.com/problems/two-sum" title="两数之和 | 力扣（LeetCode）" target="_blank" rel="noopener">两数之和 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-2/" title="两数之和 | 题解" target="_blank" rel="noopener">两数之和 | 题解</a></p></blockquote><hr><blockquote><p>文章标题：<a href="http://www.cylong.com/blog/2019/11/06/two-sum/" title="两数之和">两数之和</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href="http://www.cylong.com/blog/2019/11/06/two-sum/" title="两数之和">http://www.cylong.com/blog/2019/11/06/two-sum/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。&lt;br&gt;你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 nums = [2, 7, 11, 15], target = 9&lt;br&gt;因为 nums[0] + nums[1] = 2 + 7 = 9&lt;br&gt;所以返回 [0, 1]&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.cylong.com/categories/LeetCode/"/>
    
    
      <category term="java" scheme="http://www.cylong.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://www.cylong.com/tags/leetcode/"/>
    
      <category term="学习笔记" scheme="http://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>愚人节快乐</title>
    <link href="http://www.cylong.com/blog/2019/04/01/april-fools-day/"/>
    <id>http://www.cylong.com/blog/2019/04/01/april-fools-day/</id>
    <published>2019-04-01T14:35:22.000Z</published>
    <updated>2019-04-01T14:35:22.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p>事情起因是看到一个面试题，原题大概是，生成 N 个 1 到 1000 之间的随机数(N &lt;= 1000)，对于重复的数字，只取其中一个，并对结果进行从小到大排序。正好前几天了解了下 Java 的 Lambda 表达式和 Stream API，突然想起来，这可以一行代码搞定啊。于是就尝试的写了一下。【原题还是比较复杂的，我就提取了精华部分】</p><a id="more"></a><p>一行代码能搞定的事情从不会多写【为了美观我还是换行了】。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IntStream.range(<span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">    .map(x -&gt; (<span class="keyword">int</span>)(Math.random() * <span class="number">1000</span> + <span class="number">1</span>))</span><br><span class="line">    .distinct()</span><br><span class="line">    .sorted()</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>自从 Java 8 增加了 Lambda 表达式和 Stream API 后，很多操作都非常的方便，可以参考我上一篇博客：</p><blockquote><p><a href="http://www.cylong.com/blog/2019/03/18/lambda/" title="Java 8 的 Lambda 表达式和 Stream API | 笑话人生">Java 8 的 Lambda 表达式和 Stream API | 笑话人生</a></p></blockquote><p><span style="background-color:#000000">其实这就是一篇愚人节凑数用的博客，顺便祝愿下女票可以找到心仪的实习，相信自己，努力终将不会白费 (^_^)</span></p><hr><blockquote><p>文章标题：<a href="http://www.cylong.com/blog/2019/04/01/april-fools-day/" title="愚人节快乐">愚人节快乐</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href="http://www.cylong.com/blog/2019/04/01/april-fools-day/" title="愚人节快乐">http://www.cylong.com/blog/2019/04/01/april-fools-day/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;事情起因是看到一个面试题，原题大概是，生成 N 个 1 到 1000 之间的随机数(N &amp;lt;= 1000)，对于重复的数字，只取其中一个，并对结果进行从小到大排序。正好前几天了解了下 Java 的 Lambda 表达式和 Stream API，突然想起来，这可以一行代码搞定啊。于是就尝试的写了一下。【原题还是比较复杂的，我就提取了精华部分】&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.cylong.com/categories/Java/"/>
    
    
      <category term="java" scheme="http://www.cylong.com/tags/java/"/>
    
      <category term="随笔" scheme="http://www.cylong.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="lambda" scheme="http://www.cylong.com/tags/lambda/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 的 Lambda 表达式和 Stream API</title>
    <link href="http://www.cylong.com/blog/2019/03/18/lambda/"/>
    <id>http://www.cylong.com/blog/2019/03/18/lambda/</id>
    <published>2019-03-18T15:45:52.000Z</published>
    <updated>2019-03-19T16:52:52.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Java 8 的 Lambda 表达式提供了强大的函数化的编程能力，将函数作为参数传递进方法中。免去了使用匿名方法的麻烦，这样使可读性更好，表达更清晰。它是推动 Java 8 发布的最重要新特性。Lambda 表达式的简洁让人非常激动，但是如果第一次看到一段复杂的Lambda表达式的代码，会让你非常头疼，对于初学者来说，可能就是一段垃圾代码，因为你并不知道 Lambda 表达式到底在表达什么╮(╯▽╰)╭下面我们就举一些小例子由浅入深的了解下 Lambda 表达式。</p><a id="more"></a><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><p><code>(parameters) -&gt; expression</code> 或者 <code>(parameters) -&gt;{ statements; }</code></p><p>个人理解，把 Lambda 表达式看成咱们上学的时候学的函数 <code>f(x) = x + 1</code> 会让你更容易理解。</p><p>以下是lambda表达式的重要特征:</p><ul><li><b>可选类型声明：</b>不需要声明参数类型，编译器可以统一识别参数值。</li><li><b>可选的参数圆括号：</b>一个参数无需定义圆括号，但多个参数需要定义圆括号。</li><li><b>可选的大括号：</b>如果主体包含了一个语句，就不需要使用大括号。</li><li><b>可选的返回关键字：</b>如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</li></ul><h1 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Greeting</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, Operation operation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> operation.calc(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String msg, Greeting greeting)</span> </span>&#123;</span><br><span class="line">        greeting.say(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 类型声明</span></span><br><span class="line">        Operation addition = (<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; a + b;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不用类型声明</span></span><br><span class="line">        Operation subtraction = (a, b) -&gt; a - b;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 大括号中的返回语句。</span></span><br><span class="line">        <span class="comment">// 一般只有存在多行语句的时候才会使用，单行语句不需要使用，部分IDE会提示去掉大括号。</span></span><br><span class="line">        Operation multiplication = (<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> a * b;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有大括号及返回语句</span></span><br><span class="line">        Operation division = (<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; a / b;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"10 + 5 = "</span> + LambdaTest.calc(<span class="number">10</span>, <span class="number">5</span>, addition));</span><br><span class="line">        System.out.println(<span class="string">"10 - 5 = "</span> + LambdaTest.calc(<span class="number">10</span>, <span class="number">5</span>, subtraction));</span><br><span class="line">        System.out.println(<span class="string">"10 x 5 = "</span> + LambdaTest.calc(<span class="number">10</span>, <span class="number">5</span>, multiplication));</span><br><span class="line">        System.out.println(<span class="string">"10 / 5 = "</span> + LambdaTest.calc(<span class="number">10</span>, <span class="number">5</span>, division));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不用括号</span></span><br><span class="line">        Greeting sayHello = message -&gt; System.out.println(<span class="string">"Hello "</span> + message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用括号</span></span><br><span class="line">        Greeting sayBye = (message) -&gt; System.out.println(<span class="string">"Bye "</span> + message);</span><br><span class="line"></span><br><span class="line">        LambdaTest.say(<span class="string">"cylong"</span>, sayHello);</span><br><span class="line">        LambdaTest.say(<span class="string">"cylong"</span>, sayBye);</span><br><span class="line">        LambdaTest.say(<span class="string">"cylong"</span>, message -&gt; System.out.println(<span class="string">"Hi "</span> + message));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 以前的匿名类</span></span><br><span class="line">        LambdaTest.say(<span class="string">"cylong"</span>, <span class="keyword">new</span> Greeting() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Hello "</span> + msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码的输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">10 + 5 = 15</span><br><span class="line">10 - 5 = 5</span><br><span class="line">10 x 5 = 50</span><br><span class="line">10 / 5 = 2</span><br><span class="line">Hello cylong</span><br><span class="line">Bye cylong</span><br><span class="line">Hello cylong</span><br><span class="line">Hello cylong</span><br></pre></td></tr></table></figure><h1 id="Java-8-的-Stream-API"><a href="#Java-8-的-Stream-API" class="headerlink" title="Java 8 的 Stream API"></a>Java 8 的 Stream API</h1><p>其实目前用 Lambda 表达式最多的地方就是 Java 8 的新特性——Stream API，借助于 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。Java 8 中的 Stream 是对集合（Collection）对象功能的增强，Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的。在以前的 Java API中，我们更多的是使用for或者Iterator来遍历集合，同时我们可能会对集合里的数据进行过滤，计算等等处理，导致代码量非常的多，还容易出错。而使用 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。下面我们就看一些例子，深入了解下 Stream 的使用。</p><h2 id="集合迭代"><a href="#集合迭代" class="headerlink" title="集合迭代"></a>集合迭代</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通的 for 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n : numList) &#123;</span><br><span class="line">    System.out.println(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Lambda 表达式</span></span><br><span class="line">numList.forEach(n -&gt; System.out.println(n));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Java 8 的方法引用</span></span><br><span class="line"><span class="comment">// 看起来像C++的作用域解析运算符</span></span><br><span class="line">numList.forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>上面的例子包含普通的for循环，Lambda表达式遍历的方式，最后一种方式是方法引用，让代码量再次减少，代码更加清晰。</p><h2 id="集合过滤"><a href="#集合过滤" class="headerlink" title="集合过滤"></a>集合过滤</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出集合中所有大于5的值</span></span><br><span class="line">numList.stream().filter(n -&gt; n &gt; <span class="number">5</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>上面的代码中 <code>filter(n -&gt; n &gt; 5)</code>就是获得集合中大于5的所有值，filter 的参数是 <code>java.util.function.Predicate</code>，返回值是一个 Stream。使用 Predicate 可以向API方法添加逻辑，用更少的代码支持更多的动态行为。上面的例子就是使用 Predicate 对集合进行过滤。在 filter() 方法中，我们可以写更多复杂的逻辑来过滤集合元素。甚至可以使用 <code>and()</code> 或者 <code>or()</code>等合并多个条件，如下面这样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出集合中所有大于5并且小于8的值</span></span><br><span class="line">Predicate&lt;Integer&gt; start = n -&gt; n &gt;<span class="number">5</span>;</span><br><span class="line">Predicate&lt;Integer&gt; end = n -&gt; n &lt;<span class="number">8</span>;</span><br><span class="line">numList.stream().filter(start.and(end)).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>另外，关于 filter() 方法有个常见误解。在现实生活中，做过滤的时候，通常会丢弃部分，但使用filter()方法则是获得一个新的列表，且其每个元素符合过滤原则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个新的集合，所有元素的值大于5</span></span><br><span class="line">List&lt;Integer&gt; newNumList = numList.stream().filter(n -&gt; n &gt; <span class="number">5</span>).collect(Collectors.toList());</span><br><span class="line">newNumList.forEach(System.out::println);</span><br><span class="line">System.out.println();</span><br><span class="line">numList.forEach(System.out::print);</span><br></pre></td></tr></table></figure><p>输出是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">678910</span><br><span class="line">12345678910</span><br></pre></td></tr></table></figure><h2 id="Stream-的-map-示例"><a href="#Stream-的-map-示例" class="headerlink" title="Stream 的 map 示例"></a>Stream 的 map 示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将集合中的所有值计算平方后输出</span></span><br><span class="line">numList.stream().map(n -&gt; n * n).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>本例介绍最广为人知的函数式编程概念 map。它允许你将对象进行转换。例如在本例中，我们将 <code>n -&gt; n * n</code> lambda 表达式传到 map() 方法，后者将其应用到流中的每一个元素。然后用 <code>forEach()</code> 将列表元素打印出来。</p><h2 id="Stream-的-Reduce-示例"><a href="#Stream-的-Reduce-示例" class="headerlink" title="Stream 的 Reduce 示例"></a>Stream 的 Reduce 示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将集合中的所有值求和</span></span><br><span class="line"><span class="keyword">int</span> result = numList.stream().reduce((sum, n) -&gt; sum + n).get();</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure><p>在上个例子中，可以看到map将集合类（例如列表）元素进行转换的。还有一个 reduce() 函数可以将所有值合并成一个。Map和Reduce操作是函数式编程的核心操作，因为其功能，reduce 又被称为折叠操作。另外，reduce 并不是一个新的操作，你有可能已经在使用它。SQL中类似 sum()、avg() 或者 count() 的聚集函数，实际上就是 reduce 操作，因为它们接收多个值并返回一个值。流API定义的 reduce() 函数可以接受lambda表达式，并对所有值进行合并。IntStream这样的类有类似 average()、count()、sum() 的内建方法来做 reduce 操作，也有mapToLong()、mapToDouble() 方法来做转换。这并不会限制你，你可以用内建方法，也可以自己定义。</p><h2 id="计算集合元素的最大值、最小值、总和以及平均值"><a href="#计算集合元素的最大值、最小值、总和以及平均值" class="headerlink" title="计算集合元素的最大值、最小值、总和以及平均值"></a>计算集合元素的最大值、最小值、总和以及平均值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算集合元素的最大值、最小值、总和以及平均值</span></span><br><span class="line">IntSummaryStatistics stats = numList.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line">System.out.println(<span class="string">"Highest prime number in List : "</span> + stats.getMax());</span><br><span class="line">System.out.println(<span class="string">"Lowest prime number in List : "</span> + stats.getMin());</span><br><span class="line">System.out.println(<span class="string">"Sum of all prime numbers : "</span> + stats.getSum());</span><br><span class="line">System.out.println(<span class="string">"Average of all prime numbers : "</span> + stats.getAverage());</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Highest prime number in List : 10</span><br><span class="line">Lowest prime number in List : 1</span><br><span class="line">Sum of all prime numbers : 55</span><br><span class="line">Average of all prime numbers : 5.5</span><br></pre></td></tr></table></figure></p><h2 id="并行流-parallelStream"><a href="#并行流-parallelStream" class="headerlink" title="并行流 parallelStream"></a>并行流 parallelStream</h2><p>上文有提到，Stream API 提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势。串行流就是上面的 stream，而想要并行操作，就需要使用 parallelSteram。下面举一个例子来看看 stream 和 parallelStream 的区别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParallelStreamTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; numList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        doFor(numList);</span><br><span class="line">        doStream(numList);</span><br><span class="line">        doParallelStream(numList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doFor</span><span class="params">(List&lt;Integer&gt; numList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : numList) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(num);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">long</span> stop = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"doFor: "</span> + (stop - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doStream</span><span class="params">(List&lt;Integer&gt; numList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        numList.stream().forEach(num -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(num);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">long</span> stop = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"doStream: "</span> + (stop - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doParallelStream</span><span class="params">(List&lt;Integer&gt; numList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        numList.parallelStream().forEach(num -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(num);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">long</span> stop = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"doParallelStream: "</span> + (stop - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">12345</span><br><span class="line">doFor: 5003</span><br><span class="line">12345</span><br><span class="line">doStream: 5003</span><br><span class="line">34251</span><br><span class="line">doParallelStream: 1009</span><br></pre></td></tr></table></figure><p>代码上 stream 和 parallelStream 语法差异较小，用法基本一样。从执行结果来看，stream 顺序输出，而 parallelStream 无序输出；parallelStream 执行耗时是 stream 的五分之一，stream 和 for 循环用时一样。可以看到在当前测试场景下，parallelStream 获得的相对较好的执行性能，那 parallelStream 背后到底是什么呢？<br>要深入了解 parallelStream，首先要弄明白 ForkJoin 框架和 ForkJoinPool。ForkJoin 框架是 java 7 中提供的并行执行框架，他的策略是分而治之。说白了，就是把一个大的任务切分成很多小的子任务，子任务执行完毕后，再把结果合并起来。</p><h2 id="parallelStream-使用注意点"><a href="#parallelStream-使用注意点" class="headerlink" title="parallelStream 使用注意点"></a>parallelStream 使用注意点</h2><p>在开发过程中，经常会遇到遍历一个很大的集合做重复的操作，这时候如果使用串行执行会相当耗时，因此一般会采用多线程来提速。但是 parallelStream 若使用不当，很容易掉进陷阱中。总结以下几点需要注意：</p><ul><li>parallelStream 对集合操作是无序的，所以若需要顺序操作，请使用 stream 或者使用 parallelStream().forEachOrdered，后者执行时间就和 stream一样了，并不会提高效率。</li><li>parallelStream 速度并不会总是比 stream 快。将上面的例子修改为 <code>Thread.sleep(1)</code>，输出结果为：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">12345</span><br><span class="line">doFor: 10</span><br><span class="line">12345</span><br><span class="line">doStream: 12</span><br><span class="line">32154</span><br><span class="line">doParallelStream: 13</span><br></pre></td></tr></table></figure><p>可见并不是并行执行就是性能最好的，要根据具体的应用场景测试分析。这个例子中，每个子任务执行时间较短，而线程切换消耗了大量时间。</p><ul><li>paralleStream 是非线程安全的！非线程安全！非线程安全！重要的事情说三遍。下面看一个例子就可以很明显的看到了。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; list3 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">10000</span>).forEach(list1::add);</span><br><span class="line"></span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">10000</span>).parallel().forEach(list2::add);</span><br><span class="line"></span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">10000</span>).forEach(i -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                list3.add(i);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"串行执行的大小："</span> + list1.size());</span><br><span class="line">        System.out.println(<span class="string">"并行执行的大小："</span> + list2.size());</span><br><span class="line">        System.out.println(<span class="string">"加锁并行执行的大小："</span> + list3.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">串行执行的大小：10000</span><br><span class="line">并行执行的大小：9592</span><br><span class="line">加锁并行执行的大小：10000</span><br></pre></td></tr></table></figure><p>显而易见，stream.parallel.forEach()中执行的操作并非线程安全。如果需要线程安全，可以把集合转换为同步集合，即：Collections.synchronizedList(new ArrayList&lt;&gt;())。也可以像例子中的那样，对操作进行加锁。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>Lambda 表达式提供了 Java 的函数化编程能力，取代了匿名内部类。让我们的代码量更少更美观。</li><li>Lambda表达式在Java中又称为闭包或匿名函数。</li><li>Stream API 提供了强大的集合操作。让我们在开发过程中更关心逻辑，而不是怎么详细的去实现。</li><li>stream 是串行的，线程安全的。parallelStream 是并行的，线程不安全的，在使用过程中尤其要注意。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote><p><a href="http://www.runoob.com/java/java8-lambda-expressions.html" title="Java 8 Lambda 表达式 | 菜鸟教程" target="_blank" rel="noopener">Java 8 Lambda 表达式 | 菜鸟教程</a><br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/index.html" title="Java 8 中的 Streams API 详解 | IBM Developer" target="_blank" rel="noopener">Java 8 中的 Streams API 详解 | IBM Developer</a><br><a href="http://www.importnew.com/16436.html" title="Java 8 Lambda 表达式10个示例 | ImportNew" target="_blank" rel="noopener">Java 8 Lambda 表达式10个示例 | ImportNew</a><br><a href="https://zhuanlan.zhihu.com/p/43039062" title="Java 8 parallelStream 浅析 | 知乎" target="_blank" rel="noopener">Java 8 parallelStream 浅析 | 知乎</a><br><a href="https://www.cnblogs.com/puyangsky/p/7608741.html" title="Java 8 parallelStream 并发安全的思考 | puyangsky 博客园" target="_blank" rel="noopener">Java 8 parallelStream 并发安全的思考 | puyangsky 博客园</a><br><a href="https://blog.csdn.net/u011001723/article/details/52794455" title="深入浅出 parallelStream | 梦铃之境的专栏" target="_blank" rel="noopener">深入浅出 parallelStream | 梦铃之境的专栏</a></p></blockquote><hr><blockquote><p>文章标题：<a href="http://www.cylong.com/blog/2019/03/18/lambda/" title="Java 8 的 Lambda 表达式和 Stream API">Java 8 的 Lambda 表达式和 Stream API</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href="http://www.cylong.com/blog/2019/03/18/lambda/" title="Java 8 的 Lambda 表达式和 Stream API">http://www.cylong.com/blog/2019/03/18/lambda/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Java 8 的 Lambda 表达式提供了强大的函数化的编程能力，将函数作为参数传递进方法中。免去了使用匿名方法的麻烦，这样使可读性更好，表达更清晰。它是推动 Java 8 发布的最重要新特性。Lambda 表达式的简洁让人非常激动，但是如果第一次看到一段复杂的Lambda表达式的代码，会让你非常头疼，对于初学者来说，可能就是一段垃圾代码，因为你并不知道 Lambda 表达式到底在表达什么╮(╯▽╰)╭下面我们就举一些小例子由浅入深的了解下 Lambda 表达式。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.cylong.com/categories/Java/"/>
    
    
      <category term="java" scheme="http://www.cylong.com/tags/java/"/>
    
      <category term="lambda" scheme="http://www.cylong.com/tags/lambda/"/>
    
  </entry>
  
  <entry>
    <title>C语言头文件使用总结</title>
    <link href="http://www.cylong.com/blog/2018/06/25/c-header/"/>
    <id>http://www.cylong.com/blog/2018/06/25/c-header/</id>
    <published>2018-06-25T14:48:50.000Z</published>
    <updated>2018-06-25T14:48:50.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p>在平时工作中看到前人写的一些C头文件，很有感触。自己在写的时候也遇到了很多问题，比如重复引用导致宏或者常量重复定义，不知道该使用双引号还是使用尖括号引用等问题，决定先总结一下。做个笔记，随时复习。o(￣▽￣)ブ</p><h1 id="C语言头文件"><a href="#C语言头文件" class="headerlink" title="C语言头文件"></a>C语言头文件</h1><p>C语言头文件一般包含了函数声明，宏定义，常量等代码。我们在使用#include引用头文件。可以被多个c文件引用，避免了重复代码，减少了错误。让代码更加规范。<br>A simple practice in C 或 C++ 程序中，建议把所有的常量、宏、系统全局变量和函数原型写在头文件中，在需要的时候随时引用这些头文件。</p><a id="more"></a><h1 id="头文件引用"><a href="#头文件引用" class="headerlink" title="头文件引用"></a>头文件引用</h1><p>系统已经存在了很多头文件，当然，我们也可以自己编写。c文件引用头文件相当于直接复制到文件中，但是这样多个文件要使用这段代码的时候，就产生了很多重复代码，也不方便管理。引用存在两种引用形式。一种<code>#include &quot;cylong.h&quot;</code>，一种是 <code>#include &lt;cylong.h&gt;</code>。那这两种方式有什么区别呢？我们平时使用的时候又怎么用呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cylong.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>这种形式是引用系统文件，在系统目录下搜索此头文件。比如<code>#include &lt;stdio.h&gt;</code>等</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cylong.h"</span></span></span><br></pre></td></tr></table></figure><p>这种形式是引用用户文件，优先在当前目录下搜索此头文件，然后再去系统目录下搜索此头文件。</p><p>所以无论是我们自己写的头文件还是引用系统头文件，使用<code>#include &quot;cylong.h&quot;</code>都不会出错。但是这样并不标准，标准规定，<b>包含标准头文件或系统头文件时应使用尖括号，包含自定义头文件时可使用双引号。</b></p><h1 id="避免重复引用"><a href="#避免重复引用" class="headerlink" title="避免重复引用"></a>避免重复引用</h1><p>经常在写代码的时候，不经意间，我们会引用同一个头文件两次，那么我们会遇到很多重复定义的错误，为了避免这样的事情发生，我们需要将头文件里的内容放到编译宏中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CYONG_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CYLONG_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span> <span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// some codes</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> CYLONG_H</span></span><br></pre></td></tr></table></figure><p>当我们第一次引用的时候，未定义<code>CYLONG_H</code>宏，所以会继续编译下面的代码，当第二次引用的时候，<code>#ifndef CYLONG_H</code>为假，就不会编译下面的代码了，自然不会存在重复定义等问题。</p><h1 id="公共头文件"><a href="#公共头文件" class="headerlink" title="公共头文件"></a>公共头文件</h1><p>在程序代码中，经常很多c文件会引用一些相同的头文件，这个时候，我们就可以定义一个包含这些相同头文件的头文件<code>common.h</code>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> COMMON_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMMON_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cylong.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lsyu.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> COMMON_H</span></span><br></pre></td></tr></table></figure><p>然后我们就可以在每个需要的c文件中引用这个<code>common.h</code>头文件。但是需要注意的是，这个文件里除了头文件引用以外，建议不要再写其他的代码。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote><p><a href="http://www.runoob.com/cprogramming/c-header-files.html" title="C 头文件 | 菜鸟教程" target="_blank" rel="noopener">C 头文件 | 菜鸟教程</a><br><a href="http://c.biancheng.net/cpp/biancheng/view/66.html" title="C++ #include—尖括号和双引号的区别 | C语言中文网" target="_blank" rel="noopener">C++ #include—尖括号和双引号的区别 | C语言中文网</a></p></blockquote><hr><blockquote><p>文章标题：<a href="http://www.cylong.com/blog/2018/06/25/c-header/" title="C语言头文件使用总结">C语言头文件使用总结</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href="http://www.cylong.com/blog/2018/06/25/c-header/" title="C语言头文件使用总结">http://www.cylong.com/blog/2018/06/25/c-header/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;在平时工作中看到前人写的一些C头文件，很有感触。自己在写的时候也遇到了很多问题，比如重复引用导致宏或者常量重复定义，不知道该使用双引号还是使用尖括号引用等问题，决定先总结一下。做个笔记，随时复习。o(￣▽￣)ブ&lt;/p&gt;
&lt;h1 id=&quot;C语言头文件&quot;&gt;&lt;a href=&quot;#C语言头文件&quot; class=&quot;headerlink&quot; title=&quot;C语言头文件&quot;&gt;&lt;/a&gt;C语言头文件&lt;/h1&gt;&lt;p&gt;C语言头文件一般包含了函数声明，宏定义，常量等代码。我们在使用#include引用头文件。可以被多个c文件引用，避免了重复代码，减少了错误。让代码更加规范。&lt;br&gt;A simple practice in C 或 C++ 程序中，建议把所有的常量、宏、系统全局变量和函数原型写在头文件中，在需要的时候随时引用这些头文件。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://www.cylong.com/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://www.cylong.com/tags/C-C/"/>
    
      <category term="头文件" scheme="http://www.cylong.com/tags/%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>2018年立个FLAG-坚持写博客！</title>
    <link href="http://www.cylong.com/blog/2018/06/24/new-2018/"/>
    <id>http://www.cylong.com/blog/2018/06/24/new-2018/</id>
    <published>2018-06-24T11:51:41.000Z</published>
    <updated>2018-06-24T11:51:41.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p>时隔一年，终于想起来还有博客这种事情。工作忙的昏天黑地，但是又学不到什么太多的东西，看到很多周围的同学变得越来越厉害，有自己的目标，我也不想一直这样平淡的度过，总的想点提升不是？开始为自己的将来做准备吧！</p><p>FLAG我就立在这了！一定要坚持下去！积少成多！(╯‵□′)╯︵┻━┻<br><a id="more"></a></p><hr><blockquote><p>文章标题：<a href="http://www.cylong.com/blog/2018/06/24/new-2018/" title="2018年立个FLAG-坚持写博客！">2018年立个FLAG-坚持写博客！</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href="http://www.cylong.com/blog/2018/06/24/new-2018/" title="2018年立个FLAG-坚持写博客！">http://www.cylong.com/blog/2018/06/24/new-2018/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;时隔一年，终于想起来还有博客这种事情。工作忙的昏天黑地，但是又学不到什么太多的东西，看到很多周围的同学变得越来越厉害，有自己的目标，我也不想一直这样平淡的度过，总的想点提升不是？开始为自己的将来做准备吧！&lt;/p&gt;
&lt;p&gt;FLAG我就立在这了！一定要坚持下去！积少成多！(╯‵□′)╯︵┻━┻&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://www.cylong.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://www.cylong.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>520·答辩·校庆·校园文化夜·非酋高级成就</title>
    <link href="http://www.cylong.com/blog/2017/05/20/520/"/>
    <id>http://www.cylong.com/blog/2017/05/20/520/</id>
    <published>2017-05-20T15:24:51.000Z</published>
    <updated>2017-05-20T15:24:51.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p>经过了几个月的时间，终于完成了大学的最后一项任务：毕业设计（包括毕业项目和毕业论文）。当然，答辩这天正好赶上校庆，赶上校园文化夜，赶上期待已久的阴阳师高级非酋成就。赶上一切的一切。这一天给我的惊喜太多，给我的纪念太多，这一天，应该是本科毕业前第一个有意义的一天（以后还有毕业典礼什么的啊！o(<em>￣▽￣</em>)ブ）必须把这么重要的一天记下来！【以下图片都是手机拍摄的！原谅我的渣画质！】</p><a id="more"></a><h1 id="毕业答辩"><a href="#毕业答辩" class="headerlink" title="毕业答辩"></a>毕业答辩</h1><p>之前还在想，这是大学最后一次“作业”了，而且并不是那么容易。没想到真投入进去的时候，好像并没有那么难。之前还听学长说论文有多难写，要修改很多遍。答辩时还有人不过，等着第二次答辩。但真正自己做起来，投入进去后，就不会有什么担心了，写完论文的时候，我还在想，我竟然不知不觉写了这么多字。为了防止学校查重不过，自己还花了钱提前查重！进到答辩现场的时候，说不紧张是肯定没人信的，好歹评审老师是那种比较逗逼的人（CZY &amp; LJ），并没有给学生太大的压力。一下午竟然就这么快过去了！宣布通过名单的时候还是难以置信，自己就这样要毕业了呢，以至于后面我一直问思思姐，我真的过了么？可以毕业了么？其实只要自己认真做了，毕业还是很简单的。最重要的一点是！我忘记拍照留念了啊！还是当时太紧张了啊！(╯‵□′)╯︵┻━┻</p><h1 id="校庆"><a href="#校庆" class="headerlink" title="校庆"></a>校庆</h1><p>520这天还是南大的校庆，每次校庆，学校都会发两张5元餐券，以前一直都是用一张留一张纪念，但是后来都找不到了呢！所以这次要拍照留念！哈哈哈哈！(●’◡’●)</p><p><img src="520校庆餐券.jpg" alt="520校庆餐券"></p><p>答辩完出来的时候看到了热烈庆祝南京大学建校115周年的展板【其实去答辩的时候就看到了，但那个时候谁还有心思拍照呢？】不完美的是展板上写满了祝福的话或者名字啥的，虽然大家并无恶意，不过整个展板拍照后就感觉好乱╮(╯▽╰)╭</p><p><img src="校庆.jpg" alt="校庆"></p><h1 id="非酋高级成就"><a href="#非酋高级成就" class="headerlink" title="非酋高级成就"></a>非酋高级成就</h1><p>就在去仙林校区【我在鼓楼校区】参加校园文化夜的地铁上，思思姐帮我抽卡，庆祝下答辩完成。意料之内的没有SSR，但是发现拿到了期待已久的高级非酋成就！【抽卡400张没有SSR的成就】虽然这是非洲人的一种表现，但是我早就习惯了呢，而且我在意的是500连抽没有SSR的非洲阴阳师成就，会送一个稀有头像框——月见黑。这比抽到SSR的概率低的多啊。</p><p><img src="非酋高级成就.jpg" alt="非酋高级成就"></p><h1 id="校园文化夜"><a href="#校园文化夜" class="headerlink" title="校园文化夜"></a>校园文化夜</h1><p>这是大学四年里第三次参加了，也是最后一次。大一大二就在仙林，每年都会参加，大三搬到鼓楼，有事耽搁了一次没去。文化夜还是老样子，社团、院系都有自己的展台，在宿舍区中间的路上。先去领盖章的一页纸，每去一个展台玩小游戏都会帮你盖章，然后去领奖品。由于答辩结束的比较晚，去到仙林都已经快8点了，首先当然是找软院的展台啊！我和思思姐正玩着呢，突然看到有人坐在电脑前，玩着小游戏。我就好奇的凑过去，这不是软院的传统，大一时候程序设计大赛做的小游戏么？赶紧上去试玩了一下，相比之下，真的比我当时做的好多了呢，长江后浪推前浪啊~接下来看到了漂亮的汉服社小姐姐，思思姐每次来都会试穿汉服让我拍照呢。</p><p><img src="大四穿汉服的思思姐.jpg" alt="大四穿汉服的思思姐"></p><p>下面这张是从思思姐那要来的大一时候穿汉服的思思姐，因为那个时候还没在一起呢。【// 相比之下是不是胖了好多！つ﹏⊂】</p><p><img src="大一穿汉服的思思姐.jpg" alt="大一穿汉服的思思姐"></p><p>后来又遇到了一个听歌识曲的游戏，我问他，有动漫方面的么？他先放了一首魔卡少女樱的主题曲，又放了一首四驱兄弟的主题曲，都被我猜到了，毕竟这都是童年呢！最后放了一首虹猫蓝兔七侠传，我竟然没听出来，看来要补番了！没逛几个展台，发现大家基本上都在收拾东西，差不多结束了，我和思思姐准备去换礼物了，然后……工作人员说礼物已经发完了。(╯‵□′)╯︵┻━┻</p><h1 id="520"><a href="#520" class="headerlink" title="520"></a>520</h1><p>520这天怎么少得了秀恩爱呢！毕设一起做、一起答辩、一起去仙林参加校园文化夜，感谢思思姐一直的陪伴。以后也会是开开心心的每一天呢(<em>^_^</em>)</p><p><img src="回来的地铁上.jpg" alt="回来的地铁上"></p><hr><blockquote><p>文章标题：<a href="http://www.cylong.com/blog/2017/05/20/520/" title="520·答辩·校庆·校园文化夜·非酋高级成就">520·答辩·校庆·校园文化夜·非酋高级成就</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href="http://www.cylong.com/blog/2017/05/20/520/" title="520·答辩·校庆·校园文化夜·非酋高级成就">http://www.cylong.com/blog/2017/05/20/520/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;经过了几个月的时间，终于完成了大学的最后一项任务：毕业设计（包括毕业项目和毕业论文）。当然，答辩这天正好赶上校庆，赶上校园文化夜，赶上期待已久的阴阳师高级非酋成就。赶上一切的一切。这一天给我的惊喜太多，给我的纪念太多，这一天，应该是本科毕业前第一个有意义的一天（以后还有毕业典礼什么的啊！o(&lt;em&gt;￣▽￣&lt;/em&gt;)ブ）必须把这么重要的一天记下来！【以下图片都是手机拍摄的！原谅我的渣画质！】&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://www.cylong.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://www.cylong.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Chrome 配置 SwitchyOmega</title>
    <link href="http://www.cylong.com/blog/2017/04/09/chrome-SwitchyOmega/"/>
    <id>http://www.cylong.com/blog/2017/04/09/chrome-SwitchyOmega/</id>
    <published>2017-04-08T18:12:39.000Z</published>
    <updated>2017-04-08T18:12:39.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p>此文章是以 Shadowsocks 代理为例，若想使用 Shadowsocks 请先安装对应系统的客户端并启动。详情请参考：</p><blockquote><p><a href="/blog/2016/05/26/shadowsocks/" title="站在 Shadowsocks 的肩膀上发现精彩的世界">站在 Shadowsocks 的肩膀上发现精彩的世界</a></p></blockquote><h1 id="Chrome-浏览器"><a href="#Chrome-浏览器" class="headerlink" title="Chrome 浏览器"></a>Chrome 浏览器</h1><p>无论是用户体验、强大的功能还是丰富的扩展程序都完爆国内的各种浏览器好不好(╯‵□′)╯︵┻━┻。强烈推荐啊！目前已经可以在不翻墙的情况下去 <a href="http://www.google.cn/chrome/browser/desktop/index.html" title="Chrome（桌面版）" target="_blank" rel="noopener">下载 Chrome（桌面版）</a>了，账号数据同步方面也不需要翻墙了。【鼓掌撒花<em>★,°</em>:.☆(￣▽￣)/$:<em>.°★</em> 。】</p><h1 id="SwitchyOmega"><a href="#SwitchyOmega" class="headerlink" title="SwitchyOmega"></a>SwitchyOmega</h1><p>Google Chrome 浏览器上的一个代理扩展程序，可以轻松快捷地管理和切换多个代理设置。比如我们接下来要介绍的 <code>自动切换模式</code>。</p><a id="more"></a><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>点击 <a href="https://github.com/FelisCatus/SwitchyOmega/releases" title="FelisCatus/SwitchyOmega" target="_blank" rel="noopener">Github-SwitchyOmega</a>，下载页面有详细的安装教程，仔细看一下就好。</p><h2 id="配置-Shadowsocks-情景模式"><a href="#配置-Shadowsocks-情景模式" class="headerlink" title="配置 Shadowsocks 情景模式"></a>配置 Shadowsocks 情景模式</h2><ol><li>打开 Chrome， 点击右上角的 <span class="fa fa-globe" aria-hidden="true"></span> 图标，再点击 <code>选项</code>。<br><img src="Shadowsocks-icon.png" alt="Shadowsocks 图标"></li><li>点击左侧的 <code>新建情景模式</code>，输入情景模式名称 <code>Shadowsocks</code>【自己任意设置名称】，类型选择第一个<code>代理服务器</code>。创建完成后做如下配置：<br><img src="new.png" alt="新建情景模式"><br>你也可以自己设置不代理的地址列表。如上图。</li><li>保存后你就可以通过这个情景模式科学上网了~</li></ol><h2 id="配置自动切换模式"><a href="#配置自动切换模式" class="headerlink" title="配置自动切换模式"></a>配置自动切换模式</h2><p>配置好 Shadowsocks 情景模式后虽然可以使用 Chrome 浏览器科学上网了，但是这样的话无论你访问什么网站都会走代理，有时候访问国内的一些网站反而会很慢，这时候自动切换模式就解决了这个问题。下面介绍一下如何配置自动切换模式。</p><ol><li>点击左侧的 <code>自动切换</code>，或者自己新建情景模式，类型选择第二个 <code>自动切换模式</code>。然后做如下配置：<br><img src="auto.png" alt="自动切换模式"></li></ol><ul><li><code>切换规则</code> 是在访问 <code>条件设置</code> 的域名时候使用后面设置的 <code>情景模式</code>。比如图中我设置 <code>*.google.com</code> 和 <code>*.github.com</code> 使用 <code>Shadowsocks</code> 情景模式【刚刚创建的那个情景模式】。我们可以点击 <code>添加条件</code> 来添加自己的规则。</li><li>将图中 <code>规则列表规则</code> 前面的框打√，再将后面的 <code>情景模式</code> 设置为 <code>Shadowsocks</code>，意思是规则列表中的内容，我们使用 <code>Shadowsocks</code> 情景模式。然后 <code>规则列表设置</code> 中：<ul><li>规则列表格式： AutoProxy；</li><li>规则列表网址： <a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt" target="_blank" rel="noopener">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</a></li></ul></li><li>这样设置完成 <code>规则列表规则</code> 后就不需要在切换规则中一个一个添加条件了。</li><li><code>切换规则</code> 最后一行的 <code>默认情景模式</code> 代表不在规则列表中网址我们使用 <code>直接连接</code> 情景模式，也就是说不走代理。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote><p><a href="https://github.com/FelisCatus/SwitchyOmega" title="FelisCatus/SwitchyOmega" target="_blank" rel="noopener">Github-SwitchyOmega</a><br><a href="https://github.com/gfwlist/gfwlist" title="gfwlist/gfwlist" target="_blank" rel="noopener">Github-gfwlist</a></p></blockquote><hr><blockquote><p>文章标题：<a href="http://www.cylong.com/blog/2017/04/09/chrome-SwitchyOmega/" title="Chrome 配置 SwitchyOmega">Chrome 配置 SwitchyOmega</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href="http://www.cylong.com/blog/2017/04/09/chrome-SwitchyOmega/" title="Chrome 配置 SwitchyOmega">http://www.cylong.com/blog/2017/04/09/chrome-SwitchyOmega/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;此文章是以 Shadowsocks 代理为例，若想使用 Shadowsocks 请先安装对应系统的客户端并启动。详情请参考：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;/blog/2016/05/26/shadowsocks/&quot; title=&quot;站在 Shadowsocks 的肩膀上发现精彩的世界&quot;&gt;站在 Shadowsocks 的肩膀上发现精彩的世界&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Chrome-浏览器&quot;&gt;&lt;a href=&quot;#Chrome-浏览器&quot; class=&quot;headerlink&quot; title=&quot;Chrome 浏览器&quot;&gt;&lt;/a&gt;Chrome 浏览器&lt;/h1&gt;&lt;p&gt;无论是用户体验、强大的功能还是丰富的扩展程序都完爆国内的各种浏览器好不好(╯‵□′)╯︵┻━┻。强烈推荐啊！目前已经可以在不翻墙的情况下去 &lt;a href=&quot;http://www.google.cn/chrome/browser/desktop/index.html&quot; title=&quot;Chrome（桌面版）&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;下载 Chrome（桌面版）&lt;/a&gt;了，账号数据同步方面也不需要翻墙了。【鼓掌撒花&lt;em&gt;★,°&lt;/em&gt;:.☆(￣▽￣)/$:&lt;em&gt;.°★&lt;/em&gt; 。】&lt;/p&gt;
&lt;h1 id=&quot;SwitchyOmega&quot;&gt;&lt;a href=&quot;#SwitchyOmega&quot; class=&quot;headerlink&quot; title=&quot;SwitchyOmega&quot;&gt;&lt;/a&gt;SwitchyOmega&lt;/h1&gt;&lt;p&gt;Google Chrome 浏览器上的一个代理扩展程序，可以轻松快捷地管理和切换多个代理设置。比如我们接下来要介绍的 &lt;code&gt;自动切换模式&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Shadowsocks" scheme="http://www.cylong.com/categories/Shadowsocks/"/>
    
    
      <category term="shadowsocks" scheme="http://www.cylong.com/tags/shadowsocks/"/>
    
      <category term="翻墙" scheme="http://www.cylong.com/tags/%E7%BF%BB%E5%A2%99/"/>
    
      <category term="SwitchyOmega" scheme="http://www.cylong.com/tags/SwitchyOmega/"/>
    
  </entry>
  
  <entry>
    <title>多说评论迁移至 Disqus - Java 实现</title>
    <link href="http://www.cylong.com/blog/2017/04/05/duoshuo-to-disqus/"/>
    <id>http://www.cylong.com/blog/2017/04/05/duoshuo-to-disqus/</id>
    <published>2017-04-04T17:01:33.000Z</published>
    <updated>2017-04-04T17:01:33.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p>在网上找了一圈后，很多人都造过轮子，但是由于年代久远，多说和 Disqus 的评论格式可能发生变化，试了一些后并没有一个成功。无奈自己开始造轮子，不过看完两种评论文件格式后，发现其实还是瞒简单的，于是就用 Java 实现了一个。【为了节省时间就用自己最擅长的 Java 了，虽然其他语言可能会更快更方便的使用( ╯□╰ )】。下面附上工具链接和使用方法。</p><blockquote><p><a href="https://github.com/cylong1016/DuoshuoToDisqus" title="工具源码地址" target="_blank" rel="noopener">工具源码地址</a></p></blockquote><a id="more"></a><h1 id="导出多说评论"><a href="#导出多说评论" class="headerlink" title="导出多说评论"></a>导出多说评论</h1><ol><li>进入多说后台选择 <code>工具-&gt;导出数据</code>。</li><li>勾上 <code>包含文章数据</code> 和 <code>包含评论数据</code> 两个选项。</li><li>导出后是一个 JSON 文件，为了方便查看可以使用 <a href="http://tool.oschina.net/codeformat/json" title="在线代码格式化" target="_blank" rel="noopener">在线代码格式化</a> 工具。</li></ol><h1 id="使用工具转化"><a href="#使用工具转化" class="headerlink" title="使用工具转化"></a>使用工具转化</h1><ol><li><a href="https://github.com/cylong1016/DuoshuoToDisqus/archive/master.zip" target="_blank" rel="noopener">点击下载</a> 转化工具，并解压。</li><li>将导出的多说 JSON 文件重命名为 <code>duoshuo.json</code> 放入 <code>data</code> 文件夹下。【先删除掉存在的文件吧，其实是我的多说评论数据】</li><li>双击运行 <code>run.bat</code>。将会在 <code>data</code> 文件夹下生成 <code>duoshuo-format.json</code> 【格式化后的多说评论文件，方便查看】和 <code>disqus.xml</code>【导入到 Disqus 的 XML 文件】。</li></ol><p><strong>注意：如果发现并没有生成以上的两个文件，或者生成的文件数据有误，请使用以下方式运行程序。</strong></p><ol start="5"><li>按住 <code>Shift</code> + 鼠标右键选择 <code>在此处打开命令行窗口</code>【Windows】或者打开终端进入项目目录下【Linux】。</li><li><p>输入以下命令并回车：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar DuoshuoToDisqus.jar</span><br></pre></td></tr></table></figure></li><li><p>这种方式运行的好处是可以看到程序出错信息，同时你可以在命令最后输入你的多说评论文件路径【就不用将多说评论文件放入到 <code>data</code> 文件夹下了。】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar DuoshuoToDisqus.jar C:\duoshuo.json</span><br></pre></td></tr></table></figure></li></ol><h1 id="导入到-Disqus-中"><a href="#导入到-Disqus-中" class="headerlink" title="导入到 Disqus 中"></a>导入到 Disqus 中</h1><ol><li><a href="https://import.disqus.com/" title="Import and Export - Disqus" target="_blank" rel="noopener">点击链接</a> 进入到导入页面，选择你要导入评论的站点。</li><li>选择刚刚生成的 <code>disqus.xml</code> 文件，后面的选项选择 <code>WordPress(WXR)</code>，点击 <code>Upload</code>。</li><li>接下来静静的等待导入完成，可以看到导入的评论和文章数量，如果出错的话可以看到错误。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>整个工具其实就是解析多说的 JSON 文件并转化成 Disqus 评论的 XML 文件。想要自己用 Java 实现的可以参考以下链接：</p><blockquote><p><a href="http://dev.duoshuo.com/docs/500fc3cdb17b12d24b00000a" title="多说评论格式" target="_blank" rel="noopener">多说评论格式</a><br><a href="https://help.disqus.com/customer/portal/articles/472150-custom-xml-import-format" title="Custom XML Import Format" target="_blank" rel="noopener">Disqus 评论格式</a><br><a href="/blog/2017/03/31/jackson-java-json/" title="Jackson - Java Object 与 JSON 之间的转化工具">Jackson - Java Object 与 JSON 之间的转化工具</a><br><a href="/blog/2017/04/04/java-dom-xml/" title="Java 通过 DOM 方式解析、创建 XML">Java 通过 DOM 方式解析、创建 XML</a><br><a href="https://github.com/cylong1016/DuoshuoToDisqus" title="工具源码地址" target="_blank" rel="noopener">工具源码地址</a></p></blockquote><p>此工具需要 Java 运行环境，可以去网上搜索安装配置一下。另外此工具没有做什么非法输入的处理，所以不要尝试做一些奇怪的事情。如果运行出错请检查一下你的源多说 JSON 文件是否有错误或者使用方式是否有错，有任何问题或者想要我帮忙转化的请在下方留言或者 <a href="/about/" title="关于我">联系我</a>。很高兴可以帮助到你(●’◡’●)。</p><hr><blockquote><p>文章标题：<a href="http://www.cylong.com/blog/2017/04/05/duoshuo-to-disqus/" title="多说评论迁移至 Disqus - Java 实现">多说评论迁移至 Disqus - Java 实现</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href="http://www.cylong.com/blog/2017/04/05/duoshuo-to-disqus/" title="多说评论迁移至 Disqus - Java 实现">http://www.cylong.com/blog/2017/04/05/duoshuo-to-disqus/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;在网上找了一圈后，很多人都造过轮子，但是由于年代久远，多说和 Disqus 的评论格式可能发生变化，试了一些后并没有一个成功。无奈自己开始造轮子，不过看完两种评论文件格式后，发现其实还是瞒简单的，于是就用 Java 实现了一个。【为了节省时间就用自己最擅长的 Java 了，虽然其他语言可能会更快更方便的使用( ╯□╰ )】。下面附上工具链接和使用方法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/cylong1016/DuoshuoToDisqus&quot; title=&quot;工具源码地址&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;工具源码地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://www.cylong.com/categories/Hexo/"/>
    
    
      <category term="hexo" scheme="http://www.cylong.com/tags/hexo/"/>
    
      <category term="java" scheme="http://www.cylong.com/tags/java/"/>
    
      <category term="disqus" scheme="http://www.cylong.com/tags/disqus/"/>
    
  </entry>
  
  <entry>
    <title>Java 通过 DOM 方式解析、创建 XML</title>
    <link href="http://www.cylong.com/blog/2017/04/04/java-dom-xml/"/>
    <id>http://www.cylong.com/blog/2017/04/04/java-dom-xml/</id>
    <published>2017-04-04T15:49:23.000Z</published>
    <updated>2020-06-06T08:31:19.088Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="DOM-简介"><a href="#DOM-简介" class="headerlink" title="DOM 简介"></a>DOM 简介</h1><p>DOM（Document Object Model) 是 W3C 处理 XML 的标准 API，不仅 Java 其他很多语言，比如 Javascript、PHP等等语言都实现了该标准。Java 类库支持 DOM 操作【也就是说不需要下载依赖其他包】。DOM 以树状结构组织节点和信息的集合，这种结构允许开发人员对 XML 文档进行增删改查。为了分析该树状结构，我们需要加载整个 XML 文档进行构造分析，所以消耗资源比较大，建议在操作小文件的时候使用。</p><a id="more"></a><h1 id="创建-XML-文档"><a href="#创建-XML-文档" class="headerlink" title="创建 XML 文档"></a>创建 XML 文档</h1><ol><li><p>创建 XML Document 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建 XML Document 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> XML Document 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cylong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2017年4月5日 上午12:19:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Document <span class="title">createXMLDocument</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</span><br><span class="line">    DocumentBuilder builder = <span class="keyword">null</span>;</span><br><span class="line">    Document document = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        builder = factory.newDocumentBuilder();</span><br><span class="line">        document = builder.newDocument();</span><br><span class="line">        Element root = document.createElement(<span class="string">"college"</span>);</span><br><span class="line">        document.appendChild(root);</span><br><span class="line"></span><br><span class="line">        Element student = document.createElement(<span class="string">"student"</span>);</span><br><span class="line">        student.setAttribute(<span class="string">"id"</span>, <span class="string">"0"</span>);</span><br><span class="line">        Element name = document.createElement(<span class="string">"name"</span>);</span><br><span class="line">        name.appendChild(document.createTextNode(<span class="string">"cylong"</span>));</span><br><span class="line">        student.appendChild(name);</span><br><span class="line">        Element biography = document.createElement(<span class="string">"biography"</span>);</span><br><span class="line">        biography.appendChild(document.createCDATASection(<span class="string">"Hello"</span>));</span><br><span class="line">        student.appendChild(biography);</span><br><span class="line">        Element age = document.createElement(<span class="string">"age"</span>);</span><br><span class="line">        age.appendChild(document.createTextNode(<span class="string">"24"</span>));</span><br><span class="line">        student.appendChild(age);</span><br><span class="line"></span><br><span class="line">        Element student1 = document.createElement(<span class="string">"student"</span>);</span><br><span class="line">        student1.setAttribute(<span class="string">"id"</span>, <span class="string">"1"</span>);</span><br><span class="line">        Element name1 = document.createElement(<span class="string">"name"</span>);</span><br><span class="line">        name1.appendChild(document.createTextNode(<span class="string">"cylong1"</span>));</span><br><span class="line">        student1.appendChild(name1);</span><br><span class="line">        Element biography1 = document.createElement(<span class="string">"biography"</span>);</span><br><span class="line">        biography1.appendChild(document.createCDATASection(<span class="string">"World"</span>));</span><br><span class="line">        student1.appendChild(biography1);</span><br><span class="line">        Element age1 = document.createElement(<span class="string">"age"</span>);</span><br><span class="line">        age1.appendChild(document.createTextNode(<span class="string">"25"</span>));</span><br><span class="line">        student1.appendChild(age1);</span><br><span class="line"></span><br><span class="line">        root.appendChild(document.createComment(<span class="string">"学生0"</span>));</span><br><span class="line">        root.appendChild(student);</span><br><span class="line">        root.appendChild(document.createComment(<span class="string">"学生1"</span>));</span><br><span class="line">        root.appendChild(student1);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ParserConfigurationException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> document;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将创建的 XML Document 写入到文件中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将创建的 XML Document 写入到文件中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> document</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> path 文件路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cylong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2017年4月3日 上午2:39:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeXML</span><span class="params">(Document document, String path)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">TransformerFactory tf = TransformerFactory.newInstance();</span><br><span class="line">Transformer transformer = tf.newTransformer();</span><br><span class="line">DOMSource source = <span class="keyword">new</span> DOMSource(document);</span><br><span class="line">transformer.setOutputProperty(OutputKeys.ENCODING, <span class="string">"utf8"</span>);</span><br><span class="line">transformer.setOutputProperty(OutputKeys.INDENT, <span class="string">"yes"</span>);</span><br><span class="line">PrintWriter pw = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileOutputStream(path));</span><br><span class="line">StreamResult result = <span class="keyword">new</span> StreamResult(pw);</span><br><span class="line">    transformer.transform(source, result);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (TransformerConfigurationException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (TransformerException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="解析-XML-文档"><a href="#解析-XML-文档" class="headerlink" title="解析 XML 文档"></a>解析 XML 文档</h1><ol><li><p>解析 XML 文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析 XML 文档</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> path XML 文档路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cylong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2017年4月3日 上午2:48:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parserXML</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span><br><span class="line">        DocumentBuilder db = dbf.newDocumentBuilder();</span><br><span class="line">        Document document = db.parse(path);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// optional, but recommended</span></span><br><span class="line">        <span class="comment">// read this - http://stackoverflow.com/questions/13786607/normalization-in-dom-parsing-with-java-how-does-it-work</span></span><br><span class="line">        document.getDocumentElement().normalize();</span><br><span class="line"></span><br><span class="line">        Element root = document.getDocumentElement();</span><br><span class="line">        System.out.println(<span class="string">"Root element : "</span> + root.getNodeName());</span><br><span class="line">        NodeList students = root.getElementsByTagName(<span class="string">"student"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; students.getLength(); i++) &#123;</span><br><span class="line">            Node student = students.item(i);</span><br><span class="line">            System.out.println(student.getNodeName());</span><br><span class="line"></span><br><span class="line">            NodeList info = student.getChildNodes();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; info.getLength(); j++) &#123;</span><br><span class="line">                Node meta = info.item(j);</span><br><span class="line">                <span class="keyword">if</span> (meta.getNodeType() == Node.ELEMENT_NODE) &#123;</span><br><span class="line">                    System.out.println(meta.getNodeName() + <span class="string">":"</span> + meta.getTextContent());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ParserConfigurationException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SAXException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意<br>可以 <a href="http://stackoverflow.com/questions/13786607/normalization-in-dom-parsing-with-java-how-does-it-work" target="_blank" rel="noopener">点此链接</a> 了解其用处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// optional, but recommended</span></span><br><span class="line"><span class="comment">// read this - http://stackoverflow.com/questions/13786607/normalization-in-dom-parsing-with-java-how-does-it-work</span></span><br><span class="line">document.getDocumentElement().normalize();</span><br></pre></td></tr></table></figure></li></ol><h1 id="参考-amp-感谢"><a href="#参考-amp-感谢" class="headerlink" title="参考&amp;感谢"></a>参考&amp;感谢</h1><blockquote><p><a href="https://github.com/cylong1016/CodeJava/blob/master/src/cylong/xml/ParserXML.java" target="_blank" rel="noopener">Github 完整的代码案例</a><br><a href="https://www.mkyong.com/java/how-to-read-xml-file-in-java-dom-parser/" target="_blank" rel="noopener">How to read XML file in Java – (DOM Parser)</a></p></blockquote><hr><blockquote><p>文章标题：<a href="http://www.cylong.com/blog/2017/04/04/java-dom-xml/" title="Java 通过 DOM 方式解析、创建 XML">Java 通过 DOM 方式解析、创建 XML</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href="http://www.cylong.com/blog/2017/04/04/java-dom-xml/" title="Java 通过 DOM 方式解析、创建 XML">http://www.cylong.com/blog/2017/04/04/java-dom-xml/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;DOM-简介&quot;&gt;&lt;a href=&quot;#DOM-简介&quot; class=&quot;headerlink&quot; title=&quot;DOM 简介&quot;&gt;&lt;/a&gt;DOM 简介&lt;/h1&gt;&lt;p&gt;DOM（Document Object Model) 是 W3C 处理 XML 的标准 API，不仅 Java 其他很多语言，比如 Javascript、PHP等等语言都实现了该标准。Java 类库支持 DOM 操作【也就是说不需要下载依赖其他包】。DOM 以树状结构组织节点和信息的集合，这种结构允许开发人员对 XML 文档进行增删改查。为了分析该树状结构，我们需要加载整个 XML 文档进行构造分析，所以消耗资源比较大，建议在操作小文件的时候使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.cylong.com/categories/Java/"/>
    
    
      <category term="java" scheme="http://www.cylong.com/tags/java/"/>
    
      <category term="dom" scheme="http://www.cylong.com/tags/dom/"/>
    
      <category term="xml" scheme="http://www.cylong.com/tags/xml/"/>
    
  </entry>
  
  <entry>
    <title>Jackson - Java Object 与 JSON 之间的转化工具</title>
    <link href="http://www.cylong.com/blog/2017/03/31/jackson-java-json/"/>
    <id>http://www.cylong.com/blog/2017/03/31/jackson-java-json/</id>
    <published>2017-03-31T13:55:36.000Z</published>
    <updated>2020-06-06T08:31:19.088Z</updated>
    
    <content type="html"><![CDATA[<hr><p>一直在找一个 Java Object 与 JSON 之间方便快捷的转化工具，在舍友的推荐下了解到了 Jackson，使用之后对其爱不释手，现在推荐给大家。</p><h1 id="JSON-简介"><a href="#JSON-简介" class="headerlink" title="JSON 简介"></a>JSON 简介</h1><blockquote><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。 易于人阅读和编写。同时也易于机器解析和生成。 它基于JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。 这些特性使JSON成为理想的数据交换语言。</p><footer><strong>JSON 中文</strong><cite><a href="http://www.json.org/json-zh.html" target="_blank" rel="noopener">介绍 JSON</a></cite></footer></blockquote><p>以上链接中包含了 JSON 的详细介绍，其实 JSON 对象【”名称/值”对的集合】和 Java 对象是对应的，JSON 数组【值的有序列表】和 Java 的数组是对应的。下面就用一些具体的实例來说明。</p><a id="more"></a><h1 id="JSON-和-Java-的映射"><a href="#JSON-和-Java-的映射" class="headerlink" title="JSON 和 Java 的映射"></a>JSON 和 Java 的映射</h1><ol><li><p>JSON 示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot; : &quot;cylong&quot;,</span><br><span class="line">  &quot;age&quot; : 33,</span><br><span class="line">  &quot;position&quot; : &quot;Developer&quot;,</span><br><span class="line">  &quot;salary&quot; : 7500,</span><br><span class="line">  &quot;skills&quot; : [ &quot;java&quot;, &quot;python&quot; ],</span><br><span class="line">  &quot;date&quot; : &quot;2017-03-31 12:29:42&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对应的 Java 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Staff</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">private</span> String position;</span><br><span class="line">  <span class="keyword">private</span> BigDecimal salary;</span><br><span class="line">  <span class="keyword">private</span> List&lt;String&gt; skills;</span><br><span class="line">  <span class="comment">// Jackson 语法</span></span><br><span class="line">  <span class="meta">@JsonFormat</span>(shape = JsonFormat.Shape.STRING, pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>, timezone = <span class="string">"GMT+8"</span>)</span><br><span class="line">  <span class="keyword">private</span> Date date;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>相信以上的例子可以让你很好的理解两者之间的对应关系。其实不仅 Java，其他语言也类似。</p><h1 id="Jackson-使用"><a href="#Jackson-使用" class="headerlink" title="Jackson 使用"></a>Jackson 使用</h1><ol><li>在 <code>pom.xml</code> 中添加依赖项<figure class="highlight xml"><figcaption><span>pom.xml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Java 对象转化成 JSON</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">Staff obj = <span class="keyword">new</span> Staff();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 Java 对象转化成 JSON 并写入文件中</span></span><br><span class="line">mapper.writeValue(<span class="keyword">new</span> File(<span class="string">"c:\\file.json"</span>), obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 Java 对象转化成 JSON 字符串</span></span><br><span class="line">String jsonInString = mapper.writeValueAsString(obj);</span><br></pre></td></tr></table></figure></li><li><p>JSON 转化成 Java 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">String jsonInString = <span class="string">"&#123;'name' : 'mkyong'&#125;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从文件中读取 JSON 并转化成 Java 对象</span></span><br><span class="line">Staff obj = mapper.readValue(<span class="keyword">new</span> File(<span class="string">"c:\\file.json"</span>), Staff<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 URL 中读取 JSON 并转化成 Java 对象</span></span><br><span class="line">Staff obj = mapper.readValue(<span class="keyword">new</span> URL(<span class="string">"http://mkyong.com/api/staff.json"</span>), Staff<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 JSON 字符串转化成 Java 对象</span></span><br><span class="line">Staff obj = mapper.readValue(jsonInString, Staff<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure></li></ol><h1 id="参考-amp-感谢"><a href="#参考-amp-感谢" class="headerlink" title="参考&amp;感谢"></a>参考&amp;感谢</h1><p>其实以上的内容在下面的链接中均有详细的介绍，我只是一个代码的搬运工( ╯□╰ )，就当是自己的笔记好了。</p><blockquote><p><a href="https://www.mkyong.com/java/jackson-2-convert-java-object-to-from-json/" title="Jackson 2 – Convert Java Object to / from JSON" target="_blank" rel="noopener">Jackson 2 – Convert Java Object to / from JSON</a> 【Jackson 使用详细教程】<br><a href="http://www.baeldung.com/jackson-serialize-dates" title="Jackson Date" target="_blank" rel="noopener">Jackson Date</a> 【有关 Jackson 对日期的处理】<br><a href="http://www.json.org/json-zh.html" title="JSON 中文文档" target="_blank" rel="noopener">JSON 中文文档</a> 【概念性的东西，最下面也有不同语言的支持】<br><a href="http://wiki.jikexueyuan.com/project/json/" title="JSON 教程 - 极客学院" target="_blank" rel="noopener">JSON 教程 - 极客学院</a> 【包含 JSON 基础介绍和在其他语言中使用 JSON】</p></blockquote><hr><blockquote><p>文章标题：<a href="http://www.cylong.com/blog/2017/03/31/jackson-java-json/" title="Jackson - Java Object 与 JSON 之间的转化工具">Jackson - Java Object 与 JSON 之间的转化工具</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href="http://www.cylong.com/blog/2017/03/31/jackson-java-json/" title="Jackson - Java Object 与 JSON 之间的转化工具">http://www.cylong.com/blog/2017/03/31/jackson-java-json/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;一直在找一个 Java Object 与 JSON 之间方便快捷的转化工具，在舍友的推荐下了解到了 Jackson，使用之后对其爱不释手，现在推荐给大家。&lt;/p&gt;
&lt;h1 id=&quot;JSON-简介&quot;&gt;&lt;a href=&quot;#JSON-简介&quot; class=&quot;headerlink&quot; title=&quot;JSON 简介&quot;&gt;&lt;/a&gt;JSON 简介&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。 易于人阅读和编写。同时也易于机器解析和生成。 它基于JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。 这些特性使JSON成为理想的数据交换语言。&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;JSON 中文&lt;/strong&gt;&lt;cite&gt;&lt;a href=&quot;http://www.json.org/json-zh.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;介绍 JSON&lt;/a&gt;&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;
&lt;p&gt;以上链接中包含了 JSON 的详细介绍，其实 JSON 对象【”名称/值”对的集合】和 Java 对象是对应的，JSON 数组【值的有序列表】和 Java 的数组是对应的。下面就用一些具体的实例來说明。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.cylong.com/categories/Java/"/>
    
    
      <category term="java" scheme="http://www.cylong.com/tags/java/"/>
    
      <category term="jackson" scheme="http://www.cylong.com/tags/jackson/"/>
    
      <category term="json" scheme="http://www.cylong.com/tags/json/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 集成 Disqus 评论</title>
    <link href="http://www.cylong.com/blog/2017/03/26/hexo-next-disqus/"/>
    <id>http://www.cylong.com/blog/2017/03/26/hexo-next-disqus/</id>
    <published>2017-03-26T14:36:12.000Z</published>
    <updated>2020-06-06T08:31:19.084Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从创建博客的时候我就纠结用国内的多说还是国外的 Disqus，鉴于多说是国内的，是中文的，而且相比国内其他的系统更加稳定，功能多样，毅然选择了多说。不过后来多说经常崩溃，总是看不到评论，一直想换成 Disqus 或者国内其他的评论系统。这次好了，不用纠结了，用了一年的多说即将在<a href="http://dev.duoshuo.com/threads/58d1169ae293b89a20c57241" title="重要通知: 多说即将关闭" target="_blank" rel="noopener">2017年6月1日关闭服务</a>，不得不换一个。在我刚开始使用 Next 主题的时候，只支持多说和 Disqus，目前已经支持了很多，可以参考：</p><blockquote><p><a href="http://theme-next.iissnan.com/third-party-services.html" title="Next 第三方服务集成" target="_blank" rel="noopener">Next 第三方服务集成</a></p></blockquote><p>我后来还是选择了 Disqus 作为新的评论系统，虽然 Disqus 在国内有时候被墙掉了，英文读起来也比较费劲，但是强大的功能和用户体验让我对 Disqus 爱不释手。至于国内也有很多评论系统可以代替多说，但是根据先前的一些系统来看，最后都没有走下去呢╮(╯▽╰)╭。 我觉得 Disqus 不会半路 GG 吧 (╯‵□′)╯︵┻━┻</p><a id="more"></a><h1 id="Next-主题集成-Disqus"><a href="#Next-主题集成-Disqus" class="headerlink" title="Next 主题集成 Disqus"></a>Next 主题集成 Disqus</h1><ol><li>登陆 <a href="https://disqus.com" title="Disqus" target="_blank" rel="noopener">Disqus</a>，点击 <code>GET STARTED</code> 开始创建站点，之后就可以点击右上角的 <code>Admin</code> 进入后台管理。<br><img src="disqus_index.png" alt="Disqus 创建站点"></li><li>点击第二条 <code>I want to install Disqus on my site</code>。<br><img src="disqus_intent.png" alt></li><li>按照表单填写信息，记住 <code>Website Name</code> 这条属性。<br><img src="disqus_create.png" alt></li><li>接下来按照指引填写信息，完成第三步 <code>3.Configure Disqus</code> 后点击最下面 <code>Complete Setup</code> 完成创建。【中间会有一个嵌入代码的案例，不是 Next 主题的可以参考下】<br><img src="disqus_settings.png" alt></li><li>接下来配置主题下面的 <code>config.yml</code> 文件。<blockquote><p>大于等于5.1.1版本，将 disqus 下的 enable 设定为 true，同时提供您的 shortname。 count 用于指定是否显示评论数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">disqus:</span><br><span class="line">  enable: true</span><br><span class="line">  shortname:</span><br><span class="line">  count: true</span><br></pre></td></tr></table></figure><p>小于5.1.1 版本，设定 disqus_shortname 的值即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disqus_shortname: shortname</span><br></pre></td></tr></table></figure></blockquote></li><li>接下来就可以进入后台管理设置你的评论了。</li></ol><h1 id="多说评论迁移至-Disqus"><a href="#多说评论迁移至-Disqus" class="headerlink" title="多说评论迁移至 Disqus"></a>多说评论迁移至 Disqus</h1><p>毕竟多说我也用了一年，积攒了一点评论，就这样放弃非常的舍不得，不过多说导出的评论文件无法直接导入到 Disqus 中，多说导出的是 JSON 文件，Disqus 支持的导入格式是 WordPress 导出的的 XML 文件。在网上找了一些，发现都不好用，于是自己就造了一个轮子，在下面的链接中有详细的说明。欢迎使用并提出宝贵的意见(●’◡’●)</p><blockquote><p><a href="/blog/2017/04/05/duoshuo-to-disqus/" title="多说评论迁移至 Disqus">多说评论迁移至 Disqus</a></p></blockquote><hr><blockquote><p>文章标题：<a href="http://www.cylong.com/blog/2017/03/26/hexo-next-disqus/" title="Hexo 集成 Disqus 评论">Hexo 集成 Disqus 评论</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href="http://www.cylong.com/blog/2017/03/26/hexo-next-disqus/" title="Hexo 集成 Disqus 评论">http://www.cylong.com/blog/2017/03/26/hexo-next-disqus/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从创建博客的时候我就纠结用国内的多说还是国外的 Disqus，鉴于多说是国内的，是中文的，而且相比国内其他的系统更加稳定，功能多样，毅然选择了多说。不过后来多说经常崩溃，总是看不到评论，一直想换成 Disqus 或者国内其他的评论系统。这次好了，不用纠结了，用了一年的多说即将在&lt;a href=&quot;http://dev.duoshuo.com/threads/58d1169ae293b89a20c57241&quot; title=&quot;重要通知: 多说即将关闭&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;2017年6月1日关闭服务&lt;/a&gt;，不得不换一个。在我刚开始使用 Next 主题的时候，只支持多说和 Disqus，目前已经支持了很多，可以参考：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://theme-next.iissnan.com/third-party-services.html&quot; title=&quot;Next 第三方服务集成&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Next 第三方服务集成&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我后来还是选择了 Disqus 作为新的评论系统，虽然 Disqus 在国内有时候被墙掉了，英文读起来也比较费劲，但是强大的功能和用户体验让我对 Disqus 爱不释手。至于国内也有很多评论系统可以代替多说，但是根据先前的一些系统来看，最后都没有走下去呢╮(╯▽╰)╭。 我觉得 Disqus 不会半路 GG 吧 (╯‵□′)╯︵┻━┻&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://www.cylong.com/categories/Hexo/"/>
    
    
      <category term="hexo" scheme="http://www.cylong.com/tags/hexo/"/>
    
      <category term="插件" scheme="http://www.cylong.com/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>找出有序数组中 3 个和为 0 的数</title>
    <link href="http://www.cylong.com/blog/2016/11/08/three-number/"/>
    <id>http://www.cylong.com/blog/2016/11/08/three-number/</id>
    <published>2016-11-07T17:26:19.000Z</published>
    <updated>2020-06-06T08:31:19.084Z</updated>
    
    <content type="html"><![CDATA[<p>前几天偶尔看到一道题，感觉蛮有意思的，在自己思考，外加上网查询之后，找到了一个比较完美的算法解决。问题描述如下：</p><blockquote><p> 给定有序排列的N个整数，找出其中3个数相加和为0，输出所有的不重复的3个数，要求输出的结果依然有序。<br> 在单行内，输出的顺序和原来一致，每行之间的顺序和第一个数字在原数列中的顺序一致（如果相同则向后依次比较）<br> INPUT :<br> 5<br> -2 -1 0 1 2<br> OUTPUT:<br> -2 0 2<br> -1 0 1<br> INPUT :<br> 5<br> 2 2 0 -2 -4<br> OUTPUT:<br> 2 2 -4<br> 2 0 -2</p></blockquote><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol><li><p>首先思考：寻找有序数组（下文说的数组均是升序排列的）中两个和为 k 的值。很简单，两个指针 i 和 j 分别指向数组两端，计算两数的和，大于 k 则 <code>j--</code>，否则 <code>i++</code>，直到寻找到两个数和为 k 或者 <code>i &gt; j</code> 时停止。</p></li><li><p>上题中可以转换为寻找数组中两个和为 -k 的数，k 为数组中的元素，我们只需要再加一层循环，遍历数组中的值，作为 k 就可以了。</p></li><li><p>那么如何解决结果中有重复值的情况呢？比如我们输入 [-4, -2, 0, 2, 2] 这5个数，会输出两次 [-2, 0, 2]。其实这个也很好判断，当我们确定了三个数中的一个数，那么后面求出的两个数就确定下来了，比如我们确定”第一个数”是 -5，那么可能求出后面两个数是 [2, 3] 和 [1, 4]，当我们循环到下一个”第一个数”的时候，如果还是 -5，那求出的数据肯定还是重复的，所以直接跳过就好。【这块的描述好像不是很清楚啊！(╯‵□′)╯︵┻━┻ 不明白的话看下面的代码肯定一下子就明白了呢！】</p></li></ol><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">findThreeNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr, <span class="keyword">bool</span> asc)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> size = arr.size();</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;<span class="comment">// 保存结果</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;<span class="comment">// 保证"第一个数"在数组中</span></span><br><span class="line"><span class="keyword">int</span> m = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n = size - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (m &lt; n) &#123;</span><br><span class="line"><span class="keyword">int</span> sum = arr[m] + arr[n];<span class="comment">// 另外两个数的和</span></span><br><span class="line"><span class="keyword">if</span> (sum + arr[i]  &gt; <span class="number">0</span>) &#123;</span><br><span class="line">asc ? n-- : m++;<span class="comment">// 升序和降序的操作不一样</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sum + arr[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">asc ? m++ : n--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">// 找到三数和为0</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(<span class="number">3</span>);</span><br><span class="line">v[<span class="number">0</span>] = arr[i];</span><br><span class="line">v[<span class="number">1</span>] = arr[m];</span><br><span class="line">v[<span class="number">2</span>] = arr[n];</span><br><span class="line">result.push_back(v);</span><br><span class="line"></span><br><span class="line"><span class="comment">// "第二个数"和"第三个数"分别判断其下个数是否重复</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">m++;</span><br><span class="line">&#125; <span class="keyword">while</span> (m &lt; n &amp;&amp; arr[m - <span class="number">1</span>] == arr[m]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">n--;</span><br><span class="line">&#125; <span class="keyword">while</span> (m &lt; n &amp;&amp; arr[n + <span class="number">1</span>] == arr[n]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外层循环"第一个数"，如果下一个"第一个数"相同，则为重复数据</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; size - <span class="number">2</span> &amp;&amp; arr[i + <span class="number">1</span>] == arr[i]) &#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">bool</span> asc = <span class="literal">true</span>;<span class="comment">// 升序</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; arr[i] &lt; arr[i - <span class="number">1</span>]) &#123;</span><br><span class="line">asc = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result = findThreeNumber(arr, asc);</span><br><span class="line"><span class="function"><span class="keyword">for</span> <span class="title">each</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v in result)</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v[<span class="number">0</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; v[<span class="number">1</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; v[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>文章标题：<a href="http://www.cylong.com/blog/2016/11/08/three-number/" title="找出有序数组中 3 个和为 0 的数">找出有序数组中 3 个和为 0 的数</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href="http://www.cylong.com/blog/2016/11/08/three-number/" title="找出有序数组中 3 个和为 0 的数">http://www.cylong.com/blog/2016/11/08/three-number/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天偶尔看到一道题，感觉蛮有意思的，在自己思考，外加上网查询之后，找到了一个比较完美的算法解决。问题描述如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 给定有序排列的N个整数，找出其中3个数相加和为0，输出所有的不重复的3个数，要求输出的结果依然有序。&lt;br&gt; 在单行内，输出的顺序和原来一致，每行之间的顺序和第一个数字在原数列中的顺序一致（如果相同则向后依次比较）&lt;br&gt; INPUT :&lt;br&gt; 5&lt;br&gt; -2 -1 0 1 2&lt;br&gt; OUTPUT:&lt;br&gt; -2 0 2&lt;br&gt; -1 0 1&lt;br&gt; INPUT :&lt;br&gt; 5&lt;br&gt; 2 2 0 -2 -4&lt;br&gt; OUTPUT:&lt;br&gt; 2 2 -4&lt;br&gt; 2 0 -2&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.cylong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.cylong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>笑话人生，才刚刚开始</title>
    <link href="http://www.cylong.com/blog/2016/10/20/my-life-is-just-beginning/"/>
    <id>http://www.cylong.com/blog/2016/10/20/my-life-is-just-beginning/</id>
    <published>2016-10-20T09:11:50.000Z</published>
    <updated>2020-06-06T08:31:19.084Z</updated>
    
    <content type="html"><![CDATA[<hr><p>很多人的人生都有三个重大的转折点，第一是中考，第二是高考，第三是大学毕业。我很庆幸在这三个转折点，我都选择了或者有幸得到了自己心仪的结果，虽然有自己努力的结果，但不乏有很多幸运的元素。中考高考分别都是自己在初中和高中所有考试中发挥最好的一次，也许总有那种一到关键时候就超长发挥的光环。但我坚信，努力就会有好的结果。</p><a id="more"></a><p>即将面临毕业的我也是很纠结的，在考研和工作中二选一，最后决定脚踏两条船，还好没有翻船。从9月份开始不断的投递各个公司，陆陆续续投了接近20家。不断的参加宣讲笔试面试、参加宣讲笔试面试……有成功也有失败，两个月的时光转瞬即逝，不得不说，找工作真是一件头疼的事情【其实考研更让我头疼啊！(╯‵□′)╯︵┻━┻】。</p><p>…………【此处省略10000字，最后确定下来再填坑】</p><p>这两个月完全是在煎熬，找工作的焦急导致心情跌落到了低谷，有一段时间甚至什么都不想干，就坐在那发呆。最后终于在收到某 Offer 后，跌落到低谷的心情瞬间上升到了天堂，一切都放松了下来，可以安心的做一些其他事情了呢~~我相信我的人生才刚刚开始，后面会有更大的挑战在等着我，加油！Fighting！【怎么中二起来了啊！而且文笔也不好啊！(╯‵□′)╯︵┻━┻另外我只想记录下这一天啊！但是又不知道说什么好啊！】</p><hr><blockquote><p>文章标题：<a href="http://www.cylong.com/blog/2016/10/20/my-life-is-just-beginning/" title="笑话人生，才刚刚开始">笑话人生，才刚刚开始</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href="http://www.cylong.com/blog/2016/10/20/my-life-is-just-beginning/" title="笑话人生，才刚刚开始">http://www.cylong.com/blog/2016/10/20/my-life-is-just-beginning/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;很多人的人生都有三个重大的转折点，第一是中考，第二是高考，第三是大学毕业。我很庆幸在这三个转折点，我都选择了或者有幸得到了自己心仪的结果，虽然有自己努力的结果，但不乏有很多幸运的元素。中考高考分别都是自己在初中和高中所有考试中发挥最好的一次，也许总有那种一到关键时候就超长发挥的光环。但我坚信，努力就会有好的结果。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://www.cylong.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://www.cylong.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="人生" scheme="http://www.cylong.com/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>集中式和分布式版本控制学习整理</title>
    <link href="http://www.cylong.com/blog/2016/09/26/git-svn/"/>
    <id>http://www.cylong.com/blog/2016/09/26/git-svn/</id>
    <published>2016-09-25T16:30:55.000Z</published>
    <updated>2020-06-06T08:31:19.084Z</updated>
    
    <content type="html"><![CDATA[<hr><p>在面试的时候被问到平时喜欢用 Git 还是 SVN，他们之间的区别是什么？这自然就谈到了分布式和集中式的区别。作为一个学生党，免费的 Github 给我提供了很大的便利，我的所有项目都是放在 Github 上，毕竟 Github 还是一个全球最大的同性交友网站 ╮(╯▽╰)╭。下面就说说集中式和分布式版本控制的区别。</p><a id="more"></a><h1 id="为什么使用版本控制"><a href="#为什么使用版本控制" class="headerlink" title="为什么使用版本控制"></a>为什么使用版本控制</h1><p>在我们平时的开发过程中，大部分情况下是团队开发，即使是个人开发，我们也想对整个项目进行代码管理与备份等等。每次复制一份达成压缩包分类命名这样的肯定不是一个河里的解决办法，这只会让我们的磁盘空间越来越小，备份版本越来越多。在团队开发的时候，对代码进行合并管理的时候，总需要一些工具可以自动合并，版本控制系统应运而生。运用版本控制系统，我们可以对代码进行版本管理，可以随时查看之前版本的内容，随时回溯到之前版本中。团队合作的时候也可以自动合并代码，而不需要用一个共享文件，或者是进行定期的备份。</p><h1 id="集中式和分布式"><a href="#集中式和分布式" class="headerlink" title="集中式和分布式"></a>集中式和分布式</h1><p>版本控制系统也分为两类，集中式和分布式版本控制，我们所熟知的 Git 是分布式，SVN 是集中式，下面说说两者的区别。</p><h2 id="集中式"><a href="#集中式" class="headerlink" title="集中式"></a>集中式</h2><p>集中式版本控制系统有一个中央服务器，每个人在工作的时候都需要从中央服务器获取最新版本，修改后提交到中央服务器。其他人再获取最新代码进行更改。这种方式的缺点就是，我们必须有一个中央服务器，由于网络原因没法连接到服务器，或者服务器宕机，我们就没法进行数据获取和提交。而且由于是联网操作，网络环境也会影响到提交和下载速度。</p><p><img src="集中式.jpg" alt="集中式"></p><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><p>那么分布式版本控制系统是如何解决这些问题的呢？首先，分布式版本控制系统没有所谓的中央服务器，每个站点【就是自己用来开发的电脑】都有一个完整的版本库，我们可以在本地进行修改提交。这样在没有网络的环境下也可以进行开发。当需要进行代码合并的时候，我们只要把自己的版本库推送给你的合作伙伴就可以了，这样他就可以看到你做的更改。同时，他也可以把他的版本库推送给你，这样你就可以看到他的修改了。由于每个人电脑里都是一个完整的版本库，所以自己不小心丢失数据的话，从其他地方里拷贝一份就可以了。不过平时开发中，我们不会用这样笨拙的方式来互相推送代码。毕竟每个人的电脑不是24小时开机，总不能打个电话给他说：我要推送代码给你啦！(╯‵□′)╯︵┻━┻因此，Github 就起到了一个“中央服务器”的作用。我们把代码提交到 Github 上，任何人都可以随时下载合并代码，给我们提供了很多便利。</p><p><img src="分布式.jpg" alt="分布式"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>看完以上的介绍，很多人可能会比较模糊，我们在开发的过程中不是总需要一个中央服务器嘛？感觉上平时使用 Git 或者 SVN 操作都是一样的啊！出现这种混淆是因为我们平时开发的时候总是有一个中央服务器，总是再联网状态下。首先说明，Git 不需要一个中央服务器，我们平时使用 Github 是为了让我们的团队开发更便利，如果你不嫌麻烦，完全可以不用中央服务器。而 SVN 是必须使用一个中央服务器，而且如果没法联网或者服务器宕机，所有人都没法工作。其次，Git 是可以在断网状态下提交，因为每个人的电脑里都是一个完整的代码仓库，包含提交历史等等。而 SVN 在断网的时候是没法提交的，也没法查看历史记录。当然，Git 优于 SVN 的不仅有上面的这些，还有很多强大的功能优于 SVN。比如强大的分支功能，Git 做一个小小的标记就会产生一个分支。而 SVN 是复制一份代码到分支目录。Git 还可以进行本地回滚【因为自己电脑里也是一个完整的版本库，但是提交到中央服务器上的时候可以减少冗余版本】</p><h1 id="参考-amp-感谢"><a href="#参考-amp-感谢" class="headerlink" title="参考&amp;感谢"></a>参考&amp;感谢</h1><p>以上这些知识都是参考下面这些连接里的内容，本意是我自己的学习笔记，特此对其进行感谢。</p><blockquote><p><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001374027586935cf69c53637d8458c9aec27dd546a6cd6000" title="集中式vs分布式 - 廖雪峰的官方网站" target="_blank" rel="noopener">集中式vs分布式 - 廖雪峰的官方网站</a><br><a href="https://www.zhihu.com/question/20093241" title="如何理解 Git 的分布式？ - 知乎" target="_blank" rel="noopener">如何理解 Git 的分布式？ - 知乎</a></p></blockquote><hr><blockquote><p>文章标题：<a href="http://www.cylong.com/blog/2016/09/26/git-svn/" title="集中式和分布式版本控制学习整理">集中式和分布式版本控制学习整理</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href="http://www.cylong.com/blog/2016/09/26/git-svn/" title="集中式和分布式版本控制学习整理">http://www.cylong.com/blog/2016/09/26/git-svn/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;在面试的时候被问到平时喜欢用 Git 还是 SVN，他们之间的区别是什么？这自然就谈到了分布式和集中式的区别。作为一个学生党，免费的 Github 给我提供了很大的便利，我的所有项目都是放在 Github 上，毕竟 Github 还是一个全球最大的同性交友网站 ╮(╯▽╰)╭。下面就说说集中式和分布式版本控制的区别。&lt;/p&gt;
    
    </summary>
    
      <category term="版本控制" scheme="http://www.cylong.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
    
      <category term="git" scheme="http://www.cylong.com/tags/git/"/>
    
      <category term="svn" scheme="http://www.cylong.com/tags/svn/"/>
    
      <category term="分布式版本控制" scheme="http://www.cylong.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="集中式版本控制" scheme="http://www.cylong.com/tags/%E9%9B%86%E4%B8%AD%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>使用 Eclipse 根据 WSDL 生成 Java 代码</title>
    <link href="http://www.cylong.com/blog/2016/07/01/wsdl-to-java/"/>
    <id>http://www.cylong.com/blog/2016/07/01/wsdl-to-java/</id>
    <published>2016-07-01T09:39:06.000Z</published>
    <updated>2020-06-06T08:31:19.080Z</updated>
    
    <content type="html"><![CDATA[<hr><p>这学期的 SOA 课程已经结束了，但是我为什么感觉什么都没有学到呢！！反正学到什么就整理下好了！这次是使用 Eclipse 根据 WSDL 生成 Java 代码。整个过程都是自动的，完全是傻瓜式的！</p><a id="more"></a><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul><li>WSDL 地址【自己可以发布，如何发布我会在日后写，先挖个坑<del>一定要填上</del>】</li><li><a href="http://www.eclipse.org/downloads/eclipse-packages/" title="Eclipse IDE for Java EE Developers" target="_blank" rel="noopener">Eclipse IDE for Java EE Developers</a></li></ul><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol><li>打开 Eclipse，<code>File -&gt; New -&gt; Dynamic Web Project</code></li><li>右键刚刚新建的项目，<code>New -&gt; Other -&gt; Web Services -&gt; Web Service Client</code></li><li>在 Service definition 输入 WSDL 的地址，之后点 <code>Next</code> 或者 <code>Finish</code> 即可</li><li>会生成类似下面这样的代码结构<br><img src="wsdl-to-java.png" alt></li><li>其中 xxxProxy.java 中就有服务提供的接口方法，直接调用就行了。</li></ol><h1 id="参考-amp-感谢"><a href="#参考-amp-感谢" class="headerlink" title="参考&amp;感谢"></a>参考&amp;感谢</h1><blockquote><p><a href="http://andybang1981.blog.163.com/blog/static/177927368201426001589/" title="使用Eclipse生成Web Service Client - andybang1981的日志" target="_blank" rel="noopener">使用Eclipse生成Web Service Client - andybang1981的日志</a></p></blockquote><hr><blockquote><p>文章标题：<a href="http://www.cylong.com/blog/2016/07/01/wsdl-to-java/" title="使用 Eclipse 根据 WSDL 生成 Java 代码">使用 Eclipse 根据 WSDL 生成 Java 代码</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href="http://www.cylong.com/blog/2016/07/01/wsdl-to-java/" title="使用 Eclipse 根据 WSDL 生成 Java 代码">http://www.cylong.com/blog/2016/07/01/wsdl-to-java/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;这学期的 SOA 课程已经结束了，但是我为什么感觉什么都没有学到呢！！反正学到什么就整理下好了！这次是使用 Eclipse 根据 WSDL 生成 Java 代码。整个过程都是自动的，完全是傻瓜式的！&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.cylong.com/categories/Java/"/>
    
    
      <category term="java" scheme="http://www.cylong.com/tags/java/"/>
    
      <category term="wsdl" scheme="http://www.cylong.com/tags/wsdl/"/>
    
      <category term="web service client" scheme="http://www.cylong.com/tags/web-service-client/"/>
    
      <category term="eclipse" scheme="http://www.cylong.com/tags/eclipse/"/>
    
  </entry>
  
  <entry>
    <title>稳耐风波愿始从</title>
    <link href="http://www.cylong.com/blog/2016/06/09/iverson/"/>
    <id>http://www.cylong.com/blog/2016/06/09/iverson/</id>
    <published>2016-06-09T10:45:29.000Z</published>
    <updated>2020-06-06T08:31:19.080Z</updated>
    
    <content type="html"><![CDATA[<hr><p>夕阳西下。<br>我看着AI坐在斯台普斯客队替补席上，呆呆望着场内发生的一切。他看着科比在他面前超越了他领先十三年的得分，听着为24号的喝彩，再看着记分牌上一点点被拉大的分数，他只是呆坐，眼神迷茫，无动于衷，仿佛自己来自另一个世界。惨败，又是惨败，第三次惨败。哨声响起，他低着头，快步走出球员通道。我看得到他的背影看不到他的落寞。<br>怎么能低头离开斯台普斯？就在一年前他还是昂首走出去。八年前他只手遮天，梦想就断裂在这金黄的球馆，唯一一次六月的征战，旧队友，老照片，八年的风霜，未改的容颜，怎敢遗忘那些瞬间？最震耳欲聋的欢呼，让洛杉矶的轻歌曼舞画上一道休止符，晃倒泰龙卢，最骄傲的迈步，是谁再说，他踏上的是一条荆棘密布，无人可能成功的路？<br>只是，八年了，我们早已认不出那块泰龙卢摔倒的地板。<br>物是人非。<br>隔了个半个地球，有人在心痛。</p><a id="more"></a><p>隔了半个美国，也会有人难过吗？<br>流年，剪影，十年。<br>费城，1996，状元，三号，金链子，狐朋狗友，唱片，嘘声，对神的挑战，拉里布朗，训练，爱恨交错，忠诚，2001，洛杉矶，MVP，得分王……<br>时间，路途，前进的光，没有回望。<br>以为会与费城到地老天荒，只是寥寥的胜场，深深的惆怅，时光在云顶嘹亮地唱，分别的波澜轻轻地荡，刻不下的时光，注定一人去流浪。<br>再见了，我爱的费城；<br>再见了，我们爱的AI。<br>断肠人去天涯。<br>天涯远吗？不远，他在天涯，天涯怎么会远！</p><p>谁道飘零不可怜，断肠人去自经年。<br>那个精灵飞翔的故事还在上演，只是不再属于瓦乔维亚球馆。只是那个夜晚，是个例外——<br>那个夜晚很美，他们的欢呼他们的笑，他们的拥抱他们记得他的好。他的亲吻他的奔跑，他微微润湿的双眼，告诉我们他同样忘不掉。<br>WELCOME BACK, AI，THANKS FOR TEN GREAT YEARS OF HEART&amp;SOUL.<br>轻轻把手放在耳边，绕场慢慢的跑，聆听。<br>还记得吗？费城的欢呼是世界上最美妙的音乐。<br>俯身，深深的亲吻。<br>WE MISS YOU,AI.<br>费城的天空，我们想你时，它落泪了。<br>风雨中，陪你走，不要相忘于江湖。<br>可，踏上回丹佛的飞机，便是陌路。<br>天咫尺，人南北。</p><p>叹人生，几番离合，便成迟暮。<br>三年了，沧海桑田，人事变迁，谁会相信什么永远。<br>当他终于回到家，发现一切都变了样，是熟悉的让人陌生？还是恍如隔世陌生的让人难过？<br>曾经的一代枭雄，走到穷途末路，不甘就此推出，于是来场豪赌，一次搭上全部，输了就退出江湖。<br>感谢我爱的费城——他的退役宣言里这样说。<br>终于等到了费城的橄榄枝。<br>我们爱的AI，请回家。<br>有一种答案叫落叶归根。<br>俯身，深深的亲吻，第二次。<br>弧线不同了是吗，可那份情意此生不变。<br>谁谓我生，我思议如风，历历人生。</p><p>莫回首斜阳下，诉不尽离人话。<br>当费城故事确定未完待续时，我高兴的快要疯掉，你没有去湖人，谁在乎什么总冠军？我只要你幸福。<br>有些泪水是坚硬的，它从英雄的脸上滑过，但与懦弱无关。<br>AI说，那是看到家门后的鼻酸反应。<br>多好！爱费城的AI又回到了爱AI的费城。<br>从此无关胜负，誓死守护。<br>陪君醉笑三万场，不用诉离殇。</p><p>落魄江湖还载酒，一种悲凉滋味。<br>当两个费城之子相遇在费城——他出生成长的地方，他扬名立万的地方。他们早已不如十三年前那般锋芒毕露。久经沙场，看惯人世冷暖，他们，已不再年轻。<br>只是他正如日中天，他似乎已日薄西山。<br>有悬念吗？有奇迹吗？有人相信吗？<br>似乎费城倒戈喊几声MVP也是正常的。<br>只是他摇头，说不。<br>那美妙的第三节，十五分，已无需我赘述。<br>兄弟友爱之城的尊严，从来都要他来维护。<br>没有悬念，没有奇迹，剧本已写好，不会改变，我们输了，只是，我们开始相信：<br>弯弓射日，看我卷土重来。</p><p>谁谓我悲，意如花信，瞳清若水。<br>我从未想过有一天还会看到阿伦艾弗森穿上那件印有SIXER的球衣——那件神圣的为曾有旁人触动过的球衣，自始至终只属于一个人的球衣。<br>我看着你在费城，看着你与费城荣辱与共，休戚相关，还你那份倔强，许你那份坚强。享受你的每一场胜利与失败——我也不清楚这样的日子还会有多久，如果费城真的是你的最后一站，我们陪你走完，直到你离开你最爱的篮球场，直到那件三号球衣在瓦乔维亚上空飘扬。</p><p>任往事随风，他们自随波逐流，自始至终，稳耐风波愿始从。</p><hr><p>这篇文章是我女票大概在2009年【那个时候她真是青涩又可爱(/▽＼=)】写在百度空间里的，但是百度空间在15年就关闭了。然后我就要来发到自己的博客里，作为一种回忆 o(^▽^)o【<del>还是自己的网站靠谱~</del>】</p><hr><blockquote><p>文章标题：<a href="http://www.cylong.com/blog/2016/06/09/iverson/" title="稳耐风波愿始从">稳耐风波愿始从</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href="http://www.cylong.com/blog/2016/06/09/iverson/" title="稳耐风波愿始从">http://www.cylong.com/blog/2016/06/09/iverson/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;夕阳西下。&lt;br&gt;我看着AI坐在斯台普斯客队替补席上，呆呆望着场内发生的一切。他看着科比在他面前超越了他领先十三年的得分，听着为24号的喝彩，再看着记分牌上一点点被拉大的分数，他只是呆坐，眼神迷茫，无动于衷，仿佛自己来自另一个世界。惨败，又是惨败，第三次惨败。哨声响起，他低着头，快步走出球员通道。我看得到他的背影看不到他的落寞。&lt;br&gt;怎么能低头离开斯台普斯？就在一年前他还是昂首走出去。八年前他只手遮天，梦想就断裂在这金黄的球馆，唯一一次六月的征战，旧队友，老照片，八年的风霜，未改的容颜，怎敢遗忘那些瞬间？最震耳欲聋的欢呼，让洛杉矶的轻歌曼舞画上一道休止符，晃倒泰龙卢，最骄傲的迈步，是谁再说，他踏上的是一条荆棘密布，无人可能成功的路？&lt;br&gt;只是，八年了，我们早已认不出那块泰龙卢摔倒的地板。&lt;br&gt;物是人非。&lt;br&gt;隔了个半个地球，有人在心痛。&lt;/p&gt;
    
    </summary>
    
      <category term="艾已成诗" scheme="http://www.cylong.com/categories/%E8%89%BE%E5%B7%B2%E6%88%90%E8%AF%97/"/>
    
    
      <category term="艾弗森" scheme="http://www.cylong.com/tags/%E8%89%BE%E5%BC%97%E6%A3%AE/"/>
    
      <category term="艾已成诗" scheme="http://www.cylong.com/tags/%E8%89%BE%E5%B7%B2%E6%88%90%E8%AF%97/"/>
    
      <category term="篮球" scheme="http://www.cylong.com/tags/%E7%AF%AE%E7%90%83/"/>
    
  </entry>
  
  <entry>
    <title>Windows 10 Metro 应用使用本地 Shadowsocks 代理</title>
    <link href="http://www.cylong.com/blog/2016/06/07/windows-10-metro-shadowsocks/"/>
    <id>http://www.cylong.com/blog/2016/06/07/windows-10-metro-shadowsocks/</id>
    <published>2016-06-07T09:04:55.000Z</published>
    <updated>2020-06-06T08:31:19.079Z</updated>
    
    <content type="html"><![CDATA[<hr><p>Windows 8/10 的应用是不允许访问 localhost(127.0.0.1)，所以你配置了 Shadowsocks 代理，Windows 10 应用也无法翻墙， 因为Shadowsocks 的代理地址正好是 localhost(127.0.0.1)。这个时候我们就需要祭出 Windows 10 自带的程序：CheckNetIsolation。通过这个程序，你可以设置排除哪个应用的限制，使其可以翻墙。</p><a id="more"></a><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><ol><li><p>寻找应用的 SID：键盘组合键 <span class="fa fa-windows"></span> + R，然后输入 <code>regedit</code>，打开注册表管理器，找到以下注册表项：<br>HKEY_CURRENT_USER\Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppContainer\Mappings<br>在其中找到你想要使用代理的应用，DisplayName 就是应用名，左边的项就是 SID。比如我找的是 Twitter。如下图：<br><img src="regedit_sid.png" alt="注册表项示例"><br>【PS： 你可以鼠标放在 SID 上右键-&gt;重命名，然后就可以复制整个 SID 了】</p></li><li><p>键盘组合键 <span class="fa fa-windows"></span> + X，然后按 A【命令提示符（管理员）】，打开终端后输入：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CheckNetIsolation loopbackexempt -a -p=SID <span class="comment"># 上一步你复制的 SID</span></span><br></pre></td></tr></table></figure><p>回车后就大功告成了。</p></li><li><p>打开 Twitter 试一下<br><img src="twitter.png" alt="Twitter 翻墙成功"></p></li></ol><h1 id="CheckNetIsolation-参数"><a href="#CheckNetIsolation-参数" class="headerlink" title="CheckNetIsolation 参数"></a>CheckNetIsolation 参数</h1><ul><li>CheckNetIsolation.exe loopbackexempt -a -p=SID 添加指定程序到列表</li><li>CheckNetIsolation.exe loopbackexempt -d -p=SID 从列表删除指定程序</li><li>CheckNetIsolation.exe loopbackexempt -s 列出环回免除的应用列表</li></ul><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul><li><p>有些小伙伴可能会使用 WindowsModernAppsTools 来使 Windows 10 应用翻墙，这个软件也是使用了 CheckNetIsolation，另外最好不要随便动 Windows 10 应用的数据，说不定不小心删除了什么就导致应用崩溃了，切记切记。前车之鉴请参考：</p><blockquote><p><a href="http://www.cylong.com/blog/2016/05/15/windows-10-metro-error/" title="Windows 10 Metro 应用闪退、无法打开修复方法">Windows 10 Metro 应用闪退、无法打开修复方法</a></p></blockquote></li><li><p>Facebook 的 Windows 10 应用没法翻墙。我找了很多资料，大家的讨论也是只有 Facebook 没法翻墙，其他的都可以。有知道原因并能解决的小伙伴欢迎 <a href="http://www.cylong.com/about/#联系我" title="骚扰我">骚扰我</a> 或者在下面留言 (●’◡’●)</p></li><li>即使都是 Twitter 应用，但是不同的电脑 SID 可能不同。</li></ul><h1 id="参考-amp-感谢"><a href="#参考-amp-感谢" class="headerlink" title="参考&amp;感谢"></a>参考&amp;感谢</h1><blockquote><p><a href="https://plus.google.com/u/0/107096807950211631844/posts/CdTT2becCRm" title="Microsoft Edge 浏览器用上 shadowsocks 代理翻墙方法" target="_blank" rel="noopener">Microsoft Edge 浏览器用上 shadowsocks 代理翻墙方法</a></p></blockquote><hr><blockquote><p>文章标题：<a href="http://www.cylong.com/blog/2016/06/07/windows-10-metro-shadowsocks/" title="Windows 10 Metro 应用使用本地 Shadowsocks 代理">Windows 10 Metro 应用使用本地 Shadowsocks 代理</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href="http://www.cylong.com/blog/2016/06/07/windows-10-metro-shadowsocks/" title="Windows 10 Metro 应用使用本地 Shadowsocks 代理">http://www.cylong.com/blog/2016/06/07/windows-10-metro-shadowsocks/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;Windows 8/10 的应用是不允许访问 localhost(127.0.0.1)，所以你配置了 Shadowsocks 代理，Windows 10 应用也无法翻墙， 因为Shadowsocks 的代理地址正好是 localhost(127.0.0.1)。这个时候我们就需要祭出 Windows 10 自带的程序：CheckNetIsolation。通过这个程序，你可以设置排除哪个应用的限制，使其可以翻墙。&lt;/p&gt;
    
    </summary>
    
      <category term="Windows" scheme="http://www.cylong.com/categories/Windows/"/>
    
    
      <category term="windows" scheme="http://www.cylong.com/tags/windows/"/>
    
      <category term="shadowsocks" scheme="http://www.cylong.com/tags/shadowsocks/"/>
    
      <category term="翻墙" scheme="http://www.cylong.com/tags/%E7%BF%BB%E5%A2%99/"/>
    
  </entry>
  
  <entry>
    <title>站在 Shadowsocks 的肩膀上发现精彩的世界</title>
    <link href="http://www.cylong.com/blog/2016/05/26/shadowsocks/"/>
    <id>http://www.cylong.com/blog/2016/05/26/shadowsocks/</id>
    <published>2016-05-26T05:51:29.000Z</published>
    <updated>2017-04-08T16:16:12.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p>国内的网络环境我不说相信大家都懂。虽然墙内的世界很丰富，但是墙外的世界还有着更加精彩的内容。这不得不让我想起了曾经看过的一部漫画——进击的巨人。大部分人都在墙内过着安逸的生活，但是总有那么一帮人，想要去墙外探索未知的世界。我就是这样的人！【然后收到了女票的好人卡一张😃】之前因为想要体验 Google 搜索、体验 Youtube、查阅学习资料，还有玩的部分游戏需要翻墙，找了很多免费的代理和 VPN，效果都不好，断断续续的。后来经过舍友的推荐，入了 Shadowsocks 的坑。体验了有两个月左右，效果很棒，访问速度也很快，强烈推荐给大家使用！！！(●’◡’●)</p><a id="more"></a><h1 id="购买服务"><a href="#购买服务" class="headerlink" title="购买服务"></a>购买服务</h1><ol><li>点击进入 <a href="https://secure.shadowsocks.ch/aff.php?aff=8883" title="Shadowsocks" target="_blank" rel="noopener">Shadowsocks</a>【此链接是我的推广链接，你点击后还是会直接进入首页，但是通过这个链接购买服务后我也会获得一些好处啦，嘿嘿(<em>^_^</em>)】，进入首页后选择 <code>订购服务</code>。</li><li>之后选择你想要购买的服务，点击现在订购。我选择的是 <code>Shadowsocks.com 普通版</code>。需要注意的是，虽然显示的价格是美元，但是在后面支付的时候会自动转化为人民币。<br><img src="Shadowsocks-basic.png" alt="Shadowsocks普通版"></li><li>界面上选择你的付款年限，然后点击继续。</li><li>在结账页面，你需要填写各种信息，需要认真填写，这也是在创建账号。</li><li>Shadowsocks 支持 Alipay 支付宝国际版。之后付款就可以了，现在大约是 104 块钱一年。我买的时候，订购服务时显示的还是人民币，99块钱一年。虽然贵了一点点，不过还是可以接受的。</li><li>之后进入 <a href="https://portal.shadowsocks.com/clientarea.php" title="客户中心 - Shadowsocks" target="_blank" rel="noopener">客户中心</a>，用第4步创建的账号登陆。</li><li>点击产品服务，可以看到你刚刚购买的服务，状态为有效。<br><img src="my-service.png" alt="我的服务"></li><li>点击刚刚购买的服务，会看到产品详情。下面有配置文件下载，选择 Windows 版下载。下载下来是 <code>gui-config.json</code>。</li></ol><h1 id="客户端安装使用"><a href="#客户端安装使用" class="headerlink" title="客户端安装使用"></a>客户端安装使用</h1><p>支持的客户端：OS X， Windows， Linux， iOS， Android， OpenWRT 路由器等。<br>详情请参考：<a href="https://shadowsocks.com/client.html" title="客户端 - Shadowsocks" target="_blank" rel="noopener">客户端 - Shadowsocks</a>，客户端都在 Github 上。</p><h2 id="Windows-客户端"><a href="#Windows-客户端" class="headerlink" title="Windows 客户端"></a>Windows 客户端</h2><ol><li>点击下载 <a href="https://github.com/shadowsocks/shadowsocks-windows/releases/download/3.0/Shadowsocks-3.0.zip" title="Shadowsocks-3.0.zip" target="_blank" rel="noopener">Shadowsocks-3.0.zip</a>【写这篇博客时候的最新版本】，或者去 <a href="https://github.com/shadowsocks/shadowsocks-windows/releases" title="Github - Shadowsocks Windows" target="_blank" rel="noopener">Github - Shadowsocks Windows</a> 上寻找其他版本。</li><li>解压后有一个 <code>Shadowsocks.exe</code> 文件。最好把这个文件放到一个目录下，比如新建一个 Shadowsocks 文件夹。</li><li>把刚刚下载的 <code>gui-config.json</code> 文件放到与 <code>Shadowsocks.exe</code> 相同的目录下。</li><li>双击 <code>Shadowsocks.exe</code>，会出现一个 GUI 界面，自动读取了 <code>gui-config.json</code> 文件中的内容。<br><img src="Windows-Shadowsocks-gui.png" alt="Windows Shadowsocks 图形界面"></li><li>在右下角托盘图标上会有一个好像纸飞机的 Shadowsocks 图标，<code>右键-&gt;启动系统代理</code>，就可以越过墙壁，浏览更多丰富多彩的内容啦~<br><img src="Shadowsocks-menu.png" alt="Shadowsocks 菜单"></li><li>另外建议设置成 <code>右键-&gt;开机启动</code>，这样不用每次开机手动启动了。还可以在 <code>右键-&gt;服务器</code> 中选择不同的服务器。</li></ol><h2 id="Android-客户端"><a href="#Android-客户端" class="headerlink" title="Android 客户端"></a>Android 客户端</h2><ol><li>点击下载 <a href="https://github.com/shadowsocks/shadowsocks-android/releases/download/v2.10.3/shadowsocks-nightly-2.10.3.apk" title="shadowsocks-nightly-2.10.3.apk" target="_blank" rel="noopener">Shadowsocks-nightly-2.10.3.apk</a>【写这篇博客时候的最新版本】，或者去 <a href="https://github.com/shadowsocks/shadowsocks-android/releases" title="Github - Shadowsocks Android" target="_blank" rel="noopener">Github - Shadowsocks Android</a> 上寻找其他版本。</li><li>把这个 apk 安装到手机上【可以传到手机里，打开这个 apk 就能安装了】，中文叫影梭。</li><li>安装完成后仍然需要配置，支持扫描二维码配置，但是需要下载一个客户端。我不喜欢下太多的客户端，所以就手动配置，具体的值可以用记事本打开 <code>gui-config.json</code> 查看。<br><img src="Shadowsocks-Android.png" alt="Shadowsocks Android"></li><li>翻墙后就可以去 Google Play 商店更新 Shadowsocks 了(●’◡’●)</li></ol><p><strong>2016-09-27 更新</strong></p><ol start="5"><li>目前最新版的 Shadowsocks 已经支持直接扫码配置了，不需要下载额外的客户端。在 Shadowsocks 官网里<code>客户中心--有效产品与服务</code>里就可以找到各个节点的二维码。</li></ol><h2 id="Linux-客户端"><a href="#Linux-客户端" class="headerlink" title="Linux 客户端"></a>Linux 客户端</h2><p>经历了N天之后,终于在舍友的指导下配置完成了。不得不说，Linux 真是一个让人折腾的系统。不过后来发现，其实还蛮简单的（╯－＿－）╯╧╧</p><ol><li>首先你需要下载 <a href="http://www.google.cn/chrome/browser/desktop/index.html" title="Chrome 浏览器" target="_blank" rel="noopener">Chrome 浏览器</a> 【不需要翻墙】，已经有的小伙伴就不用重新下载了。</li><li>使用如下命令安装你下载下来的 Chrome 安装包：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i xxx-chrome-xxx.deb</span><br></pre></td></tr></table></figure></li><li>通过 PPA 源安装 Shadowsocks-qt5，仅支持 Ubuntu 14.04 或更高版本。<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:hzwhuang/ss-qt5</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install shadowsocks-qt5</span><br></pre></td></tr></table></figure></li><li>之后就可以在应用列表里搜索到 Shadowsocks-qt5 了<br><img src="search-shadowsocks.png" alt="搜索应用列表"></li><li>打开图形化界面，点击 <code>文件 -&gt; 从 gui-config.json 导入链接</code>，接着就会像下图一样。<br><img src="Shadowsocks-Qt5-GUI.png" alt="Shadowsocks-Qt5 图形界面"></li><li>上图的 jp01 和 us01 都是后来配置好的，导入 gui-config.json 后还是有些需要自己配置。双击某一条连接，像我如下这样配置【默认有的配置就不要改了】：<br><img src="config.png" alt="连接配置"></li><li>配置完成后点击 <code>OK</code>，再点击界面上面的 <code>连接</code>，测试下延迟，看看是否能连接上。可以多配置几个，方便切换~</li><li>接下来就是配置 Chrome，让 Chrome 可以使用代理。下载安装 <a href="http://switchysharp.com/install.html" title="SwitchySharp" target="_blank" rel="noopener">SwitchySharp</a> 【目前此应用已经更新为 SwitchyOmega，请参考 <a href="/blog/2017/04/09/chrome-SwitchyOmega/" title="Chrome 配置 SwitchyOmega">Chrome 配置 SwitchyOmega</a>】。</li><li>打开 Chrome， 点击右上角的 <span class="fa fa-globe" aria-hidden="true"></span> 图标，再点击 <code>选项</code>。<br><img src="Shadowsocks-icon.png" alt="Shadowsocks 图标"></li><li>点击 <code>新建情景模式</code>，做如下配置。<br><img src="SwitchySharp-config.png" alt="SwitchySharp 配置"></li><li>保存后再点击 <span class="fa fa-globe" aria-hidden="true"></span> 图标就会有你刚刚配置的情景模式，选择后就可以使用 Chrome 浏览器浏览墙外的世界啦~【另外 SwitchySharp 可以升级成 SwitchyOmega 了，有兴趣的小伙伴可以试一试！】</li><li>做了上述一系列操作后只有在 Chrome 中可以翻出墙外，至于全局代理我正在研究，过几天会出教程，有会的小伙伴也可以交 ♂ 流下~【此坑算是没时间填了(╯‵□′)╯︵┻━┻】</li></ol><h2 id="IOS-客户端"><a href="#IOS-客户端" class="headerlink" title="IOS 客户端"></a>IOS 客户端</h2><p>由于本渣没有任何的苹果设备。。。所以自己研究吧，相信聪明的你可以完成的！去 <a href="https://shadowsocks.com/client.html" title="客户端 - Shadowsocks" target="_blank" rel="noopener">客户端 - Shadowsocks</a> 可以找到相关的客户端。</p><p><strong>2016-09-27 更新</strong></p><p>最近也是人品爆表，抽奖抽到了个 IPad mini 2，自然就研究了下如何在 IOS 中试用 Shadowsocks 了。官方推荐的客户端是 <code>shadowrocket</code>。App Store 里卖6块钱。我找到的是 <code>Lifi客户端-Shadowsocks and ShadowsocksR VPN</code>，也是在 App Store 里下载，不过是免费的。两者的配置方式基本一样，都可以扫码配置。在 Shadowsocks 官网里<code>客户中心--我的产品与服务</code>里就可以找到各个节点的二维码。</p><ol><li><p>Lifi 配置，在应用里选择<code>设置--从二维码导入</code>就会打开扫码界面，之后配置一下代理名称，打开系统 VPN 就可以了，非常简单【我觉得有张图挺好看的，于是强行加了张图(<em>^_^</em>)】。：<br><img src="Shadowsocks-IOS.png" alt="Shadowsocks IOS"></p></li><li><p>Shadowrocket 配置，打开应用，点击左上角的扫码图标就可以打开扫码页面：<br><img src="Shadowrocket.png" alt="Shadowrocket"></p></li></ol><p>看评论说<code>Lifi客户端-Shadowsocks and ShadowsocksR VPN</code>是拿的 Potatso 源码？我也不知道是否真实，有了解的小伙伴欢迎联系我。不过在我一天的试用中发现这个客户端一直掉线，而且舍友 IOS 10 也没法使用，于是我俩都换成了 <code>shadowrocket</code>，IOS 10 可以用，不过也是一直掉线啊，而且有时候还闪退(╯‵□′)╯︵┻━┻！如果用 Shadowrocket 的小伙伴发现QQ聊天的时候没法接收和发送图片，可以在应用的 <code>Settings-Global Routing</code>中选择 Proxy 就好了。大家可以先试一下免费的 Lifi，如果不好用再换成收费的那个 Shadowrocket 吧。有更好的客户端也欢迎在下面讨论。</p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul><li>要是偶尔发现网络不稳定，切换线路试一下。</li><li>不要同时在多台设备上使用，也不要把配置文件分享给其他人，可能会遭到封号行为。不过手机和 PC 同时使用时没事的。</li><li>我遇到一个问题就是启动某些服务器无法下载 Google Play 里的应用，而且有些应用也提示无法在你所在的国家或者地区购买，这个时候就切换下线路，并且清除 Google Play 数据重启就行了。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote><p><a href="https://github.com/shadowsocks/shadowsocks-qt5/wiki" title="中文文档 - Shadowsocks-qt5" target="_blank" rel="noopener">中文文档 - Shadowsocks-qt5</a><br><a href="blog/2017/04/09/chrome-SwitchyOmega/" title="Chrome 配置 SwitchyOmega - 笑话人生">Chrome 配置 SwitchyOmega - 笑话人生</a> 【Shadowsocks 配合 SwitchyOmega 使用有奇效，建议尝试下(●’◡’●)】</p></blockquote><hr><blockquote><p>文章标题：<a href="http://www.cylong.com/blog/2016/05/26/shadowsocks/" title="站在 Shadowsocks 的肩膀上发现精彩的世界">站在 Shadowsocks 的肩膀上发现精彩的世界</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href="http://www.cylong.com/blog/2016/05/26/shadowsocks/" title="站在 Shadowsocks 的肩膀上发现精彩的世界">http://www.cylong.com/blog/2016/05/26/shadowsocks/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;国内的网络环境我不说相信大家都懂。虽然墙内的世界很丰富，但是墙外的世界还有着更加精彩的内容。这不得不让我想起了曾经看过的一部漫画——进击的巨人。大部分人都在墙内过着安逸的生活，但是总有那么一帮人，想要去墙外探索未知的世界。我就是这样的人！【然后收到了女票的好人卡一张😃】之前因为想要体验 Google 搜索、体验 Youtube、查阅学习资料，还有玩的部分游戏需要翻墙，找了很多免费的代理和 VPN，效果都不好，断断续续的。后来经过舍友的推荐，入了 Shadowsocks 的坑。体验了有两个月左右，效果很棒，访问速度也很快，强烈推荐给大家使用！！！(●’◡’●)&lt;/p&gt;
    
    </summary>
    
      <category term="Shadowsocks" scheme="http://www.cylong.com/categories/Shadowsocks/"/>
    
    
      <category term="ubuntu" scheme="http://www.cylong.com/tags/ubuntu/"/>
    
      <category term="windows" scheme="http://www.cylong.com/tags/windows/"/>
    
      <category term="linux" scheme="http://www.cylong.com/tags/linux/"/>
    
      <category term="shadowsocks" scheme="http://www.cylong.com/tags/shadowsocks/"/>
    
      <category term="翻墙" scheme="http://www.cylong.com/tags/%E7%BF%BB%E5%A2%99/"/>
    
      <category term="android" scheme="http://www.cylong.com/tags/android/"/>
    
  </entry>
  
</feed>
