<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>与青春有关的日子（2001&amp;2011）十年纪之全明星</title>
    <url>/blog/2011/02/24/iverson-2001-2011/</url>
    <content><![CDATA[<hr>
<p>没有奇迹。<br>纵使勒布朗·詹姆斯率东部“殊死”抵抗一番，依旧未能填平那将近20分的沟壑。<br>终于，有人怀念起十年以前，那个与世界为敌，狂妄得无法无天的小子来了。<br>“我离开后，你们才会真正明白我的价值。”<br>我们的艾如是说道。</p>
<a id="more"></a>

<p>还记得那时的全明星吗？<br>尚在湖人的沙克，梳着辫子头的天尊，拄着双拐的希尔，笑容灿烂的马布里，引爆全场的卡特，顶着怪异头型的科比，一副无所谓表情的麦迪，以及，那时风华绝代的阿伦艾弗森。<br>那些是时代的宠儿。他们不知道未来的命运，不知道沙克会与科比闹翻，不知道希尔把最好的年华献给了队医，不知道卡特有一天失去翅膀也会泯然众人，不知道马布里会被视为球队毒药，不知道麦迪会被带上“软”与“炸伤”的帽子，不知道AI有一天会流浪到土耳其，不知道未来的某一天，自己会成为时代的倒影。</p>
<p>那仅仅是2001年，那时的华盛顿是属于他们的舞台。<br>遥远的十年以前，轻狂的AI连走起路来都放荡不羁。那些个意气风发的少年，一张张微笑的脸，试图把这世界改变。<br>如果有十年前的照片，那一定已经泛黄。只有在比赛录像中，现场DJ充满激情的呼喊才依旧清晰，那些故人的笑容也依然明朗。那总会让我们产生错觉，闭上眼，仿佛一切发生在昨天。心微微的疼，因为那些人已不复当年。</p>
<p>那是场高低悬殊的比赛，至少东部七名队员身高都不足两米，所有人都觉得他们不够强壮，无法取得比赛的胜利。只是，AI与马布里联手向世界证明了，胜利与身体无关，与之有关的，只是——心！那颗为胜利而跳动的心脏。<br>于是造就了如此一场惊心动魄荡气回肠的比赛。看看今年的全明星，再与十年前做对比，你就会发现，一代人已经走向妥协，这个世界的反面英雄已经几乎绝迹。再也没有人会在落后二十几分时依旧骄傲的说我们会赢了；再也没有人可以那么勇敢地站在权威的背面了；再也没有人会玩世不恭地对这个世界竖起中指了。<br>十年过去了，那时叱咤风云的人物都离开了。<br>但使龙城飞将在，不教胡马度阴山。</p>
<p>但，当年轻的球员们看到阿伦艾弗森与世界为敌后的下场时，恐怕已经没有多少人愿意和他再走上同一条道路。那种坚持与忠诚，执着与顽强，反抗与斗争，那首属于英雄的赞歌再也不会在NBA响起了，这个世界也许还需要个人英雄主义，只是没有人愿意去做那个英雄了。<br>单挑篮球之神，全明星逆转，总决赛与繁华的洛杉矶为敌，纹身，嘻哈，垄沟头，轻描淡写，不爱训练，我行我素，史诗般的对决，胜利失败，爱与恨。<br>再也没有人可以承受这一切了。答案，真的无法被取代。<br>阿伦艾弗森走的，的确是一条前无古人后无来者的道路，因为再也没有人还有勇气如他一般。<br>单凭这一点，他所做的一切，就值得所有人，脱帽致敬。</p>
<p>所以，纵使上赛季被球队裁掉，老将底薪，球队备胎，依旧全明星。<br>你所做的事情，权威不喜欢，我们却深爱。<br>那些传奇，权威可以淡漠，我们却会铭记。<br>无论你是无限风光如日中天，还是黯然神伤举步维艰，我们都站在你的身后。<br>你是我们无法消散的光芒，<br>你是我们此生不变的信仰。</p>
<p>无论未来有多远，我们等你。</p>
<hr>
<h1 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h1><p>骄傲的狮子座,喜欢笑,喜欢明亮到刺眼的阳光,喜欢初春时节融化的冰雪，喜欢湛蓝色的天空，喜欢一生都在飞翔的北极燕鸥，喜欢伤感的文字,喜欢动人的故事,喜欢费城，此生挚爱 Allen Iverson。</p>
<h1 id="笔者附言"><a href="#笔者附言" class="headerlink" title="笔者附言"></a>笔者附言</h1><p>嘿嘿，偷偷搬运下！不要让原作者发现！(●’◡’●)【2016-11-22 16:10:55】</p>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2011/02/24/iverson-2001-2011/' title='与青春有关的日子（2001&2011）十年纪之全明星' >与青春有关的日子（2001&2011）十年纪之全明星</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2011/02/24/iverson-2001-2011/' title='与青春有关的日子（2001&2011）十年纪之全明星' >http://www.cylong.com/blog/2011/02/24/iverson-2001-2011/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>艾已成诗</category>
      </categories>
      <tags>
        <tag>艾弗森</tag>
        <tag>艾已成诗</tag>
        <tag>全明星</tag>
        <tag>流年</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo + Git 搭建免费的个人博客</title>
    <url>/blog/2016/04/19/hexo-git/</url>
    <content><![CDATA[<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>个人博客日益流行，大家都开始搭建自己的博客，记录成长中学习中的点点滴滴，最近觉得自己也需要有一个平台整理自己的所学所想，于是用了将近3天的时间 <del>(实际上一天就能搞定的！)</del> 使用 Hexo + Git 搭建了自己的个人博客，提高自己的学习动力，没事的时候可以拿出来温习下，提高下本人的渣渣水平。目前仍有很多功能没有添加，留着日后慢慢完善。准备将自己的第一篇博客献给 Hexo，表示对 Hexo 的感谢。下面详细介绍下搭建流程，有任何不懂的问题欢迎 <a href="/about/#%E8%81%94%E7%B3%BB%E6%88%91" title="联系我">联系我</a> 或者在下面评论。另外个人能力有限，接受任何建议或者吐槽！共同进步(●’◡’●)。</p>
<a id="more"></a>
<h1 id="Hexo-简介"><a href="#Hexo-简介" class="headerlink" title="Hexo 简介"></a>Hexo 简介</h1><p>大家所熟悉的博客框架莫过于 Wordpress，还有 Jekyll 等，博主在查阅了大量资料后选择了<a href="https://hexo.io/zh-cn/" title="Hexo">Hexo</a>，Hexo 是一个快速、简洁且高效的博客框架。可以方便快捷的生成博客网页。Hexo由台湾大学生 <a href="http://twitter.com/tommy351" title="SkyArrow (@tommy351) | Twitter">tommy351</a> 开发，是一个基于Node.js的静态博客程序。支持多种主题，博主选择的是 <a href="http://theme-next.iissnan.com/" title="Next">NexT</a> 主题。使用 Hexo + Git 搭建博客不需要购买域名和服务器，由 Github 提供域名和网站页面空间。</p>
<h1 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h1><p><b>注意:</b> 本文针对 <em>Windows</em> 平台和 <em>Hexo 3.x</em> 【其实后来我也在 Ubuntu 上试了一下，完全一样的】</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>在安装 Hexo 之前，请确认你已经安装了以下程序：</p>
<ul>
<li><a href="http://nodejs.cn/download/" title="Node.js">Node.js</a></li>
<li><a href="http://git-scm.com/" title="Git">Git</a></li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在自己认为合适的地方创建一个文件夹作为博客项目的目录，进入文件夹，然后鼠标右键选择 <code>Git Bash Here</code>，依次输入：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">npm install hexo --save</span><br><span class="line">hexo -v <span class="comment"># 查看版本</span></span><br></pre></td></tr></table></figure>

<p>输入 <code>hexo -v</code> 后输出以下内容表示安装成功了(可能版本有差别)：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ hexo -v</span><br><span class="line">hexo: 3.2.0</span><br><span class="line">hexo-cli: 1.0.1</span><br><span class="line">os: Windows_NT 10.0.10586 win32 x64</span><br><span class="line">http_parser: 2.5.2</span><br><span class="line">node: 4.4.2</span><br><span class="line">v8: 4.5.103.35</span><br><span class="line">uv: 1.8.0</span><br><span class="line">zlib: 1.2.8</span><br><span class="line">ares: 1.10.1-DEV</span><br><span class="line">icu: 56.1</span><br><span class="line">modules: 46</span><br><span class="line">openssl: 1.0.2g</span><br></pre></td></tr></table></figure>

<h2 id="体验-Hexo"><a href="#体验-Hexo" class="headerlink" title="体验 Hexo"></a>体验 Hexo</h2><p>接下来在当前的博客目录下，依次输入：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hexo init   <span class="comment"># 初始化组件</span></span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>之后 npm 将会自动安装你需要的组件，只需要等待 npm 操作即可。接着输入：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>

<p>说明你的博客可以在本地访问啦，打开浏览器输入 <a href="http://localhost:4000/">http://localhost:4000/</a> 试试看吧~</p>
<h1 id="Hexo-使用"><a href="#Hexo-使用" class="headerlink" title="Hexo 使用"></a>Hexo 使用</h1><p>下面让我们创建第一篇文章吧，输入：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hexo n my-first   <span class="comment"># 生成文章，或者 source\_posts 手动编辑</span></span><br></pre></td></tr></table></figure>

<p>之后查看 <code>source\_posts</code> 下面就会出现 <code>my-first.md</code>， 编辑这个文件就是在编辑你的这篇博客，博客采用 md 文件编写。md 语法请参考：</p>
<blockquote>
<p><a href="http://wowubuntu.com/markdown/" title="Markdown 语法说明(简体中文版)">Markdown 语法说明(简体中文版)</a></p>
</blockquote>
<p>完成保存后输入：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hexo g <span class="comment"># 生成 public 静态文件，这步不是必须的，当你需要生成的 Html 页面的时候输入这行代码</span></span><br><span class="line">hexo s <span class="comment"># 启动服务器，查看本地效果</span></span><br></pre></td></tr></table></figure>

<p>浏览器中输入 <a href="http://localhost:4000/">http://localhost:4000/</a> 就会看到你刚刚编辑的博客了，如果发现无法访问的情况，可能是因为端口被占用或者你启用了代理【关掉就好】，运行如下命令修改端口：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hexo server -p 5000 <span class="comment"># 5000为你想要修改的端口号</span></span><br></pre></td></tr></table></figure>

<p>在服务器启动期间，Hexo 会监视文件变动并自动更新，您无须重启服务器。更多博客编辑技巧请参照 <a href="https://hexo.io/zh-cn/docs/" title="Hexo 中文文档">Hexo 中文文档</a></p>
<h1 id="部署到Github"><a href="#部署到Github" class="headerlink" title="部署到Github"></a>部署到Github</h1><h2 id="创建代码仓库"><a href="#创建代码仓库" class="headerlink" title="创建代码仓库"></a>创建代码仓库</h2><p>首先你需要一个 Github: <a href="https://github.com/">https://github.com/</a> 账号，然后创建一个仓库，仓库名是 <code>yourname.github.io</code>， 比如我的是 <code>cylong1016.github.io</code>。</p>
<h2 id="开启-gh-pages-功能"><a href="#开启-gh-pages-功能" class="headerlink" title="开启 gh-pages 功能"></a>开启 gh-pages 功能</h2><p>创建完成后点击界面右侧的 <code>Settings</code>，向下拖动，直到看见 <code>GitHub Pages</code> ，点击 <code>Automatic page generator</code>，Github 将会自动替你创建出一个 gh-pages 的页面。<br>如果你的配置没有问题，那么大约15分钟之后，<a href="http://cylong1016.github.io/">http://cylong1016.github.io</a> 这个网址就可以正常访问了~<br>之后打开本地博客目录下的 <code>_config.yml</code> 文件，最下面找到 <code>Deployment</code> ， 做如下修改：</p>
<pre><code>deploy:
  type: git
  repo: https://github.com/cylong1016/cylong1016.github.io.git
  # cylong1016改成你的用户名
  branch: master</code></pre>
<p>接着在 Git Bash 中依次输入：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save    <span class="comment"># 安装使用 git 方式进行部署所需要的插件</span></span><br><span class="line">hexo d                <span class="comment"># 部署到 Github 上，按照提示输入自己 Github 的用户名和密码。</span></span><br></pre></td></tr></table></figure>

<p>部署会强制覆盖掉你之前生成的页面，在博客的目录下会产生 <code>.deploy_git</code>文件夹，不要删除，否则你的部署记录就会不见。之后就可以通过 <a href="http://cylong1016.github.io/">http://cylong1016.github.io</a> (cylong1016 替换成你的用户名)访问你的网站啦。在之后的部署时，建议输入以下代码:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hexo clean  <span class="comment"># 清除之前 public 文件夹的内容</span></span><br><span class="line">hexo g      <span class="comment"># 生成静态的 public 文件夹，部署时候也是直接拷贝此文件夹里的文件。</span></span><br><span class="line">hexo d      <span class="comment"># 部署到 Github 上，按照提示输入自己 Github 的用户名和密码。</span></span><br><span class="line"><span class="comment"># hexo g 和 hexo d 这两条命令可以合并成 hexo d --g 或者 hexo g --d</span></span><br></pre></td></tr></table></figure>

<h1 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h1><p>你可以在 <a href="https://hexo.io/themes/" title="Themes | Hexo">Themes - Hexo</a> 找到你喜欢的主题下载下来，放在博客目录下的 <code>themes</code> 目录下，之后修改 <code>_config.yml</code> 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;</span><br><span class="line">## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;</span><br><span class="line">theme: next # 修改成你的主题文件夹名</span><br></pre></td></tr></table></figure>

<p>Hexo 默认主题是 landscape，我使用的是 Next 主题，也是强烈推荐的，简洁、扁平化主题风格是我最喜欢的。配置使用 NexT 主题请参考：</p>
<blockquote>
<p><a href="http://theme-next.iissnan.com/" title="Next 主题中文文档">NexT 主题中文文档</a></p>
</blockquote>
<p>本来想单独写一个博客讲述主题方面的配置，不过这些都有官方文档，写的也都很详细，没必要做文章的搬运工(<del>明明是博主很懒！</del>)。如果有问题欢迎在下面提问(●’◡’●)</p>
<h1 id="使用自己的域名"><a href="#使用自己的域名" class="headerlink" title="使用自己的域名"></a>使用自己的域名</h1><h2 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h2><p>首先你需要一个域名。个人比较推荐  <a href="https://sg.godaddy.com/zh/" title="买域名 | 世界最大域名注册商 — GoDaddy">GoDaddy</a> 和 <a href="https://wanwang.aliyun.com/" title="域名注册_虚拟主机_云服务器_企业邮箱-万网-阿里云旗下品牌">万网</a>，我的域名是在万网买的。【好不容易抢到 cylong.com 这个域名，之前被人注册了，不过在16年2月份的时候就过期了，哈哈哈】</p>
<h2 id="设置-CNAME"><a href="#设置-CNAME" class="headerlink" title="设置 CNAME"></a>设置 CNAME</h2><p>在博客目录下的 <code>source</code> 文件夹下，创建一个名称为 <code>CNAME</code> 的文件，内容为你的域名，比如我的是:</p>
<figure class="highlight plain"><figcaption><span>source/CNAME</span></figcaption><table><tr><td class="code"><pre><span class="line">www.cylong.com</span><br></pre></td></tr></table></figure>

<p><b>注意</b>： <em><code>CNAME</code> 文件是不带后缀的。另外带 www 和不带 www，虽然用户在访问的时候网页内容是一样的，但是搜索引擎却认为是两个网页，最好自己选择一个首选域。更多详情请参考：<a href="http://www.cylong.com/blog/2016/05/02/preferred-domain/" title="网站首选域 | 笑话人生">网站首选域</a></em></p>
<h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>简单来说就是让你的网站和你购买的域名对应起来。万网提供免费的 DNS 解析服务。也可以使用 <a href="https://www.dnspod.cn/" title="DNSPod-免费智能DNS解析服务商">DNSPod</a> 的服务，但是要在域名注册商修改 DNS 服务地址为：</p>
<pre><code>f1g1ns1.dnspod.net
f1g1ns2.dnspod.net</code></pre>
<p>我在万网购买的域名，所以直接进行解析配置【默认使用万网的 DNS 解析服务，没有使用 DNSPod 的服务】。配置过程如下：</p>
<ol>
<li>登陆 <a href="https://wanwang.aliyun.com/" title="域名注册_虚拟主机_云服务器_企业邮箱-万网-阿里云旗下品牌">万网</a>。</li>
<li>点击最上面的 <code>管理控制台</code>，再点击左侧的 <code>云解析</code>。或者直接点击首页查询域名框下面的常用链接：<code>域名解析</code>。</li>
<li>选择你要解析的域名，点击域名后面的 <code>解析</code>。</li>
<li>解析配置如下【看不清图片可以点击放大】：</li>
</ol>
<img src="/blog/2016/04/19/hexo-git/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90.png" class="" title="域名解析配置">

<p>设置解析后大约几分钟就可以通过你的域名访问你的网站啦，如果你修改了 DNS 服务器，解析一般最长需要48小时生效。耐心等待吧~</p>
<h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><blockquote>
<p><a href="https://xuanwo.org/2015/03/26/hexo-intor/" title="Xuanwo&#39;s Blog - 史上最详细的Hexo博客搭建图文教程">Xuanwo’s Blog - 史上最详细的 Hexo 博客搭建图文教程</a><br><a href="http://wsgzao.github.io/post/hexo-guide/" title="HelloDog - 使用GitHub和Hexo搭建免费静态Blog">HelloDog - 使用 GitHub 和 Hexo 搭建免费静态Blog</a><br><a href="http://www.paopaoche.net/jiaocheng/85988.html" title="潇潇 - 搭建hexo部署到github图文教程">潇潇 - 搭建 hexo 部署到 github 图文教程</a></p>
</blockquote>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote>
<p><a href="https://hexo.io/zh-cn/docs/" title="Hexo 中文文档">Hexo 中文文档</a><br><a href="http://theme-next.iissnan.com/" title="Next 主题中文文档">NexT 主题中文文档</a><br><a href="http://wowubuntu.com/markdown/" title="Markdown 语法说明(简体中文版)">Markdown 语法说明(简体中文版)</a><br><a href="http://www.cylong.com/categories/Hexo/" title="分类：Hexo | 笑话人生">分类：Hexo | 笑话人生</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2016/04/19/hexo-git/' title='Hexo + Git 搭建免费的个人博客' >Hexo + Git 搭建免费的个人博客</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2016/04/19/hexo-git/' title='Hexo + Git 搭建免费的个人博客' >http://www.cylong.com/blog/2016/04/19/hexo-git/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>hexo</tag>
        <tag>git</tag>
        <tag>node.js</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 使用总结 &amp; 常见问题</title>
    <url>/blog/2016/04/25/hexo-faq/</url>
    <content><![CDATA[<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Hexo 是一个非常简洁的静态博客框架，可以快速的搭建生成自己的博客，但是在使用中总会遇到各种各样奇怪的错误，在这里我整理一下我所遇到的错误和一些使用技巧等等，也欢迎各位读者对使用技巧和使用问题进行补充。如果有什么问题也可以随时在下方提问。</p>
<p><strong>注意：</strong></p>
<ol>
<li><code>_config.yml</code> 文件在项目下有两个，一个在主题目录下，一个在博客根目录下。我在文中会说明是哪个文件。</li>
<li>本博客使用的是 NexT 主题，某些设置可能与主题有关。</li>
</ol>
<a id="more"></a>

<h1 id="让-Hexo-不渲染-md-或者-html"><a href="#让-Hexo-不渲染-md-或者-html" class="headerlink" title="让 Hexo 不渲染 .md 或者 .html"></a>让 Hexo 不渲染 .md 或者 .html</h1><p>我们知道，在 source 文件夹下的所有 md 文件或者 html 文件都会被渲染，有时候我们不想这些文件被渲染怎么办？比如很多时候我们想要写一个 README.md 或者一些自定义的页面。比如百度或者谷歌在验证站长权限的时候，通常都会要求在主目录下添加一个 html 文件。</p>
<h2 id="不渲染-html-文件"><a href="#不渲染-html-文件" class="headerlink" title="不渲染 html 文件"></a>不渲染 html 文件</h2><p>在不想被渲染的 html 文件最上面添加如下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">layout: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h2 id="不渲染-md-文件"><a href="#不渲染-md-文件" class="headerlink" title="不渲染 md 文件"></a>不渲染 md 文件</h2><p>使用上面的办法虽然不会渲染 md 文件，但是还是将 md 文件转化成了 html 文件，如果想保留原 md 文件后缀要怎么做呢？这就需要在 <code>站点配置文件</code> <code>_config.yml</code> 中配置，找到 <code>skip_render</code> 参数，开始匹配的位置是基于你的 <code>source_dir</code> 的，一般来说，是你的 <code>source</code> 文件夹下。下面我分别列举几种常见的情况进行说明：</p>
<ol>
<li><code>skip_render: test/*</code>    单个文件夹下全部文件</li>
<li><code>skip_render: test/*.md</code> 单个文件夹下指定类型文件</li>
<li><code>skip_render: test/**</code>   单个文件夹下全部文件以及子目录</li>
<li>多个文件夹以及各种复杂情况：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">skip_render:</span><br><span class="line">  - &#96;test1&#x2F;*.html&#96;</span><br><span class="line">  - &#96;test2&#x2F;**&#96;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="首页文章显示查看原文按钮"><a href="#首页文章显示查看原文按钮" class="headerlink" title="首页文章显示查看原文按钮"></a>首页文章显示查看原文按钮</h1><p>我们常常想在首页只显示文章的概述，而不是文章的全部，用一个 <code>阅读全文</code> 的字样代替，要怎么做呢？如下图：</p>
<img src="/blog/2016/04/25/hexo-faq/%E9%98%85%E8%AF%BB%E5%85%A8%E6%96%87.png" class="" title="阅读全文">

<p>在文章中只要写成如下格式即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这是摘要</span><br><span class="line"></span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line"></span><br><span class="line">这是全文</span><br></pre></td></tr></table></figure>

<p>需要注意的是，点击 <code>阅读全文</code> 之后，文章会自动定位到 <code>&lt;!-- more --&gt;</code> 所在位置，想要修改成从头阅读需要修改<code>主题配置文件</code> <code>_config.yml</code> 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Automatically scroll page to section which is under &lt;!-- more --&gt; mark.</span><br><span class="line">scroll_to_more: false &#x2F;&#x2F; NexT v7版本已经不支持</span><br></pre></td></tr></table></figure>

<h1 id="部署到-Github-后，部分修改未更新"><a href="#部署到-Github-后，部分修改未更新" class="headerlink" title="部署到 Github 后，部分修改未更新"></a>部署到 Github 后，部分修改未更新</h1><p>有时候当你 <code>hexo d --g</code> 部署到 Github 的时候，发现有些地方并没有更新，比如你的主题样式。这时候就建议你输入 <code>hexo clean</code> 清除下 public 文件夹下的文件，然后再部署【部署的时候实际上是直接拷贝 public 下的文件的】。另外多说一句，<code>hexo d --g</code> 是以下两个命令的缩写：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hexo g  <span class="comment"># 生成本地 public 静态文件</span></span><br><span class="line">hexo d  <span class="comment"># 部署到 Github 上</span></span><br><span class="line"><span class="comment"># 也可以缩写成：hexo g --d</span></span><br></pre></td></tr></table></figure>

<h1 id="Hexo-使用-Fort-Awesome-图标"><a href="#Hexo-使用-Fort-Awesome-图标" class="headerlink" title="Hexo 使用 Fort Awesome 图标"></a>Hexo 使用 Fort Awesome 图标</h1><p>我们知道，在我们写博客的时候，博客文件，或者自己自定义的页面，比如关于页面，都是 md 文件。最后会转化成 Html 文件。但是所支持的标签还是没有 Html 的全面，不过我们可以直接在 md 文件中写 Html 标签，比如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">del</span>&gt;</span>你什么都没有看见<span class="tag">&lt;/<span class="name">del</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当然，你可以直接使用 <a href="https://fortawesome.github.io/Font-Awesome/icons/" title="Font Awesome icons">Fort Awesome</a> 图标，下面是我在 <a href="http://www.cylong.com/about/#%E8%81%94%E7%B3%BB%E6%88%91" title="关于 - 联系我">关于</a> 页面写的代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"># 联系我</span><br><span class="line"></span><br><span class="line">如果有志同道合的小伙伴，或者想找个基友什么的，欢迎联系！</span><br><span class="line"></span><br><span class="line">*   <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-envelope&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> Email: cyl19941016@sina.com</span><br><span class="line">*   <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-qq&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> QQ: 948557407</span><br><span class="line">*   <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-wechat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> 微信：cyl19941016</span><br></pre></td></tr></table></figure>

<h1 id="配置-SSH-公钥免去部署的时候输入密码"><a href="#配置-SSH-公钥免去部署的时候输入密码" class="headerlink" title="配置 SSH 公钥免去部署的时候输入密码"></a>配置 SSH 公钥免去部署的时候输入密码</h1><figure class="highlight sh"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo:</span><br><span class="line">    github: git@github.com:cylong1016/cylong1016.github.io.git <span class="comment"># Github SSH</span></span><br><span class="line">    <span class="comment"># github: https://github.com/cylong1016/cylong1016.github.io.git # Github HTTPS</span></span><br><span class="line">    coding: git@git.coding.net:cylong1016/cylong1016.git <span class="comment"># Coding SSH</span></span><br><span class="line">    <span class="comment"># coding: https://git.coding.net/cylong1016/cylong1016.git # Coding HTTPS</span></span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>上面的代码是 _config.yml 中部署的代码，分别是部署到 Github 和 Coding 上的两种方式，使用 HTTPS 方式的话每次部署都需要输入用户名和密码，很麻烦。</p>
<img src="/blog/2016/04/25/hexo-faq/OpenSSH.png" class="" title="OpenSSH">
<p>所以我选择使用 SSH 的方式，此方式是本机与远程仓库建立对接，这样部署的时候就不需要输入用户名和密码了。但是需要以下的配置：</p>
<p>打开终端或者 Git Bash，依次输入：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkdir ~/.ssh    <span class="comment"># 如果之前没有这个文件夹就创建此文件夹</span></span><br><span class="line"><span class="built_in">cd</span> ~/.ssh       <span class="comment"># 进入到 .ssh 文件夹中</span></span><br><span class="line"></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;youremail@example.com&quot;</span>    <span class="comment"># 生成密钥</span></span><br><span class="line"><span class="comment"># 接着会提示输入 file 和 passphrase，直接回车就行。</span></span><br><span class="line"><span class="comment"># 接着会看到下面的输出：</span></span><br><span class="line">Your identification has been saved <span class="keyword">in</span> /home/cylong/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /home/cylong/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">fd:56:db:23:db:bf:df:54:0a:6a:43:51:13:34:22:b6 youremail@example.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接着输入</span></span><br><span class="line">ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>
<p>然后打开 <a href="https://github.com/settings/ssh">https://github.com/settings/ssh</a>【Github】，点击 <code>New SSH key</code>，复制 <code>id_rsa.pub</code> 中的所有内容到 Key 框中，在 Title 框中输入方便自己记忆的名字【比如我的是 Personal Ubuntu】。<a href="https://coding.net/user/account/setting/keys">https://coding.net/user/account/setting/keys</a>【Coding】也一样，但是需要注意的是注册邮箱要一样，否则要两个 SSH。最后输入 <code>ssh -T git@github.com</code> 和 <code>ssh -T git@git.coding.net</code> 测试是否配置成功。</p>
<h1 id="Ubuntu-下使用-Hexo"><a href="#Ubuntu-下使用-Hexo" class="headerlink" title="Ubuntu 下使用 Hexo"></a>Ubuntu 下使用 Hexo</h1><p>辗转反侧，还是忍不住使用 Ubuntu 系统。而且基本所有的人都和我说以后的开发都要使用 Linux 系统。所以最近准备使用 Ubuntu 练手，当然，博客也要在 Ubuntu 上更新了。由于我的博客已经在 Windows 系统下搭建好了，教程参考 <a href="http://www.cylong.com/blog/2016/04/19/hexo-git/" title="Hexo + Git 搭建免费的个人博客 | 笑话人生">Hexo + Git 搭建免费的个人博客 | 笑话人生</a> 【虽然是 Windows 下的教程，但是其他平台步骤都是一样的】。Hexo 源码放在 <a href="https://github.com/cylong1016/HexoBlog" title="HexoBlog">Github - HexoBlog</a> 上。所以直接 clone 下来就好。下面就说说我在 Ubuntu 系统下遇到的问题。</p>
<ol>
<li><p>在执行 npm 命令时出现以下错误：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sh: 1: node: not found</span><br><span class="line">npm WARN This failure might be due to the use of legacy binary <span class="string">&quot;node&quot;</span></span><br><span class="line">npm WARN For further explanations, please <span class="built_in">read</span></span><br><span class="line">/usr/share/doc/nodejs/README.Debian</span><br></pre></td></tr></table></figure>
<p>解决办法，执行以下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nodejs-legacy</span><br></pre></td></tr></table></figure>
<p>详情请参考：</p>
<blockquote>
<p><a href="http://stackoverflow.com/questions/21168141/cannot-install-packages-using-node-package-manager-in-ubuntu">http://stackoverflow.com/questions/21168141/cannot-install-packages-using-node-package-manager-in-ubuntu</a></p>
<p><a href="http://stackoverflow.com/questions/20057790/what-are-the-differences-between-node-js-and-node">http://stackoverflow.com/questions/20057790/what-are-the-differences-between-node-js-and-node</a></p>
<p><a href="https://github.com/hexojs/hexo/issues/580">https://github.com/hexojs/hexo/issues/580</a></p>
</blockquote>
</li>
<li><p>执行 hexo 命令时出现以下错误：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">FATAL Cannot find module <span class="string">&#x27;/home/cylong/Github/HexoBlog/node_modules/hexo-deployer-git&#x27;</span></span><br></pre></td></tr></table></figure>
<p>原因是没有 hexo-deployer-git module。执行以下命令安装：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以正常执行 hexo 命令，但是会出现下面的警告：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Native thread-sleep not available.</span><br><span class="line">This will result <span class="keyword">in</span> much slower performance, but it will still work.</span><br><span class="line">You should re-install spawn-sync or upgrade to the lastest version of node <span class="keyword">if</span> possible.</span><br><span class="line">Check /usr/<span class="built_in">local</span>/lib/node_modules/hexo-cli/node_modules/hexo-util/node_modules/cross-spawn/node_modules/spawn-sync/error.log <span class="keyword">for</span> more details</span><br></pre></td></tr></table></figure>
<p>解决办法如上警告所说，升级 node.js。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo npm cache clean -f</span><br><span class="line">sudo npm install -g n</span><br><span class="line">sudo n stable</span><br></pre></td></tr></table></figure>
<p>详情请参考：</p>
<blockquote>
<p><a href="http://stackoverflow.com/questions/8191459/how-to-update-node-js">http://stackoverflow.com/questions/8191459/how-to-update-node-js</a></p>
</blockquote>
</li>
<li><p>执行 <code>hexo g</code> 无法部署到 Github 上，出现如下错误：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Permission denied (publickey).</span><br><span class="line">fatal: Could not <span class="built_in">read</span> from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br><span class="line">FATAL Something<span class="string">&#x27;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span></span><br><span class="line"><span class="string">Error: Permission denied (publickey).</span></span><br><span class="line"><span class="string">fatal: Could not read from remote repository.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Please make sure you have the correct access rights</span></span><br><span class="line"><span class="string">and the repository exists.</span></span><br></pre></td></tr></table></figure>
<p>解决办法，请参考：</p>
</li>
</ol>
<blockquote>
<p><a href="/blog/2016/04/25/hexo-faq/#%E9%85%8D%E7%BD%AE-SSH-%E5%85%AC%E9%92%A5%E5%85%8D%E5%8E%BB%E9%83%A8%E7%BD%B2%E7%9A%84%E6%97%B6%E5%80%99%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81" title="配置 SSH 公钥免去部署的时候输入密码">配置 SSH 公钥免去部署的时候输入密码</a></p>
</blockquote>
<h1 id="添加-RSS-订阅"><a href="#添加-RSS-订阅" class="headerlink" title="添加 RSS 订阅"></a>添加 RSS 订阅</h1><ol>
<li><p>安装 Feed 插件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置站点目录下的 <code>_config.yml</code> 文件，添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">feed:</span><br><span class="line">    type: atom</span><br><span class="line">    path: atom.xml</span><br><span class="line">    limit: 20</span><br><span class="line">    hub:</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>type - 订阅类型 (atom 或 rss2)</li>
<li>path - 路径 (默认: atom.xml 或 rss2.xml)</li>
<li>limit - 最多显示文章数量 (0 或 false 展示所有文章)</li>
<li>hub - PubSubHubbub hubs 的 URL (PubSubHubbub 是一个“开放的、服务器对服务器、基于Web-hook的发布/订阅协议，是 Atom 和 RSS 的扩展”。不使用就留空)</li>
</ul>
<h1 id="网站底部字数统计"><a href="#网站底部字数统计" class="headerlink" title="网站底部字数统计"></a>网站底部字数统计</h1><ol>
<li><p>安装 hexo-wordcount 插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>/themes/next/layout/_partials/footer.swig</code> 中最后加上:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;theme-info&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;powered-by&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-count&quot;</span>&gt;</span>博客共&#123;&#123; totalcount(site) &#125;&#125;字<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>参考：<a href="https://www.npmjs.com/package/hexo-wordcount" title="hexo-wordcount">hexo-wordcount</a></p>
</li>
</ol>
<h1 id="LF-will-be-replaced"><a href="#LF-will-be-replaced" class="headerlink" title="LF will be replaced"></a>LF will be replaced</h1><p>Windows 提交命令的时候出现 <code>warning: LF will be replaced by CRLF in xxx</code> 的警告。输入以下命令即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global core.autocrlf false</span><br></pre></td></tr></table></figure>

<h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><blockquote>
<p><a href="https://xuanwo.org/2014/08/14/hexo-usual-problem/" title="Xuanwo&#39;s Blog - Hexo常见问题解决方案">Xuanwo’s Blog - Hexo常见问题解决方案</a><br><a href="https://xuanwo.org/2015/02/07/generate-a-ssh-key/" title="Xuanwo&#39;s Blog - 使用Github SSH Key以免去Hexo部署时输入密码">Xuanwo’s Blog - 使用Github SSH Key以免去Hexo部署时输入密码</a><br><a href="http://www.arao.me/2015/hexo-next-theme-optimize-seo/" title="动动手指，不限于NexT主题的Hexo优化（SEO篇） | ARAO&#39;S BLOG">动动手指，不限于NexT主题的Hexo优化（SEO篇） | ARAO’S BLOG</a><br><a href="https://zingss.github.io/" title="生生之境">生生之境</a> 提出的各种【高智商(●’◡’●)】问题<br><a href="http://latias94.github.io/2016/09/30/Hexo-patch/" title="Hexo 博客补丁 - 萤火之森">Hexo 博客补丁 - 萤火之森</a><br><a href="http://blog.tangxiaozhu.com/p/45374067/" title="使用 Hexo 搭建博客的深度优化与定制 - 唐小筑">使用 Hexo 搭建博客的深度优化与定制 - 唐小筑</a><br><a href="https://segmentfault.com/a/1190000004548638" title="hexo同时托管到coding.net与github - shomy">hexo同时托管到coding.net与github - shomy</a></p>
</blockquote>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote>
<p><a href="http://www.cylong.com/blog/2016/04/19/hexo-git/" title="Hexo + Git 搭建免费的个人博客 | 笑话人生">Hexo + Git 搭建免费的个人博客 | 笑话人生</a><br><a href="https://hexo.io/zh-cn/" title="Hexo 中文文档">Hexo 中文文档</a> 【包涵：文档、API、插件、主题】<br><a href="http://theme-next.iissnan.com/" title="NexT 使用文档">NexT 使用文档</a> 【包含：开始使用、主题配置、第三方服务、内建标签、常见问题】<br><a href="https://github.com/hexojs/hexo-generator-feed" title="Feed generator for Hexo">Feed generator for Hexo</a><br><a href="https://www.npmjs.com/package/hexo-wordcount" title="hexo-wordcount">hexo-wordcount</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2016/04/25/hexo-faq/' title='Hexo 使用总结 & 常见问题' >Hexo 使用总结 & 常见问题</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2016/04/25/hexo-faq/' title='Hexo 使用总结 & 常见问题' >http://www.cylong.com/blog/2016/04/25/hexo-faq/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>Atom 的炫酷插件 activate-power-mode</title>
    <url>/blog/2016/04/22/activate-power-mode/</url>
    <content><![CDATA[<hr>
<h1 id="Atom-简介"><a href="#Atom-简介" class="headerlink" title="Atom 简介"></a>Atom 简介</h1><p><a href="https://atom.io/" title="Atom">Atom</a> 是一款免费的编辑器，我一般在写 Web 项目的时候使用。写 Java 项目用 Eclipse， 其他直接用 Notepad++，别问我为什么不用 Sublime。喜欢这款编辑器的主要原因是它的黑色扁平化主题风格非常炫酷，功能也比较强大，缺点就是比较吃内存，启动比较慢( ╯□╰ )。最近使用 Atom 写自己的博客【没错，就是现在这个博客】，想到了 <a href="https://github.com/JoelBesada/activate-power-mode" title="activate-power-mode">activate-power-mode</a> 插件的炫酷效果，于是就体验了一下。下面介绍下详细安装过程。</p>
<a id="more"></a>

<h1 id="安装使用-activate-power-mode"><a href="#安装使用-activate-power-mode" class="headerlink" title="安装使用 activate-power-mode"></a>安装使用 activate-power-mode</h1><p>注意：本文针对 <em>Windows</em> 和 <em>Ubuntu</em> 平台，其他平台也差不多，自己琢磨吧~</p>
<p>先上图！</p>
<img src="/blog/2016/04/22/activate-power-mode/activate-power-mode.gif" class="" title="activate-power-mode 插件">

<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul>
<li><a href="https://atom.io/" title="Atom">Atom</a></li>
<li><a href="https://github.com/JoelBesada/activate-power-mode" title="activate-power-mode">activate-power-mode</a></li>
<li><a href="http://nodejs.org/" title="Node.js">Node.js</a></li>
</ul>
<p>点击上面的三个链接，分别下载下来 Atom、activate-power-mode、Node.js，然后安装 Atom、Node.js。</p>
<ul>
<li>Windows：直接双击安装就可以。</li>
<li>Ubuntu： 运行 <code>sudo dpkg -i xxx-atom-xxx.deb</code> 安装 Atom。</li>
</ul>
<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>解压下载下来的 activate-power-mode zip 包，移动到 <code>~\.atom\packages</code> 下，比如 Windows 是  <code>C:\Users\cylong\.atom\packages</code> ，Ubuntu 是 <code>home/cylong/.atom/packages</code>，接下来进入到 <code>activate-power-mode</code> 目录下，打开终端，输入：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install <span class="comment"># 安装必要的 module</span></span><br></pre></td></tr></table></figure>

<p>之后重启 Atom ，使用右键选择 <code>Toggle</code> 或者 <code>Ctrl ＋ Alt ＋ O</code> 就启动插件了，体验炫酷的效果吧！</p>
<h2 id="插件设置"><a href="#插件设置" class="headerlink" title="插件设置"></a>插件设置</h2><p>刚开始用的时候感觉蛮好玩的，非常爽。然后用了不到一分钟，我就觉得眼睛要瞎了！估计在玩个几分钟就真的瞎了！！屏幕震动效果闪瞎我的双眼！要是能够把震动效果删除会不会好一点？于是自己开始找这个插件的设置，果然有！</p>
<ul>
<li>首先点击 Atom 左上角的 <code>File</code> 按钮，Ubuntu 是 <code>Edit</code></li>
<li>Windows 进入到 <code>Settings</code>，Ubuntu 是 <code>Preferences</code></li>
<li>找到 <code>packages</code> 设置</li>
<li>找到  <code>activate-power-mode</code></li>
<li>进入到  <code>Settings</code></li>
<li>找到 <code>Screen Shake - Enable</code>， 将前面的 √ 去掉</li>
</ul>
<p>之后就只有颗粒效果啦，现在感觉好多了吧(●’◡’●)。插件设置中还有颗粒大小的设置，自己根据需要修改吧~</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>把屏幕震动效果关掉后感觉好很多了。也一直在用这个效果，感觉还是蛮帅的~不过，如果一行中字符太多，Atom 会自动换行显示，但是这些字符还是在同一行的，这个时候这个插件产生的效果就会错位，就是产生的颗粒不是在当前输入的字符位置，目前我还没解决 ( ╯□╰ )，谁有好的解决办法欢迎联系我。另外，如果读者有更好的 Atom 插件或者使用技巧，欢迎留言或者 <a href="/about/#%E8%81%94%E7%B3%BB%E6%88%91" title="联系我">联系我</a>。最后推荐下自己比较喜欢的编辑器 <a href="https://atom.io/" title="Atom">Atom</a> 吧 (●’◡’●)</p>
<h1 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h1><p><strong>2016-05-15 更新</strong><br>这个插件的作者是比较良心的，修复了 Atom 自动换行后，插件产生的颗粒位置错位的 BUG。现在一直在用这个插件，写代码越来越有激情了呢 o(^▽^)o</p>
<p><strong>2016-06-01 更新</strong><br>我有点傻了( ╯□╰ )，我发现直接进入到 <code>Preferences(首选项)-&gt; install(安装)</code>，就可以直接安装 activate-power-mode 插件了。</p>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2016/04/22/activate-power-mode/' title='Atom 的炫酷插件 activate-power-mode' >Atom 的炫酷插件 activate-power-mode</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2016/04/22/activate-power-mode/' title='Atom 的炫酷插件 activate-power-mode' >http://www.cylong.com/blog/2016/04/22/activate-power-mode/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>Atom</category>
      </categories>
      <tags>
        <tag>atom</tag>
        <tag>插件</tag>
        <tag>ubuntu</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache 如何设置 404 错误页面</title>
    <url>/blog/2016/04/29/apache-404/</url>
    <content><![CDATA[<hr>
<p>当我们浏览网站的时候，有时候会发现访问的页面不存在了，页面会有“你访问的页面不存在了，跳转到主页”或者“404 Not Found”等等的提示。我们通常称之为 404 页面。所谓的 404 页面就是当用户输入一个错误或非存在的链接时，显示的一个页面。当 Web 服务器接到类似请求时，会返回一个 404 状态码，告诉浏览器要请求的资源并不存在。显示的 404 页面主要作用是告诉用户，你输入的网址多请求的页面是不存在的或者是一个错误的链接，引导用户进入网站的其他页面。但是 Web 的默认 404 页面非常的简陋，对用户很不友好，这就需要我们自己定义个性化的 404 页面，提升用户体验。</p>
<a id="more"></a>

<h1 id="Apache-设置-404-错误页面"><a href="#Apache-设置-404-错误页面" class="headerlink" title="Apache 设置 404 错误页面"></a>Apache 设置 404 错误页面</h1><p>在 <code>.htaccess</code> 文件中加入代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ErrorDocument 404 &#x2F;404.html</span><br></pre></td></tr></table></figure>

<p>之后在网站根目录建立一个 <code>404.html</code> 文件，编写你的 404 页面。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>不要将 404 页面直接指向到网站主页，这可能导致你的首页不被搜索引擎收录。</li>
<li>/404.html 不要带域名，比如(错误写法：<a href="http://www.cylong.com/404.html">http://www.cylong.com/404.html</a>)，否则返回的状态码不是 404，而是 302、200。</li>
</ul>
<h1 id="SEO-搜索引擎优化"><a href="#SEO-搜索引擎优化" class="headerlink" title="SEO(搜索引擎优化)"></a>SEO(搜索引擎优化)</h1><p>404 状态码对搜索引擎是非常重要的。需要注意的是，有时候我们看到一个 404 的错误页面，但返回的状态码可能并不是 404。用户并不会关心状态码是多少，但是对于搜索引擎就不一样了。当搜索引擎获取到404 状态码，就表示此 URL 已经失效，页面已经不存在了。搜索引擎就不会索引这个页面，并且删除数据库中的索引。若返回的是 200，搜索引擎就会对此 URL 建立索引，这样就会产生多个不同的 URL 具有相同的页面内容，搜索引擎就认为你的网站有大量重复的内容，可能会被降权。</p>
<p>所以当我们自定义错误页面的时候，一定要保证状态码也是 404，不仅要对用户友好，也要对搜索引擎友好。</p>
<h1 id="参考资料-amp-感谢"><a href="#参考资料-amp-感谢" class="headerlink" title="参考资料&amp;感谢"></a>参考资料&amp;感谢</h1><blockquote>
<p><a href="http://bbs.20z.com/thread-5162-1-1.html" title="网站如何设置404页面，什么是404错误，404页面代码怎么写">网站如何设置404页面，什么是404错误，404页面代码怎么写</a><br><a href="http://www.yzznl.cn/archives/19.html" title="园子博客 - 如何设置404页面">园子博客 - 如何设置404页面</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2016/04/29/apache-404/' title='Apache 如何设置 404 错误页面' >Apache 如何设置 404 错误页面</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2016/04/29/apache-404/' title='Apache 如何设置 404 错误页面' >http://www.cylong.com/blog/2016/04/29/apache-404/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>Apache</category>
      </categories>
      <tags>
        <tag>apache</tag>
        <tag>seo</tag>
        <tag>htaccess</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 集成多说评论 + 多说分享 + 美化多说</title>
    <url>/blog/2016/04/25/hexo-next-duoshuo/</url>
    <content><![CDATA[<hr>
<h1 id="多说简介"><a href="#多说简介" class="headerlink" title="多说简介"></a>多说简介</h1><p>多说是一款追求极致体验的社会化评论框，可以用微博、QQ、人人、豆瓣等帐号登录并评论。功能强大且永久免费。Hexo 默认使用的评论插件是国外的 Disqus，。对于国内来说，使用多说无非是最好的。这篇文章就介绍下如何在 Hexo 中添加多说评论插件和多说 CSS 的美化，顺便说一下多说分享插件。至于如何搭建 Hexo 博客请参考：</p>
<blockquote>
<p><a href="http://www.cylong.com/blog/2016/04/19/hexo-git/" title="Hexo + Git 搭建免费的个人博客">Hexo + Git 搭建免费的个人博客</a> </p>
</blockquote>
<a id="more"></a>

<h1 id="集成多说"><a href="#集成多说" class="headerlink" title="集成多说"></a>集成多说</h1><p><b>注意:</b> <em>我使用的是 NexT 主题，集成多说插件非常简单，这也是我喜欢这个主题的原因，简单、高效。其他主题的配置需要你们自己研究了，不过都差不多的。NexT 主题更多第三方服务请参考：</em></p>
<blockquote>
<p><a href="http://theme-next.iissnan.com/third-party-services.html" title="第三方服务集成 - NexT 使用文档">第三方服务集成 - NexT 使用文档</a></p>
</blockquote>
<h2 id="NexT-主题"><a href="#NexT-主题" class="headerlink" title="NexT 主题"></a>NexT 主题</h2><p>下面说一下 NexT 主题如何集成多说。首先要在 <a href="http://duoshuo.com/" title="多说">多说</a> 创建一个站点，具体步骤如下：</p>
<ol>
<li>登录后在首页选择 “我要安装”。</li>
<li>创建站点，填写表单。如图：<img src="/blog/2016/04/25/hexo-next-duoshuo/duoshuo_create.png" class="" title="多说创建站点"></li>
<li>在博客站点配置文件 <code>_config.yml</code> 中添加如下代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 多说评论功能</span><br><span class="line">duoshuo_shortname: xxx # 你填写在多说域名中的值</span><br><span class="line"></span><br><span class="line"># 多说分享服务，必须与多说评论同时使用</span><br><span class="line">duoshuo_share: true</span><br></pre></td></tr></table></figure></li>
<li>启用后默认在所有页面都会显示多说评论框，比如分类页面、标签页面、自定义的关于页面，如果不想在这些页面显示评论框，找到对应的<code>index.md</code>文档，在<code>Front-matter</code>(文件最上方以 <code>---</code> 分隔的区域)中加入 <code>comments: false</code> 这一行代码就行了</li>
</ol>
<h2 id="Landscape-主题"><a href="#Landscape-主题" class="headerlink" title="Landscape 主题"></a>Landscape 主题</h2><p>顺便说一下 Hexo 默认的 Landscape 主题如何集成多说，具体步骤如下：</p>
<ol>
<li>与上面相同</li>
<li>修改 <code>themes\landscape\layout\_partial\article.ejs</code> 模板，把：</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (!<span class="attr">index</span> &amp;&amp; <span class="attr">post.comments</span> &amp;&amp; <span class="attr">config.disqus_shortname</span>)&#123; %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;comments&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;disqus_thread&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">noscript</span>&gt;</span>Please enable JavaScript to view the <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;//disqus.com/?ref_noscript&quot;</span>&gt;</span>comments powered by Disqus.<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br></pre></td></tr></table></figure>

<p>改为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (!<span class="attr">index</span> &amp;&amp; <span class="attr">post.comments</span> &amp;&amp; <span class="attr">config.duoshuo_shortname</span>)&#123; %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;comments&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 多说评论框 start --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ds-thread&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">data-thread-key</span>=<span class="string">&quot;&lt;%= post.layout %&gt;-&lt;%= post.slug %&gt;&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">data-title</span>=<span class="string">&quot;&lt;%= post.title %&gt;&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">data-url</span>=<span class="string">&quot;&lt;%= page.permalink %&gt;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 多说评论框 end --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> duoshuoQuery = &#123;<span class="attr">short_name</span>:<span class="string">&#x27;&lt;%= config.duoshuo_shortname %&gt;&#x27;</span>&#125;;</span></span><br><span class="line"><span class="javascript">        (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> ds = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span></span><br><span class="line"><span class="javascript">            ds.type = <span class="string">&#x27;text/javascript&#x27;</span>;ds.async = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">            ds.src = (<span class="built_in">document</span>.location.protocol == <span class="string">&#x27;https:&#x27;</span> ? <span class="string">&#x27;https:&#x27;</span> : <span class="string">&#x27;http:&#x27;</span>) + <span class="string">&#x27;//static.duoshuo.com/embed.js&#x27;</span>;</span></span><br><span class="line"><span class="javascript">            ds.charset = <span class="string">&#x27;UTF-8&#x27;</span>;</span></span><br><span class="line"><span class="javascript">            (<span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;head&#x27;</span>)[<span class="number">0</span>] || <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;body&#x27;</span>)[<span class="number">0</span>]).appendChild(ds);</span></span><br><span class="line">        &#125;)();</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 多说公共JS代码 end --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="美化多说"><a href="#美化多说" class="headerlink" title="美化多说"></a>美化多说</h1><h2 id="多说设置"><a href="#多说设置" class="headerlink" title="多说设置"></a>多说设置</h2><p>登陆 <a href="http://duoshuo.com/" title="多说">多说</a>，点击后台管理，在<code>设置</code>中修改，包括基本设置、自定义文本、默认头像、外观主题。如图：</p>
<img src="/blog/2016/04/25/hexo-next-duoshuo/duoshuo_text.png" class="" title="多说自定义文本">

<h2 id="自定义多说分享图标"><a href="#自定义多说分享图标" class="headerlink" title="自定义多说分享图标"></a>自定义多说分享图标</h2><p>多说提供很多平台的分享服务，有时候我们肯能并不需要这么多，要如何修改呢？<br>首先，进入到 <code>themes\next\layout\_partials\share\duoshuo_share.swig</code> ，在这里就可以修改图标，至于都有什么图标，请参考：</p>
<blockquote>
<p><a href="http://dev.duoshuo.com/docs/5497972ba1165bfd53cf4263" title="多说分享组件自定义图标 - 多说开发者中心">多说分享组件自定义图标 - 多说开发者中心</a></p>
</blockquote>
<h2 id="多说评论显示-UA"><a href="#多说评论显示-UA" class="headerlink" title="多说评论显示 UA"></a>多说评论显示 UA</h2><p>在每一条多说评论后显示评论者所使用的代理信息（如 操作系统、浏览器），效果如下：</p>
<img src="/blog/2016/04/25/hexo-next-duoshuo/duoshuo_ua.png" class="" title="多说评论显示 UA 示例">

<p>启用此功能，需要编辑<code>主题配置文件</code> <code>_congig.yml</code> 如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Make duoshuo show UA</span><br><span class="line"># user_id must NOT be null when admin_enable is true!</span><br><span class="line"># you can visit http:&#x2F;&#x2F;dev.duoshuo.com get duoshuo user id.</span><br><span class="line">duoshuo_info:</span><br><span class="line">  ua_enable: true</span><br><span class="line">  admin_enable: true</span><br><span class="line">  user_id: xxxxxx</span><br><span class="line">  admin_nickname: 权限汪</span><br></pre></td></tr></table></figure>

<p>只要设置 <code>ua_enable</code> 为 true 即可显示 UA 信息。 <code>admin_enable</code> 是用于显示 <code>博主</code> 文字，表明评论者是博主【默认显示的是博主，我给改成权限汪了】，此字段需要同时配置 user_id。 请访问 <a href="http://dev.duoshuo.com/" title="多说开发者中心">多说开发者中心</a>，登录并访问 <code>我的主页</code> 获取 user_id ， 此 ID 是网址最后那串数字。</p>
<h2 id="自定义-CSS"><a href="#自定义-CSS" class="headerlink" title="自定义 CSS"></a>自定义 CSS</h2><p>登陆 <a href="http://duoshuo.com/" title="多说">多说</a>，点击后台管理，在 <code>设置/基本设置/自定义CSS</code> 中可以修改多说的 CSS 样式，如图：</p>
<img src="/blog/2016/04/25/hexo-next-duoshuo/duoshuo_css.png" class="" title="多说 - 自定义 CSS">

<p>我的修改如下（可以使用键盘上的上下左右查看看不到的代码）：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 设置圆形头像 */</span></span><br><span class="line"><span class="selector-id">#ds-reset</span> <span class="selector-class">.ds-avatar</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">54px</span>; <span class="attribute">height</span>:<span class="number">54px</span>;   <span class="comment">/*设置图像的长和宽*/</span></span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">27px</span>;        <span class="comment">/*设置图像圆角效果,在这里我直接设置了超过 width/2 的像素，即为圆形了*/</span></span><br><span class="line">    <span class="attribute">-webkit-border-radius</span>: <span class="number">27px</span>;<span class="comment">/*圆角效果：兼容webkit浏览器*/</span></span><br><span class="line">    <span class="attribute">-moz-border-radius</span>: <span class="number">27px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 所有样式 */</span></span><br><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">-webkit-border-radius</span>: <span class="number">0px</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">0px</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: inset <span class="number">0</span> <span class="number">0</span> <span class="number">0px</span> <span class="number">#fff</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 喜欢按钮 */</span></span><br><span class="line"><span class="selector-id">#ds-thread</span> <span class="selector-id">#ds-reset</span> <span class="selector-tag">a</span><span class="selector-class">.ds-like-thread-button</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#f3726d</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#fff</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">0</span> <span class="number">0px</span> <span class="number">0</span> <span class="number">#fff</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 点击喜欢后弹出的分享图标 */</span></span><br><span class="line"><span class="selector-class">.ds-service-link</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&quot;//static.duoshuo.com/images/service-icons-color-flat.png?v=2&quot;</span>) no-repeat;</span><br><span class="line">    <span class="attribute">_background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;//static.duoshuo.com/images/service-icons-color-flat.gif?v=2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 上面那个分享图标我是想改成扁平化的，但是修改了后 */</span></span><br><span class="line"><span class="comment">/* 下面这几个图标的坐标位置属性（多说原生的代码）就无效了，不知道为什么，于是自己手动写上去了 */</span></span><br><span class="line"><span class="selector-id">#ds-reset</span> <span class="selector-class">.ds-qzone</span> &#123;</span><br><span class="line">    <span class="attribute">background-position</span>: <span class="number">0</span> -<span class="number">128px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#ds-reset</span> <span class="selector-class">.ds-qqt</span> &#123;</span><br><span class="line">    <span class="attribute">background-position</span>: <span class="number">0</span> -<span class="number">64px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#ds-reset</span> <span class="selector-class">.ds-renren</span> &#123;</span><br><span class="line">    <span class="attribute">background-position</span>: <span class="number">0</span> -<span class="number">32px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#ds-reset</span> <span class="selector-class">.ds-kaixin</span> &#123;</span><br><span class="line">    <span class="attribute">background-position</span>: <span class="number">0</span> -<span class="number">80px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#ds-reset</span> <span class="selector-class">.ds-douban</span> &#123;</span><br><span class="line">    <span class="attribute">background-position</span>: <span class="number">0</span> -<span class="number">96px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#ds-reset</span> <span class="selector-class">.ds-baidu</span> &#123;</span><br><span class="line">    <span class="attribute">background-position</span>: <span class="number">0</span> -<span class="number">208px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 被顶起来的评论 */</span></span><br><span class="line"><span class="selector-id">#ds-reset</span> <span class="selector-class">.ds-gradient-bg</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#E9E9E9</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 评论框默认显示文字样式 */</span></span><br><span class="line"><span class="selector-id">#ds-thread</span> <span class="selector-id">#ds-reset</span> <span class="selector-class">.ds-textarea-wrapper</span> <span class="selector-tag">textarea</span>, <span class="selector-id">#ds-thread</span> <span class="selector-id">#ds-reset</span> <span class="selector-class">.ds-textarea-wrapper</span> <span class="selector-class">.ds-hidden-text</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&quot;Microsoft YaHei&quot;</span>, Verdana, sans-serif <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 发布评论按钮 */</span></span><br><span class="line"><span class="selector-id">#ds-thread</span> <span class="selector-id">#ds-reset</span> <span class="selector-class">.ds-post-button</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&quot;Microsoft YaHei&quot;</span>, Verdana, sans-serif <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">0</span> none <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#FFFFFF</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">background</span>: none repeat scroll <span class="number">0</span> <span class="number">0</span> <span class="number">#F3726D</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">display</span>: inline-block <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">text-transform</span>: none <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">transition</span>: all <span class="number">0.3s</span> ease <span class="number">0s</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">-moz-transition</span>: all <span class="number">0.3s</span> ease <span class="number">0s</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">-webkit-transition</span>: all <span class="number">0.3s</span> ease <span class="number">0s</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">0</span> <span class="number">0px</span> <span class="number">0</span> <span class="number">#fff</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 发布评论按钮  hover */</span></span><br><span class="line"><span class="selector-id">#ds-thread</span> <span class="selector-id">#ds-reset</span> <span class="selector-class">.ds-post-button</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: none repeat scroll <span class="number">0</span> <span class="number">0</span> <span class="number">#303030</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">color</span>: white <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 评论框边框 */</span></span><br><span class="line"><span class="selector-class">.theme-next</span> <span class="selector-id">#ds-thread</span> <span class="selector-id">#ds-reset</span> <span class="selector-class">.ds-textarea-wrapper</span> &#123;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="number">#DEDEDE</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 评论框下面框的边框(好绕啊！) */</span></span><br><span class="line"><span class="selector-id">#ds-thread</span> <span class="selector-id">#ds-reset</span> <span class="selector-class">.ds-post-toolbar</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#DEDEDE</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#E9E9E9</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 昵称 */</span></span><br><span class="line"><span class="selector-id">#ds-reset</span> <span class="selector-class">.ds-highlight</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#F3726D</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 顶 */</span></span><br><span class="line"><span class="selector-id">#ds-thread</span> <span class="selector-id">#ds-reset</span> <span class="selector-class">.ds-post-liked</span> <span class="selector-tag">a</span><span class="selector-class">.ds-post-likes</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#F3726D</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 发布旁边的“分享到”图标 */</span></span><br><span class="line"><span class="selector-id">#ds-reset</span> <span class="selector-class">.ds-service-icon</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;//static.duoshuo.com/images/service-icons-color-flat.png&quot;</span>) <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">_background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;//static.duoshuo.com/images/service-icons-color-flat.gif&quot;</span>) <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 隐藏多说底部的版权 */</span></span><br><span class="line"><span class="selector-id">#ds-thread</span> <span class="selector-id">#ds-reset</span> <span class="selector-class">.ds-powered-by</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 最近访客的头像 */</span></span><br><span class="line"><span class="selector-id">#ds-recent-visitors</span> <span class="selector-class">.ds-avatar</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">27px</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">-webkit-border-radius</span>: <span class="number">27px</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">-moz-border-radius</span>: <span class="number">27px</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 最近访客的头像 */</span></span><br><span class="line"><span class="selector-id">#ds-recent-visitors</span> <span class="selector-class">.ds-avatar</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我比较喜欢简洁扁平化的风格，所以做了上述的更改。小伙伴们具体看那些组件不顺眼，要修改掉，在网页上右键，选择 <code>检查元素</code> 就可以看到相对应的类名和 ID 等等。如果不会 CSS，建议你去 <a href="http://www.w3school.com.cn/css/index.asp" title="CSS 教程 - W3School">CSS 教程 - W3School</a> 简单的学习一下 CSS 的基本知识。</p>
<p>另外我发现 NexT 主题也对多说的 CSS 样式做了些更改，CSS路径 <code>themes\next\source\css\_common\components\third-party\duoshuo.styl</code>，所以如果小伙伴用了其他主题，显示样式可能有点区别。 目前就先改这么多，更多的样式还在开发中，会不定期的更新。如果小伙伴有什么更好的样式，欢迎留言~</p>
<h1 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h1><p><strong>2016-05-28 更新</strong></p>
<h2 id="添加站点最近访客功能"><a href="#添加站点最近访客功能" class="headerlink" title="添加站点最近访客功能"></a>添加站点最近访客功能</h2><p>你只需要在想要显示的地方添加如下代码即可：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ds-recent-visitors&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">data-num-items</span>=<span class="string">&quot;36&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">data-avatar-size</span>=<span class="string">&quot;42&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">&quot;ds-recent-visitors&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>data-num-items：显示的最近访客数量<br>data-avatar-size： 访客头像大小<br>CSS 设置：请参考上面的自定义CSS</p>
<p>当然，前提是你使用了多说评论功能，因为最近访客功能就是由多说提供的。我是直接写在了 <code>about/index.md</code> 文件中。<a href="http://www.cylong.com/about/" title="关于我 - 笑话人生">点此</a> 看看我的访客功能(●’◡’●)</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote>
<p><a href="http://dev.duoshuo.com/docs/" title="多说使用帮助 - 多说开发者中心">多说使用帮助 - 多说开发者中心</a><br><a href="http://dev.duoshuo.com/discussion" title="讨论区 - 多说开发者中心">讨论区 - 多说开发者中心</a><br><a href="http://theme-next.iissnan.com/theme-settings.html" title="主题配置 - NexT 使用文档">主题配置 - NexT 使用文档</a><br><a href="http://theme-next.iissnan.com/third-party-services.html" title="第三方服务集成 - NexT 使用文档">第三方服务集成 - NexT 使用文档</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2016/04/25/hexo-next-duoshuo/' title='Hexo 集成多说评论 + 多说分享 + 美化多说' >Hexo 集成多说评论 + 多说分享 + 美化多说</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2016/04/25/hexo-next-duoshuo/' title='Hexo 集成多说评论 + 多说分享 + 美化多说' >http://www.cylong.com/blog/2016/04/25/hexo-next-duoshuo/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>网站首选域</title>
    <url>/blog/2016/05/02/preferred-domain/</url>
    <content><![CDATA[<hr>
<h1 id="什么是首选域"><a href="#什么是首选域" class="headerlink" title="什么是首选域"></a>什么是首选域</h1><p>当我们在访问一个网站的时候，使用 <a href="http://www.cylong.com/">http://www.cylong.com</a> 和 <a href="http://cylong.com/">http://cylong.com</a> 访问网站，获得的内容并没有区别。对于用户来说，带 www 和不带 www 访问是一样的，但是对于搜索引擎就不一样了，两种域会被视为不同的网页，使得权重分散。Google 解释如下：</p>
<blockquote><p>首选网域是您希望 Google 用来将您的网页编入索引的网域（有时也称为规范网域）。指向您网站的链接可能会同时使用 www 版和非 www 版网址（例如，<a href="http://www.example.com/">http://www.example.com</a> 和 <a href="http://example.com/">http://example.com</a>）。首选域是您希望 Google 用来在搜索结果中显示您网站的版本。</p>
<footer><strong>Search Console帮助</strong><cite><a href="https://support.google.com/webmasters/answer/44231">设置您的首选网域（www 版网址或非 www 版网址）</a></cite></footer></blockquote>

<a id="more"></a>

<h1 id="设置首选域"><a href="#设置首选域" class="headerlink" title="设置首选域"></a>设置首选域</h1><h2 id="使用-Google-Search-Console-设置"><a href="#使用-Google-Search-Console-设置" class="headerlink" title="使用 Google Search Console 设置"></a>使用 Google Search Console 设置</h2><p><b>注意：</b> <em>此方式仅适合 Google</em></p>
<ol>
<li>点击 <a href="https://www.google.com/webmasters/" title="Google 网站站长">Google 网站站长</a>，然后点击首页的 <code>SEARCH CONSOLE</code>。</li>
<li>登陆后，点击想设置首选域的网站（没有网站就添加下）。</li>
<li>点击右上角的齿轮设置图标 <span class="fa fa-cog" aria-hidden="true"></span>，然后点击 <code>网站设置</code>。</li>
<li>选择对应的首选域。</li>
</ol>
<h2 id="使用-301-重定向"><a href="#使用-301-重定向" class="headerlink" title="使用 301 重定向"></a>使用 301 重定向</h2><p>为了使其他搜索引擎和访问者都采用你的首选版本，建议你使用 301 重定向对你的非首选网域的访问重定向到首选网域。在 <code>.htaccess</code> 文件里添加如下代码（要针对托管在运行 Apache 的服务器上的网站实施 301 重定向，你需要有访问权限，日后可能会写什么是 <code>.htaccess</code> 文件，先挖个坑）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RewriteEngine On</span><br><span class="line">RewriteCond %&#123;http_host&#125; ^cylong.com [NC]</span><br><span class="line">RewriteRule ^(.*)$ http:&#x2F;&#x2F;www.cylong.com&#x2F;$1 [L,R&#x3D;301]</span><br></pre></td></tr></table></figure>

<p>使访问 <a href="http://cylong.com/">http://cylong.com</a> 的时候就会自动转到 <a href="http://www.cylong.com/">http://www.cylong.com</a>。</p>
<h2 id="Hexo-博客框架设置首选域"><a href="#Hexo-博客框架设置首选域" class="headerlink" title="Hexo 博客框架设置首选域"></a>Hexo 博客框架设置首选域</h2><p>我的博客是由 <a href="https://hexo.io/zh-cn/" title="Hexo">Hexo</a> 搭建的。没有部署到一个 Apache 服务器上，所以上面的设置方法就没用了。博客源码由 Hexo 生成，部署在 <a href="https://github.com/cylong1016/cylong1016.github.io">Github</a> 上。如何搭建 Hexo 博客请参考：</p>
<blockquote>
<p><a href="http://www.cylong.com/blog/2016/04/19/hexo-git/" title="Hexo + Git 搭建免费的个人博客">Hexo + Git 搭建免费的个人博客</a> 。</p>
</blockquote>
<p>如果你使用的是 GitHub 提供的域名，比如我的是 <a href="http://cylong1016.github.com/">http://cylong1016.github.com</a>。就不需要往下看了，如果你使用的是自己购买的域名，则只需要在 CNAME 中填写你所希望的首选域就可以了，比如我的是:</p>
<figure class="highlight plain"><figcaption><span>CNAME</span></figcaption><table><tr><td class="code"><pre><span class="line">www.cylong.com</span><br></pre></td></tr></table></figure>

<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>当你确定你的首选域之后，在以后的 SEO 工作中，比如友情链接、链接推广时，都要采用你设置的首选域。</p>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2016/05/02/preferred-domain/' title='网站首选域' >网站首选域</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2016/05/02/preferred-domain/' title='网站首选域' >http://www.cylong.com/blog/2016/05/02/preferred-domain/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>apache</tag>
        <tag>seo</tag>
        <tag>htaccess</tag>
        <tag>301重定向</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 使用 cmd(命令提示符)创建文件</title>
    <url>/blog/2016/05/09/windows-linux-new-file/</url>
    <content><![CDATA[<hr>
<p>最近在研究 <a href="http://www.cylong.com/blog/2016/05/19/gitignore/" title=".gitignore 的使用">.gitignore 的使用</a>，于是想创建一个 <code>.gitignore</code> 文件做测试，<code>右键-&gt;新建-&gt;文本文档</code> 再输入文件名后，惊讶的发现，Windows 竟然提示： 请键入文件名！【不得不去吐槽！】。看样子 Windows 是把 gitignore 当成文件名的后缀了。没办法，只好打开 cmd(命令提示符)去创建文件了。</p>
<a id="more"></a>

<h1 id="打开-cmd"><a href="#打开-cmd" class="headerlink" title="打开 cmd"></a>打开 cmd</h1><p>一般有以下方式打开 cmd【<em>我使用的是 Windows 10 系统，某些方法可能没用</em>】：</p>
<ul>
<li>在某个文件夹下按住 <code>Shift</code> 键，然后点击 <code>鼠标右键</code>，选择 <code>在此处打开命令窗口</code>（建议使用此方式，这样你就不用 cd 到指定的文件夹了）。</li>
<li>键盘组合键 <span class="fa fa-windows"></span> + R，然后输入 <code>cmd</code> 并确定。</li>
<li>键盘组合键 <span class="fa fa-windows"></span> + X，然后选择 <code>命令提示符</code>。</li>
<li>键盘组合键 <span class="fa fa-windows"></span> + S，呼出 Cortana，然后输入 cmd 并确认（Windows 10才支持）。</li>
</ul>
<h1 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo hello &gt; .abc</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ol>
<li>“echo hello” ：输出 “hello” 到控制台。</li>
<li>“&gt; .abc” ：输出重定向到 .abc 文件中【没有此文件就会创建】。</li>
<li>当然你也可以使用其他的命令，比如 <code>type</code>，来输出重定向。核心思想就是把某些字符串输出重定向到指定文件里就可以了。</li>
</ol>
<h1 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir .abc</span><br></pre></td></tr></table></figure>

<h1 id="Linux-使用-shell-创建文件"><a href="#Linux-使用-shell-创建文件" class="headerlink" title="Linux 使用 shell 创建文件"></a>Linux 使用 shell 创建文件</h1><p>顺便说一下使用 shell 创建文件吧。上面的那些命令在 shell 中都可以使用，另外说一个在 shell 中更方便的命令。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">touch .abc</span><br></pre></td></tr></table></figure>

<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>写本文的目的是在 Windows 下创建类似 .abc 这样的文件没法使用 <code>右键-&gt;新建</code> 来创建文件。如果你想创建一个 abc.txt 就不要这么麻烦啦【也没人会这么做吧(●’◡’●)】</p>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2016/05/09/windows-linux-new-file/' title='Windows 使用 cmd(命令提示符)创建文件' >Windows 使用 cmd(命令提示符)创建文件</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2016/05/09/windows-linux-new-file/' title='Windows 使用 cmd(命令提示符)创建文件' >http://www.cylong.com/blog/2016/05/09/windows-linux-new-file/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>cmd</tag>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Struts2 参数依赖注入失败</title>
    <url>/blog/2016/05/10/struts2-jsp-param/</url>
    <content><![CDATA[<hr>
<p>这是在 <a href="https://segmentfault.com/" title="SegmentFault">SegmentFault</a> 上看到的一个问题，正好前不久学习了 J2EE 的 SSH 框架，看到这个问题忍不住答了一下。结果问题并不像表面上那么简单。没办法，自己挖的坑，跪着也要填完( ▼-▼ )。原问题链接：</p>
<blockquote>
<p><a href="https://segmentfault.com/q/1010000005088213/a-1020000005088292" title="struct2框架jsp页面传参失败">struct2框架jsp页面传参失败</a></p>
</blockquote>
<a id="more"></a>

<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>和提问者要了源码，方便查找BUG。源代码太长，我就截取了部分代码。</p>
<figure class="highlight html"><figcaption><span>addFlower.jsp</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">s:form</span> <span class="attr">action</span>=<span class="string">&quot;addFlower&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">table</span> <span class="attr">width</span>=<span class="string">&quot;380&quot;</span> &gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">td</span>&gt;</span>鲜花ID：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">s:textfield</span> <span class="attr">id</span>=<span class="string">&quot;goodsId&quot;</span> <span class="attr">name</span>=<span class="string">&quot;goods.goodsId&quot;</span>/&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;添加&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">s:form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><figcaption><span>struts.xml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;flowers&quot;</span> <span class="attr">namespace</span>=<span class="string">&quot;/&quot;</span> <span class="attr">extends</span>=<span class="string">&quot;struts-default&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">&quot;addFlower&quot;</span> <span class="attr">class</span>=<span class="string">&quot;flowers&quot;</span> <span class="attr">method</span>=<span class="string">&quot;addFlowerInfo&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">&quot;index&quot;</span>&gt;</span>/flowerInformation/flowerInformation.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><figcaption><span>applicationContext.xml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;adminUser&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xhydxs.action.AdminUserAction&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;adminUserBiz&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;adminUserBiz&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;flowers&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xhydxs.action.FlowerAction&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;flowerBiz&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;flowerBiz&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><figcaption><span>FlowerAction.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowerAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">RequestAware</span>, <span class="title">SessionAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Goods goods;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Goods <span class="title">getGoods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> goods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGoods</span><span class="params">(Goods goods)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.goods = goods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addFlowerInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;goods:&quot;</span> + goods);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><p>基本上看这些代码是完全正确的啊，并没有什么错误【后来证明确实也没有错误( ╯□╰ )】。拿到项目代码的我运行了下【运行前由于环境不同，我配置了好久啊啊啊啊！】，输出一直是 <code>goods:null</code>。这我就非常奇怪了，和之前写的 J2EE 项目对比了下，套路都是一样的啊！后来我发现了上面的一堆错误信息【为什么不早点看这些错误信息呢】，基本上都是围绕着下面这个错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Caused by: java.lang.IllegalStateException: Cannot convert value of type [com.xhydxs.action.AdminUserAction] to required type [com.xhydxs.entity.AdminUser] for property &#39;adminUser&#39;: no matching editors or conversion strategy found</span><br></pre></td></tr></table></figure>

<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>可以发现是类型转化问题，为什么会让 AdminUserAction 转化成 AdminUser 呢？这两个类怎么会互相转化呢？于是我使用全局查找 AdminUserAction 和 AdminUser 这两个关键词【用 Atom 编辑器】。终于让我发现以下的代码！！！</p>
<figure class="highlight xml"><figcaption><span>applicationContext.xml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;adminUser&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xhydxs.action.AdminUserAction&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;adminUserBiz&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;adminUserBiz&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><figcaption><span>Goods.hbm.xml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">&quot;adminUser&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xhydxs.entity.AdminUser&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">fetch</span>=<span class="string">&quot;select&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">&quot;UPD_OPR&quot;</span> <span class="attr">length</span>=<span class="string">&quot;20&quot;</span> <span class="attr">not-null</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">many-to-one</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>发现了么？name 都是 adminUser，然而 class 分别对应着 AdminUserAction 和 AdminUser。然后把 AdminUserAction 对应的 name 改掉就行了。。。。至于为什么上面这个错误会导致 goods 为 null，因为在 Goods 类里有一个 AdminUser 成员变量，导致 struts 没法构建 goods 这个实例了&gt;3&lt;</p>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2016/05/10/struts2-jsp-param/' title='Struts2 参数依赖注入失败' >Struts2 参数依赖注入失败</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2016/05/10/struts2-jsp-param/' title='Struts2 参数依赖注入失败' >http://www.cylong.com/blog/2016/05/10/struts2-jsp-param/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>ssh</tag>
        <tag>java</tag>
        <tag>jsp</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 10 Metro 应用闪退、无法打开修复方法</title>
    <url>/blog/2016/05/15/windows-10-metro-error/</url>
    <content><![CDATA[<hr>
<p>最近在使用 WindowsModernAppsTools 研究 <a href="http://www.cylong.com/blog/2016/06/07/windows-10-metro-shadowsocks/" title="Windows 10 Metro 应用使用本地 Shadowsocks 代理">Windows Metro 应用翻墙</a> 问题，由于我的手贱删除了些不该删除的东西，导致我的系统中很多 Win 10 应用没法打开了，比如日历、资讯、天气、必应词典等等都打不开了。虽然平时不常用，但是强迫症的我表示没法忍受啊！于是找了很多资料，终于搞定了！</p>
<a id="more"></a>

<p><strong>注意：</strong> 我说的应用都是 Windows 应用商店里的应用。</p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><ol>
<li>键盘组合键 <span class="fa fa-windows"></span> + S，呼出 Cortana，然后输入 PowerShell。在结果中的 PowerShell 上 <code>右键-&gt;以管理员身份运行</code>。</li>
<li>输入以下命令：<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Get-AppXPackage -AllUsers | Foreach &#123;Add-AppxPackage -DisableDevelopmentMode -Register <span class="string">&quot;<span class="subst">$($_.InstallLocation)</span>\AppXManifest.xml&quot;</span>&#125;</span><br></pre></td></tr></table></figure></li>
<li>回车后等待命令执行完毕即可。</li>
<li>以上其实是对应用进行了重置</li>
</ol>
<h1 id="参考资料-amp-感谢"><a href="#参考资料-amp-感谢" class="headerlink" title="参考资料&amp;感谢"></a>参考资料&amp;感谢</h1><blockquote>
<p><a href="http://www.ithome.com/html/win10/166832.htm" title="Win10应用商店、应用打不开或闪退的解决方法 - IT之家">Win10应用商店、应用打不开或闪退的解决方法 - IT之家</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2016/05/15/windows-10-metro-error/' title='Windows 10 Metro 应用闪退、无法打开修复方法' >Windows 10 Metro 应用闪退、无法打开修复方法</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2016/05/15/windows-10-metro-error/' title='Windows 10 Metro 应用闪退、无法打开修复方法' >http://www.cylong.com/blog/2016/05/15/windows-10-metro-error/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 Github Pages 禁止百度爬虫抓取的问题</title>
    <url>/blog/2016/05/22/github-baidu-spider-exception/</url>
    <content><![CDATA[<hr>
<p>最近在研究网站在 Google 和百度的收录问题，Google 收录很轻松，抓取提交下链接就好了，但是百度却花了我好长时间才搞定，这也是为什么这篇博客写的这么晚 ( ╯□╰ )。有关如何能让你的网站被搜索到请参考：</p>
<blockquote>
<p><a href="/blog/2016/05/22/google-baidu-search/" title="如何在 Google 和百度里搜索到自己的网站">如何在 Google 和百度里搜索到自己的网站</a></p>
</blockquote>
<a id="more"></a>

<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>在 <a href="http://zhanzhang.baidu.com/" title="百度站长平台">百度站长平台</a> 上进行抓取诊断的时候，发现一直抓取失败，如图：</p>

<img src="/blog/2016/05/22/github-baidu-spider-exception/exception.png" class="" title="百度爬虫抓取错误">

<p>后来才发现，原来是 Github 禁止百度爬虫抓取，原因是百度的抓取太猛烈，给 Github 的用户造成了可用性问题，而且会一直禁用下去。。。 【我该吐槽 Github 呢？还是百度呢？大家心知肚明就好。（╯－＿－）╯╧╧】</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>我想了想，既然 Github 不让百度抓取，那么我干脆把博客部署到其他地方吧。于是找到了国内的 <a href="https://coding.net/" title="CODING">CODING</a> 【之前可能有很多小伙伴使用的是 <a href="https://gitcafe.com/" title="Gitcafe">Gitcafe</a>，不过已经被 CODING 收购了，2016-05-31 号就会停止服务】。CODING 中也提供和 Github 相同的 Pages 服务。下面是具体步骤：</p>
<ol>
<li>注册登录 <a href="https://coding.net/" title="CODING">CODING</a>。</li>
<li>创建新项目，项目的后缀必须是和你的个性后缀一样。</li>
<li>创建项目的时候你可以选择从 Github 上导入你的博客仓库或者之后自己部署到 CODING 上，如下图：<img src="/blog/2016/05/22/github-baidu-spider-exception/import-from-github.png" class="" title="从 Github 上导入仓库"></li>
<li>进入你的项目，点击左侧的 <code>代码</code>，再选择 <code>Pages 服务</code>，选择 <code>部署分支</code>，默认是 <code>coding-pages</code>，建议换成 <code>master</code> 分支和 Github 保持一致。然后点击 <code>立即开启</code>。</li>
<li>绑定自己的域名，如下图：<img src="/blog/2016/05/22/github-baidu-spider-exception/coding-pages.png" class="" title="Coding Pages"></li>
<li>到你的 DNS 服务商修改你的域名解析记录，这里不需要删除解析到 Github 的记录，像我下面这样配置就可以，这样正常访问还是访问到 Github 上，百度抓取的时候是抓取的 CODING 上的项目。<br>万网 DNS 设置：<img src="/blog/2016/05/22/github-baidu-spider-exception/dns-parse.png" class="" title="DNS 解析记录 - 万网">
DNSPod 设置：<img src="/blog/2016/05/22/github-baidu-spider-exception/dns-parse-dnspod.png" class="" title="DNS 解析记录 - DNSPod">
注意：我的域名在万网购买的，默认使用的是万网的 DNS，设置成百度后开始是好用的，后来就又抓取不到了（╯－＿－）╯╧╧。 于是我就换成了 <a href="https://www.dnspod.cn/" title="DNSPod-免费智能DNS解析服务商">DNSPod</a> 的服务，把线路类型设置成百度、搜索引擎或者国内都可以。如果设置成搜索引擎的话注意 Google 也会去 Coding.net 抓取页面。设置成国内的话，国内的其他用户访问也访问的是 Coding.net 中的页面，相比访问 Github Pages 会更快一点。</li>
</ol>
<h1 id="Hexo-同时部署到-Github-和-Coding"><a href="#Hexo-同时部署到-Github-和-Coding" class="headerlink" title="Hexo 同时部署到 Github 和 Coding"></a>Hexo 同时部署到 Github 和 Coding</h1><p>既然上面的 DNS 分流到了 Github 和 Coding 上，那么我们在部署的时候就要同时维护这两个仓库，好消息是 Hexo 框架支持同时部署到 Github 和 Coding 上，详细介绍请参考：</p>
<blockquote>
<p><a href="/blog/2016/04/25/hexo-faq/#%E9%85%8D%E7%BD%AE-SSH-%E5%85%AC%E9%92%A5%E5%85%8D%E5%8E%BB%E9%83%A8%E7%BD%B2%E7%9A%84%E6%97%B6%E5%80%99%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81" title="配置 SSH 公钥免去部署的时候输入密码">配置 SSH 公钥免去部署的时候输入密码</a></p>
</blockquote>
<h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><blockquote>
<p><a href="http://jerryzou.com/posts/feasibility-of-allowing-baiduSpider-for-Github-Pages/" title="解决 Github Pages 禁止百度爬虫的方法与可行性分析 - 咀嚼之味">解决 Github Pages 禁止百度爬虫的方法与可行性分析 - 咀嚼之味</a><br><a href="http://www.ezlippi.com/blog/2016/02/baidu-spider-forbidden.html" title="解决百度爬虫无法抓取github pages - Lippi-浮生志">解决百度爬虫无法抓取github pages - Lippi-浮生志</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2016/05/22/github-baidu-spider-exception/' title='解决 Github Pages 禁止百度爬虫抓取的问题' >解决 Github Pages 禁止百度爬虫抓取的问题</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2016/05/22/github-baidu-spider-exception/' title='解决 Github Pages 禁止百度爬虫抓取的问题' >http://www.cylong.com/blog/2016/05/22/github-baidu-spider-exception/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>Search</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>hexo</tag>
        <tag>git</tag>
        <tag>seo</tag>
        <tag>爬虫</tag>
        <tag>search</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在 Google 和百度里搜索到自己的网站</title>
    <url>/blog/2016/05/22/google-baidu-search/</url>
    <content><![CDATA[<hr>
<p>搭建完自己的博客或者有一个自己的网站什么的，总想着能在 Google 或者是百度里搜索到吧，这样就可以提高你的网站的知名度，说不定还会结 ♂ 交到志同道合的小伙伴呢 (●’◡’●)。下面就讲解下如何让自己的网站被搜索引擎收录~</p>
<a id="more"></a>

<h1 id="Google-搜索"><a href="#Google-搜索" class="headerlink" title="Google 搜索"></a>Google 搜索</h1><ol>
<li>点击 <a href="https://www.google.com/webmasters/" title="Google 网站站长">Google 网站站长</a>，然后点击首页的 <code>SEARCH CONSOLE</code>。</li>
<li>添加你的网站，进行人机验证【就是证明这个网站是你的】。</li>
<li>进入到 <code>抓取-&gt;Google 抓取方式</code>。</li>
<li>点击 <code>抓取</code> 或者 <code>抓取并呈现</code>。</li>
<li>若提示完成或者部分完成，则可以将网址 <code>提交至索引</code>，有两种提交方式：仅抓取此网址、抓取此网址及其直接链接。都有次数限制。</li>
<li>等待一会，打开 Google，在搜索栏输入 <code>site:www.cylong.com</code>【换成你的域名】，就可以看到你网站的内容了~</li>
</ol>
<img src="/blog/2016/05/22/google-baidu-search/google-search.png" class="" title="Github Google 抓取示例">

<h1 id="百度搜索"><a href="#百度搜索" class="headerlink" title="百度搜索"></a>百度搜索</h1><ol>
<li>点击 <a href="http://zhanzhang.baidu.com/" title="百度站长平台">百度站长平台</a>，登陆。</li>
<li>添加你的网站，进行人机验证。</li>
<li>点击 <code>抓取诊断</code> 判断百度是否能够抓取到你的网站【我的博客部署在 Github 上，结果 Github 禁止百度抓取 ( ╯□╰ )，如何解决请参考：<a href="/blog/2016/05/22/github-baidu-spider-exception/" title="解决 Github Pages 禁止百度爬虫抓取的问题">解决 Github Pages 禁止百度爬虫抓取的问题</a>】</li>
<li>点击 <code>链接提交</code> ，这里有很多种提交方式，各有各的优点，也有详细的说明。自己选择吧【实在不会就直接手动提交】</li>
<li>我使用的是自动提交方式，Hexo 的 NexT 主题已经部署了自动推送的代码，我们只需在主题配置文件中找到 <code>baidu_push</code> 字段 , 设置其为 <code>true</code> 即可。</li>
<li>等待一会，打开百度，在搜索栏输入 <code>site:www.cylong.com</code>【换成你的域名】，就可以看到你网站的内容了~</li>
</ol>
<h1 id="其他的搜索引擎"><a href="#其他的搜索引擎" class="headerlink" title="其他的搜索引擎"></a>其他的搜索引擎</h1><p>其他的搜索引擎我用的也比较少，不过如果你的网站不知道什么时候也会被其收录的，我试了一下，我的博客的首页就被 Bing 收录了，当然你想像上面的那些方法在各个搜索引擎中管理你的网站也是可以的，然而我并没有闲心管那些【我猜测基本都是差不多的】，有兴趣的小伙伴可以自己试一试。</p>
<h1 id="搜索引擎优化-SEO"><a href="#搜索引擎优化-SEO" class="headerlink" title="搜索引擎优化(SEO)"></a>搜索引擎优化(SEO)</h1><blockquote><p>搜索引擎优化（英语：search engine optimization，缩写为SEO），是一种通过了解搜索引擎的运作规则来调整网站，以及提高目的网站在有关搜索引擎内排名的方式。由于不少研究发现，搜索引擎的用户往往只会留意搜索结果最前面的几个条目，所以不少网站都希望通过各种形式来影响搜索引擎的排序，让自己的网站可以有优秀的搜索排名。当中尤以各种依靠广告维生的网站为甚。</p>
<footer><strong>维基百科</strong><cite><a href="https://zh.wikipedia.org/wiki/%E6%90%9C%E5%B0%8B%E5%BC%95%E6%93%8E%E6%9C%80%E4%BD%B3%E5%8C%96">搜索引擎优化</a></cite></footer></blockquote>

<p><strong>注意：</strong> <em>此文章是以 Hexo 搭建的博客为基础，某些插件只支持 Hexo 搭建的博客，如果是其他博客，请寻找支持自己博客的插件或者自己实现。</em></p>
<h2 id="添加-robots-txt"><a href="#添加-robots-txt" class="headerlink" title="添加 robots.txt"></a>添加 robots.txt</h2><p>robots.txt 可以告诉搜索引擎你网站的哪些页面可以被抓取，哪些页面不可以被抓取。将 robots.txt 放置在 source 根目录下。以下是我的 robots.txt：</p>
<figure class="highlight plain"><figcaption><span>robots.txt</span></figcaption><table><tr><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Allow: &#x2F;</span><br><span class="line">Allow: &#x2F;archives&#x2F;</span><br><span class="line"></span><br><span class="line">Disallow: &#x2F;js&#x2F;</span><br><span class="line">Disallow: &#x2F;css&#x2F;</span><br><span class="line">Disallow: &#x2F;fonts&#x2F;</span><br><span class="line">Disallow: &#x2F;lib&#x2F;</span><br><span class="line">Disallow: &#x2F;fancybox&#x2F;</span><br><span class="line"></span><br><span class="line">Sitemap: http:&#x2F;&#x2F;www.cylong.com&#x2F;sitemap.xml</span><br><span class="line">Sitemap: http:&#x2F;&#x2F;www.cylong.com&#x2F;baidusitemap.xml</span><br></pre></td></tr></table></figure>


<h2 id="添加网站地图-Sitemap"><a href="#添加网站地图-Sitemap" class="headerlink" title="添加网站地图(Sitemap)"></a>添加网站地图(Sitemap)</h2><p>Sitemap 上面放置了网站上需要搜索引擎抓取的所有页面的链接，有助于搜索引擎抓取你的网站，清晰了解网站的架构，益于 SEO 优化。</p>
<ol>
<li><p>安装 Hexo 的 sitemap 插件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save       <span class="comment"># 适用于提交给 Google</span></span><br><span class="line">npm install hexo-generator-baidu-sitemap --save <span class="comment"># 适用于提交给百度</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在站点的 <code>_config.yml</code> 添加以下代码：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sitemap:</span><br><span class="line">    path: sitemap.xml</span><br><span class="line">baidusitemap:</span><br><span class="line">    path: baidusitemap.xml</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置成功后，在你执行 <code>hexo -g</code> 的时候，在 public 文件夹【也就是你的站点根目录】就会出现 sitemap.xml 和 baidusitemap.xml。然后在 robots.txt 中添加如下代码：</p>
<figure class="highlight plain"><figcaption><span>robots.txt</span></figcaption><table><tr><td class="code"><pre><span class="line">Sitemap: http:&#x2F;&#x2F;www.cylong.com&#x2F;sitemap.xml</span><br><span class="line">Sitemap: http:&#x2F;&#x2F;www.cylong.com&#x2F;baidusitemap.xml</span><br></pre></td></tr></table></figure>
</li>
<li><p>第三步中搜索引擎在抓取到 robots.txt 的时候会自动抓取站点地图。你还可以手动提交给 Google 和百度，都是带有提示的傻瓜式操作，相信大家都能解决吧(●’◡’●)</p>
</li>
</ol>
<ul>
<li>Google： <a href="https://www.google.com/webmasters/tools/home?hl=zh-CN" title="Search Console">Search Console</a></li>
<li>百度： <a href="http://zhanzhang.baidu.com/" title="百度站长平台">百度站长平台</a></li>
</ul>
<p><strong>2017-04-13 更新</strong></p>
<p>在我向百度提交站点地图 baidusitemap.xml 的时候提示 XML 解析失败，猜测可能是格式有问题，通过查看 <a href="http://zhanzhang.baidu.com/college/courseinfo?id=267&page=2#h2_article_title1" title="百度sitemap协议都支持哪些格式？">百度sitemap协议都支持哪些格式？</a> 发现 Hexo 生成的 baidusitemap.xml 确实有问题，不过百度支持上文中生成的 sitemap.xml 格式的 XML 文档，上传这个就正常了。</p>
<img src="/blog/2016/05/22/google-baidu-search/baidusitemap-error.png" class="" title="XML 解析失败">

<h1 id="一些小点子"><a href="#一些小点子" class="headerlink" title="一些小点子"></a>一些小点子</h1><p>你在你的各大社交网站的个人信息里贴上你的博客域名【比如知乎、Facebook、Twitter、Github 等等】会提高你网站的访问量哟，还有在各大社交网站上回答有关问题可以附上自己的博客地址，也会增加访问量o(^▽^)o。当然，更重要的还是你的博客要内容丰富精彩，才会吸引更多的人。如果是自己的某个网站什么的，多注意下 SEO 优化也是不错的选择。</p>
<h1 id="参考-amp-感谢"><a href="#参考-amp-感谢" class="headerlink" title="参考&amp;感谢"></a>参考&amp;感谢</h1><blockquote>
<p><a href="http://www.yuan-ji.me/Hexo-%E4%BC%98%E5%8C%96%EF%BC%9A%E6%8F%90%E4%BA%A4sitemap%E5%8F%8A%E8%A7%A3%E5%86%B3%E7%99%BE%E5%BA%A6%E7%88%AC%E8%99%AB%E6%8A%93%E5%8F%96-GitHub-Pages-%E9%97%AE%E9%A2%98/" title="Hexo 优化：提交 sitemap 及解决百度爬虫无法抓取 GitHub Pages 链接问题">Hexo 优化：提交 sitemap 及解决百度爬虫无法抓取 GitHub Pages 链接问题</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2016/05/22/google-baidu-search/' title='如何在 Google 和百度里搜索到自己的网站' >如何在 Google 和百度里搜索到自己的网站</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2016/05/22/google-baidu-search/' title='如何在 Google 和百度里搜索到自己的网站' >http://www.cylong.com/blog/2016/05/22/google-baidu-search/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>Search</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>seo</tag>
        <tag>search</tag>
      </tags>
  </entry>
  <entry>
    <title>.gitignore 的使用</title>
    <url>/blog/2016/05/19/gitignore/</url>
    <content><![CDATA[<hr>
<p>当我们在项目开发的时候，常常使用 Git 做版本控制工具。有时候，我们不希望某些文件或者文件夹被 Git 追踪，比如项目产生的中间文件【.class 、 .o】 ，比如某些编辑器的副本文件【一般文件名带有 ~ 符号】，还有一些 log 文件等等。使用命令行的小伙伴可以不使用 <code>git add</code> 把他们加到索引中，不过随即而来的就是一些麻烦事，在你使用 <code>git add .</code> 的时候还是会追踪这些文件。使用 <code>git status</code> 也会显示 <code>Untracked files……</code>。我一直在使用 Github For Windows ，如果没有 .gitignore 文件，每次提交之前也要取消勾选那些不想上传的文件，非常的麻烦。</p>
<a id="more"></a>

<h1 id="创建-gitignore"><a href="#创建-gitignore" class="headerlink" title="创建 .gitignore"></a>创建 .gitignore</h1><p>以上说的那些问题都可以通过一个或者更多的 .gitignore 文件搞定，你可以在项目的任意目录下创建 .gitignore 文件，此文件的影响范围是当前目录和其所有子目录，可以在不同目录创建多个 .gitignore 文件【不过一般都是在项目根目录创建一个就行了】。</p>
<p>需要注意的是 Windows 下直接<code>右键-&gt;新建文本文档</code>，然后键入文件名是没法创建的。。。详情请参考我的另一篇博客【这两篇博客应该是同一天写完的啊！拖延症得治呀( ╯□╰ )】：</p>
<blockquote>
<p><a href="http://www.cylong.com/blog/2016/05/09/windows-linux-new-file/" title="Windows 使用 cmd(命令提示符)创建文件">Windows 使用 cmd(命令提示符)创建文件</a></p>
</blockquote>
<p>你还可以在 Github 上新建一个仓库的同时指定生成特定的 .gitignore 文件，如下图：</p>
<img src="/blog/2016/05/19/gitignore/create-gitignore.png" class="" title="Github 自动创建指定的 .gitignore">

<h1 id="编辑-gitignore"><a href="#编辑-gitignore" class="headerlink" title="编辑 .gitignore"></a>编辑 .gitignore</h1><p>创建好后，我们就可以用任何编辑器打开了，在其中填写你想要忽略的文件的文件名，Git 就会忽略这些文件。例子请往下看：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以&#x27;#&#x27; 开始的行，被视为注释。</span></span><br><span class="line"><span class="comment"># 忽略掉所有文件名是 cylong 的文件和文件夹。</span></span><br><span class="line">cylong</span><br><span class="line"><span class="comment"># 如果只想忽略 cylong 文件夹【不能有上面那段代码】。</span></span><br><span class="line">cylong/</span><br><span class="line"><span class="comment"># 如果只想忽略 doc/ 下面的 cylong 文件【同样不能有上面的 cylong 和 cylong/ 】</span></span><br><span class="line">doc/cylong</span><br><span class="line"><span class="comment"># 忽略所有后缀为 html 文件。</span></span><br><span class="line">*.html</span><br><span class="line"><span class="comment"># about.html 不想被忽略。</span></span><br><span class="line">!about.html</span><br><span class="line"><span class="comment"># 忽略所有后缀为 .o 和 .a文件。</span></span><br><span class="line">*.[oa]</span><br></pre></td></tr></table></figure>

<p>除上面的一些例子以外，[abc]、[0-9]、[a-z]、? 这些正则表达式也是支持的。</p>
<h1 id="使用-Github-的配置文件"><a href="#使用-Github-的配置文件" class="headerlink" title="使用 Github 的配置文件"></a>使用 Github 的配置文件</h1><p>如果只是我们自己写的话，可能并不会写的很全【重要的是比较麻烦是吧！】。还好 Github 已经为我们准备了各种配置文件，我们想要用哪个，就直接拿来用就好了。详情请戳：</p>
<blockquote>
<p><a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a></p>
</blockquote>
<h1 id="删除已经跟踪的文件"><a href="#删除已经跟踪的文件" class="headerlink" title="删除已经跟踪的文件"></a>删除已经跟踪的文件</h1><p>如果文件已经被 Git 跟踪了， 那么这些文件即使被写在了 .gitignore 中，Git 也不会忽略他，还是会继续跟踪，解决办法是输入以下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git rm --cached test.txt <span class="comment"># 如果是文件夹，后面再加上 -r</span></span><br><span class="line">git commit -m <span class="string">&#x27;delete test.txt&#x27;</span></span><br></pre></td></tr></table></figure>

<h1 id="参考资料-amp-感谢"><a href="#参考资料-amp-感谢" class="headerlink" title="参考资料&amp;感谢"></a>参考资料&amp;感谢</h1><blockquote>
<p><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013758404317281e54b6f5375640abbb11e67be4cd49e0000" title="忽略特殊文件 - 廖雪峰的官方网站">忽略特殊文件 - 廖雪峰的官方网站</a><br><a href="https://segmentfault.com/a/1190000000522997" title=".gitignore 文件使用说明 - change2hao">.gitignore 文件使用说明 - change2hao</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2016/05/19/gitignore/' title='.gitignore 的使用' >.gitignore 的使用</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2016/05/19/gitignore/' title='.gitignore 的使用' >http://www.cylong.com/blog/2016/05/19/gitignore/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>gitignore</tag>
      </tags>
  </entry>
  <entry>
    <title>站在 Shadowsocks 的肩膀上发现精彩的世界</title>
    <url>/blog/2016/05/26/shadowsocks/</url>
    <content><![CDATA[<hr>
<p>国内的网络环境我不说相信大家都懂。虽然墙内的世界很丰富，但是墙外的世界还有着更加精彩的内容。这不得不让我想起了曾经看过的一部漫画——进击的巨人。大部分人都在墙内过着安逸的生活，但是总有那么一帮人，想要去墙外探索未知的世界。我就是这样的人！【然后收到了女票的好人卡一张😃】之前因为想要体验 Google 搜索、体验 Youtube、查阅学习资料，还有玩的部分游戏需要翻墙，找了很多免费的代理和 VPN，效果都不好，断断续续的。后来经过舍友的推荐，入了 Shadowsocks 的坑。体验了有两个月左右，效果很棒，访问速度也很快，强烈推荐给大家使用！！！(●’◡’●)</p>
<a id="more"></a>

<h1 id="购买服务"><a href="#购买服务" class="headerlink" title="购买服务"></a>购买服务</h1><ol>
<li>点击进入 <a href="https://portal.shadowsocks.nz/aff.php?aff=8883" title="Shadowsocks">Shadowsocks</a>【此链接是我的推广链接，<strong>因为种种原因，Shadowsocks 官网常常换，所以我的推广链接也会不断更新的，官网链接也以此为准。</strong>你点击后会直接进入首页，通过这个链接购买服务后我也会获得一些好处啦，嘿嘿(^_^)】，进入首页后选择 <code>订购服务</code>。</li>
<li>之后选择你想要购买的服务，点击现在订购。我选择的是 <code>Shadowsocks.com 普通版</code>。需要注意的是，虽然显示的价格是美元，但是在后面支付的时候会自动转化为人民币。<img src="/blog/2016/05/26/shadowsocks/Shadowsocks-basic.png" class="" title="Shadowsocks普通版"></li>
<li>界面上选择你的付款年限，然后点击继续。</li>
<li>在结账页面，你需要填写各种信息，需要认真填写，这也是在创建账号。</li>
<li>Shadowsocks 支持 Alipay 支付宝国际版。之后付款就可以了，现在大约是 104 块钱一年。我买的时候，订购服务时显示的还是人民币，99块钱一年。虽然贵了一点点，不过还是可以接受的。</li>
<li>之后进入 <a href="https://portal.shadowsocks.com/clientarea.php" title="客户中心 - Shadowsocks">客户中心</a>，用第4步创建的账号登陆。</li>
<li>点击产品服务，可以看到你刚刚购买的服务，状态为有效。<img src="/blog/2016/05/26/shadowsocks/my-service.png" class="" title="XML 我的服务"></li>
<li>点击刚刚购买的服务，会看到产品详情。下面有配置文件下载，选择 Windows 版下载。下载下来是 <code>gui-config.json</code>。</li>
</ol>
<h1 id="客户端安装使用"><a href="#客户端安装使用" class="headerlink" title="客户端安装使用"></a>客户端安装使用</h1><p>支持的客户端：OS X， Windows， Linux， iOS， Android， OpenWRT 路由器等。<br>详情请参考：<a href="https://shadowsocks.com/client.html" title="客户端 - Shadowsocks">客户端 - Shadowsocks</a>，客户端都在 Github 上。</p>
<h2 id="Windows-客户端"><a href="#Windows-客户端" class="headerlink" title="Windows 客户端"></a>Windows 客户端</h2><ol>
<li>点击下载 <a href="https://github.com/shadowsocks/shadowsocks-windows/releases/download/3.0/Shadowsocks-3.0.zip" title="Shadowsocks-3.0.zip">Shadowsocks-3.0.zip</a>【写这篇博客时候的最新版本】，或者去 <a href="https://github.com/shadowsocks/shadowsocks-windows/releases" title="Github - Shadowsocks Windows">Github - Shadowsocks Windows</a> 上寻找其他版本。</li>
<li>解压后有一个 <code>Shadowsocks.exe</code> 文件。最好把这个文件放到一个目录下，比如新建一个 Shadowsocks 文件夹。</li>
<li>把刚刚下载的 <code>gui-config.json</code> 文件放到与 <code>Shadowsocks.exe</code> 相同的目录下。</li>
<li>双击 <code>Shadowsocks.exe</code>，会出现一个 GUI 界面，自动读取了 <code>gui-config.json</code> 文件中的内容。<img src="/blog/2016/05/26/shadowsocks/Windows-Shadowsocks-gui.png" class="" title="Windows Shadowsocks 图形界面"></li>
<li>在右下角托盘图标上会有一个好像纸飞机的 Shadowsocks 图标，<code>右键-&gt;启动系统代理</code>，就可以越过墙壁，浏览更多丰富多彩的内容啦~<img src="/blog/2016/05/26/shadowsocks/Shadowsocks-menu.png" class="" title="Shadowsocks 菜单"></li>
<li>另外建议设置成 <code>右键-&gt;开机启动</code>，这样不用每次开机手动启动了。还可以在 <code>右键-&gt;服务器</code> 中选择不同的服务器。</li>
</ol>
<h2 id="Android-客户端"><a href="#Android-客户端" class="headerlink" title="Android 客户端"></a>Android 客户端</h2><ol>
<li>点击下载 <a href="https://github.com/shadowsocks/shadowsocks-android/releases/download/v2.10.3/shadowsocks-nightly-2.10.3.apk" title="shadowsocks-nightly-2.10.3.apk">Shadowsocks-nightly-2.10.3.apk</a>【写这篇博客时候的最新版本】，或者去 <a href="https://github.com/shadowsocks/shadowsocks-android/releases" title="Github - Shadowsocks Android">Github - Shadowsocks Android</a> 上寻找其他版本。</li>
<li>把这个 apk 安装到手机上【可以传到手机里，打开这个 apk 就能安装了】，中文叫影梭。</li>
<li>安装完成后仍然需要配置，支持扫描二维码配置，但是需要下载一个客户端。我不喜欢下太多的客户端，所以就手动配置，具体的值可以用记事本打开 <code>gui-config.json</code> 查看。<img src="/blog/2016/05/26/shadowsocks/Shadowsocks-Android.png" class="" title="Shadowsocks Android"></li>
<li>翻墙后就可以去 Google Play 商店更新 Shadowsocks 了(●’◡’●)</li>
</ol>
<p><strong>2016-09-27 更新</strong></p>
<ol start="5">
<li>目前最新版的 Shadowsocks 已经支持直接扫码配置了，不需要下载额外的客户端。在 Shadowsocks 官网里<code>客户中心--有效产品与服务</code>里就可以找到各个节点的二维码。</li>
</ol>
<h2 id="Linux-客户端"><a href="#Linux-客户端" class="headerlink" title="Linux 客户端"></a>Linux 客户端</h2><p>经历了N天之后,终于在舍友的指导下配置完成了。不得不说，Linux 真是一个让人折腾的系统。不过后来发现，其实还蛮简单的（╯－＿－）╯╧╧</p>
<ol>
<li>首先你需要下载 <a href="http://www.google.cn/chrome/browser/desktop/index.html" title="Chrome 浏览器">Chrome 浏览器</a> 【不需要翻墙】，已经有的小伙伴就不用重新下载了。</li>
<li>使用如下命令安装你下载下来的 Chrome 安装包：<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i xxx-chrome-xxx.deb</span><br></pre></td></tr></table></figure></li>
<li>通过 PPA 源安装 Shadowsocks-qt5，仅支持 Ubuntu 14.04 或更高版本。<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:hzwhuang/ss-qt5</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install shadowsocks-qt5</span><br></pre></td></tr></table></figure></li>
<li>之后就可以在应用列表里搜索到 Shadowsocks-qt5 了<img src="/blog/2016/05/26/shadowsocks/search-shadowsocks.png" class="" title="搜索应用列表"></li>
<li>打开图形化界面，点击 <code>文件 -&gt; 从 gui-config.json 导入链接</code>，接着就会像下图一样。<img src="/blog/2016/05/26/shadowsocks/Shadowsocks-Qt5-GUI.png" class="" title="Shadowsocks-Qt5 图形界面"></li>
<li>上图的 jp01 和 us01 都是后来配置好的，导入 gui-config.json 后还是有些需要自己配置。双击某一条连接，像我如下这样配置【默认有的配置就不要改了】：<img src="/blog/2016/05/26/shadowsocks/config.png" class="" title="连接配置"></li>
<li>配置完成后点击 <code>OK</code>，再点击界面上面的 <code>连接</code>，测试下延迟，看看是否能连接上。可以多配置几个，方便切换~</li>
<li>接下来就是配置 Chrome，让 Chrome 可以使用代理。下载安装 <a href="http://switchysharp.com/install.html" title="SwitchySharp">SwitchySharp</a> 【目前此应用已经更新为 SwitchyOmega，请参考 <a href="/blog/2017/04/09/chrome-SwitchyOmega/" title="Chrome 配置 SwitchyOmega">Chrome 配置 SwitchyOmega</a>】。</li>
<li>打开 Chrome， 点击右上角的 <span class="fa fa-globe" aria-hidden="true"></span> 图标，再点击 <code>选项</code>。<img src="/blog/2016/05/26/shadowsocks/Shadowsocks-icon.png" class="" title="Shadowsocks 图标"></li>
<li>点击 <code>新建情景模式</code>，做如下配置。<img src="/blog/2016/05/26/shadowsocks/SwitchySharp-config.png" class="" title="SwitchySharp 配置"></li>
<li>保存后再点击 <span class="fa fa-globe" aria-hidden="true"></span> 图标就会有你刚刚配置的情景模式，选择后就可以使用 Chrome 浏览器浏览墙外的世界啦~【另外 SwitchySharp 可以升级成 SwitchyOmega 了，有兴趣的小伙伴可以试一试！】</li>
<li>做了上述一系列操作后只有在 Chrome 中可以翻出墙外，至于全局代理我正在研究，过几天会出教程，有会的小伙伴也可以交 ♂ 流下~【此坑算是没时间填了(╯‵□′)╯︵┻━┻】</li>
</ol>
<h2 id="IOS-客户端"><a href="#IOS-客户端" class="headerlink" title="IOS 客户端"></a>IOS 客户端</h2><p>由于本渣没有任何的苹果设备。。。所以自己研究吧，相信聪明的你可以完成的！去 <a href="https://shadowsocks.com/client.html" title="客户端 - Shadowsocks">客户端 - Shadowsocks</a> 可以找到相关的客户端。</p>
<p><strong>2016-09-27 更新</strong></p>
<p>最近也是人品爆表，抽奖抽到了个 IPad mini 2，自然就研究了下如何在 IOS 中试用 Shadowsocks 了。官方推荐的客户端是 <code>shadowrocket</code>。App Store 里卖6块钱。我找到的是 <code>Lifi客户端-Shadowsocks and ShadowsocksR VPN</code>，也是在 App Store 里下载，不过是免费的。两者的配置方式基本一样，都可以扫码配置。在 Shadowsocks 官网里<code>客户中心--我的产品与服务</code>里就可以找到各个节点的二维码。</p>
<ol>
<li><p>Lifi 配置，在应用里选择<code>设置--从二维码导入</code>就会打开扫码界面，之后配置一下代理名称，打开系统 VPN 就可以了，非常简单【我觉得有张图挺好看的，于是强行加了张图(^_^)】。：</p>
<img src="/blog/2016/05/26/shadowsocks/Shadowsocks-IOS.png" class="" title="Shadowsocks IOS">
</li>
<li><p>Shadowrocket 配置，打开应用，点击左上角的扫码图标就可以打开扫码页面：</p>
<img src="/blog/2016/05/26/shadowsocks/Shadowrocket.png" class="" title="Shadowrocket">

</li>
</ol>
<p>看评论说<code>Lifi客户端-Shadowsocks and ShadowsocksR VPN</code>是拿的 Potatso 源码？我也不知道是否真实，有了解的小伙伴欢迎联系我。不过在我一天的试用中发现这个客户端一直掉线，而且舍友 IOS 10 也没法使用，于是我俩都换成了 <code>shadowrocket</code>，IOS 10 可以用，不过也是一直掉线啊，而且有时候还闪退(╯‵□′)╯︵┻━┻！如果用 Shadowrocket 的小伙伴发现QQ聊天的时候没法接收和发送图片，可以在应用的 <code>Settings-Global Routing</code>中选择 Proxy 就好了。大家可以先试一下免费的 Lifi，如果不好用再换成收费的那个 Shadowrocket 吧。有更好的客户端也欢迎在下面讨论。</p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul>
<li>要是偶尔发现网络不稳定，切换线路试一下。</li>
<li>不要同时在多台设备上使用，也不要把配置文件分享给其他人，可能会遭到封号行为。不过手机和 PC 同时使用时没事的。</li>
<li>我遇到一个问题就是启动某些服务器无法下载 Google Play 里的应用，而且有些应用也提示无法在你所在的国家或者地区购买，这个时候就切换下线路，并且清除 Google Play 数据重启就行了。</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote>
<p><a href="https://github.com/shadowsocks/shadowsocks-qt5/wiki" title="中文文档 - Shadowsocks-qt5">中文文档 - Shadowsocks-qt5</a><br><a href="blog/2017/04/09/chrome-SwitchyOmega/" title="Chrome 配置 SwitchyOmega - 笑话人生">Chrome 配置 SwitchyOmega - 笑话人生</a> 【Shadowsocks 配合 SwitchyOmega 使用有奇效，建议尝试下(●’◡’●)】</p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2016/05/26/shadowsocks/' title='站在 Shadowsocks 的肩膀上发现精彩的世界' >站在 Shadowsocks 的肩膀上发现精彩的世界</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2016/05/26/shadowsocks/' title='站在 Shadowsocks 的肩膀上发现精彩的世界' >http://www.cylong.com/blog/2016/05/26/shadowsocks/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>Shadowsocks</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>windows</tag>
        <tag>linux</tag>
        <tag>shadowsocks</tag>
        <tag>android</tag>
        <tag>翻墙</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 10 Metro 应用使用本地 Shadowsocks 代理</title>
    <url>/blog/2016/06/07/windows-10-metro-shadowsocks/</url>
    <content><![CDATA[<hr>
<p>Windows 8/10 的应用是不允许访问 localhost(127.0.0.1)，所以你配置了 Shadowsocks 代理，Windows 10 应用也无法翻墙， 因为Shadowsocks 的代理地址正好是 localhost(127.0.0.1)。这个时候我们就需要祭出 Windows 10 自带的程序：CheckNetIsolation。通过这个程序，你可以设置排除哪个应用的限制，使其可以翻墙。</p>
<a id="more"></a>

<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><ol>
<li><p>寻找应用的 SID：键盘组合键 <span class="fa fa-windows"></span> + R，然后输入 <code>regedit</code>，打开注册表管理器，找到以下注册表项：<br>HKEY_CURRENT_USER\Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppContainer\Mappings<br>在其中找到你想要使用代理的应用，DisplayName 就是应用名，左边的项就是 SID。比如我找的是 Twitter。如下图：</p>
<img src="/blog/2016/06/07/windows-10-metro-shadowsocks/regedit_sid.png" class="" title="注册表项示例">
<p>【PS： 你可以鼠标放在 SID 上右键-&gt;重命名，然后就可以复制整个 SID 了】</p>
</li>
<li><p>键盘组合键 <span class="fa fa-windows"></span> + X，然后按 A【命令提示符（管理员）】，打开终端后输入：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">CheckNetIsolation loopbackexempt -a -p=SID <span class="comment"># 上一步你复制的 SID</span></span><br></pre></td></tr></table></figure>
<p>回车后就大功告成了。</p>
</li>
<li><p>打开 Twitter 试一下</p>
<img src="/blog/2016/06/07/windows-10-metro-shadowsocks/twitter.png" class="" title="Twitter 翻墙成功">

</li>
</ol>
<h1 id="CheckNetIsolation-参数"><a href="#CheckNetIsolation-参数" class="headerlink" title="CheckNetIsolation 参数"></a>CheckNetIsolation 参数</h1><ul>
<li>CheckNetIsolation.exe loopbackexempt -a -p=SID 添加指定程序到列表</li>
<li>CheckNetIsolation.exe loopbackexempt -d -p=SID 从列表删除指定程序</li>
<li>CheckNetIsolation.exe loopbackexempt -s 列出环回免除的应用列表</li>
</ul>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul>
<li><p>有些小伙伴可能会使用 WindowsModernAppsTools 来使 Windows 10 应用翻墙，这个软件也是使用了 CheckNetIsolation，另外最好不要随便动 Windows 10 应用的数据，说不定不小心删除了什么就导致应用崩溃了，切记切记。前车之鉴请参考：</p>
<blockquote>
<p><a href="http://www.cylong.com/blog/2016/05/15/windows-10-metro-error/" title="Windows 10 Metro 应用闪退、无法打开修复方法">Windows 10 Metro 应用闪退、无法打开修复方法</a></p>
</blockquote>
</li>
<li><p>Facebook 的 Windows 10 应用没法翻墙。我找了很多资料，大家的讨论也是只有 Facebook 没法翻墙，其他的都可以。有知道原因并能解决的小伙伴欢迎 <a href="http://www.cylong.com/about/#%E8%81%94%E7%B3%BB%E6%88%91" title="骚扰我">骚扰我</a> 或者在下面留言 (●’◡’●)</p>
</li>
<li><p>即使都是 Twitter 应用，但是不同的电脑 SID 可能不同。</p>
</li>
</ul>
<h1 id="参考-amp-感谢"><a href="#参考-amp-感谢" class="headerlink" title="参考&amp;感谢"></a>参考&amp;感谢</h1><blockquote>
<p><a href="https://plus.google.com/u/0/107096807950211631844/posts/CdTT2becCRm" title="Microsoft Edge 浏览器用上 shadowsocks 代理翻墙方法">Microsoft Edge 浏览器用上 shadowsocks 代理翻墙方法</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2016/06/07/windows-10-metro-shadowsocks/' title='Windows 10 Metro 应用使用本地 Shadowsocks 代理' >Windows 10 Metro 应用使用本地 Shadowsocks 代理</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2016/06/07/windows-10-metro-shadowsocks/' title='Windows 10 Metro 应用使用本地 Shadowsocks 代理' >http://www.cylong.com/blog/2016/06/07/windows-10-metro-shadowsocks/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>shadowsocks</tag>
        <tag>翻墙</tag>
      </tags>
  </entry>
  <entry>
    <title>稳耐风波愿始从</title>
    <url>/blog/2016/06/09/iverson/</url>
    <content><![CDATA[<hr>
<p>夕阳西下。<br>我看着AI坐在斯台普斯客队替补席上，呆呆望着场内发生的一切。他看着科比在他面前超越了他领先十三年的得分，听着为24号的喝彩，再看着记分牌上一点点被拉大的分数，他只是呆坐，眼神迷茫，无动于衷，仿佛自己来自另一个世界。惨败，又是惨败，第三次惨败。哨声响起，他低着头，快步走出球员通道。我看得到他的背影看不到他的落寞。<br>怎么能低头离开斯台普斯？就在一年前他还是昂首走出去。八年前他只手遮天，梦想就断裂在这金黄的球馆，唯一一次六月的征战，旧队友，老照片，八年的风霜，未改的容颜，怎敢遗忘那些瞬间？最震耳欲聋的欢呼，让洛杉矶的轻歌曼舞画上一道休止符，晃倒泰龙卢，最骄傲的迈步，是谁再说，他踏上的是一条荆棘密布，无人可能成功的路？<br>只是，八年了，我们早已认不出那块泰龙卢摔倒的地板。<br>物是人非。<br>隔了个半个地球，有人在心痛。</p>
<a id="more"></a>

<p>隔了半个美国，也会有人难过吗？<br>流年，剪影，十年。<br>费城，1996，状元，三号，金链子，狐朋狗友，唱片，嘘声，对神的挑战，拉里布朗，训练，爱恨交错，忠诚，2001，洛杉矶，MVP，得分王……<br>时间，路途，前进的光，没有回望。<br>以为会与费城到地老天荒，只是寥寥的胜场，深深的惆怅，时光在云顶嘹亮地唱，分别的波澜轻轻地荡，刻不下的时光，注定一人去流浪。<br>再见了，我爱的费城；<br>再见了，我们爱的AI。<br>断肠人去天涯。<br>天涯远吗？不远，他在天涯，天涯怎么会远！</p>
<p>谁道飘零不可怜，断肠人去自经年。<br>那个精灵飞翔的故事还在上演，只是不再属于瓦乔维亚球馆。只是那个夜晚，是个例外——<br>那个夜晚很美，他们的欢呼他们的笑，他们的拥抱他们记得他的好。他的亲吻他的奔跑，他微微润湿的双眼，告诉我们他同样忘不掉。<br>WELCOME BACK, AI，THANKS FOR TEN GREAT YEARS OF HEART&amp;SOUL.<br>轻轻把手放在耳边，绕场慢慢的跑，聆听。<br>还记得吗？费城的欢呼是世界上最美妙的音乐。<br>俯身，深深的亲吻。<br>WE MISS YOU,AI.<br>费城的天空，我们想你时，它落泪了。<br>风雨中，陪你走，不要相忘于江湖。<br>可，踏上回丹佛的飞机，便是陌路。<br>天咫尺，人南北。</p>
<p>叹人生，几番离合，便成迟暮。<br>三年了，沧海桑田，人事变迁，谁会相信什么永远。<br>当他终于回到家，发现一切都变了样，是熟悉的让人陌生？还是恍如隔世陌生的让人难过？<br>曾经的一代枭雄，走到穷途末路，不甘就此推出，于是来场豪赌，一次搭上全部，输了就退出江湖。<br>感谢我爱的费城——他的退役宣言里这样说。<br>终于等到了费城的橄榄枝。<br>我们爱的AI，请回家。<br>有一种答案叫落叶归根。<br>俯身，深深的亲吻，第二次。<br>弧线不同了是吗，可那份情意此生不变。<br>谁谓我生，我思议如风，历历人生。</p>
<p>莫回首斜阳下，诉不尽离人话。<br>当费城故事确定未完待续时，我高兴的快要疯掉，你没有去湖人，谁在乎什么总冠军？我只要你幸福。<br>有些泪水是坚硬的，它从英雄的脸上滑过，但与懦弱无关。<br>AI说，那是看到家门后的鼻酸反应。<br>多好！爱费城的AI又回到了爱AI的费城。<br>从此无关胜负，誓死守护。<br>陪君醉笑三万场，不用诉离殇。</p>
<p>落魄江湖还载酒，一种悲凉滋味。<br>当两个费城之子相遇在费城——他出生成长的地方，他扬名立万的地方。他们早已不如十三年前那般锋芒毕露。久经沙场，看惯人世冷暖，他们，已不再年轻。<br>只是他正如日中天，他似乎已日薄西山。<br>有悬念吗？有奇迹吗？有人相信吗？<br>似乎费城倒戈喊几声MVP也是正常的。<br>只是他摇头，说不。<br>那美妙的第三节，十五分，已无需我赘述。<br>兄弟友爱之城的尊严，从来都要他来维护。<br>没有悬念，没有奇迹，剧本已写好，不会改变，我们输了，只是，我们开始相信：<br>弯弓射日，看我卷土重来。</p>
<p>谁谓我悲，意如花信，瞳清若水。<br>我从未想过有一天还会看到阿伦艾弗森穿上那件印有SIXER的球衣——那件神圣的为曾有旁人触动过的球衣，自始至终只属于一个人的球衣。<br>我看着你在费城，看着你与费城荣辱与共，休戚相关，还你那份倔强，许你那份坚强。享受你的每一场胜利与失败——我也不清楚这样的日子还会有多久，如果费城真的是你的最后一站，我们陪你走完，直到你离开你最爱的篮球场，直到那件三号球衣在瓦乔维亚上空飘扬。</p>
<p>任往事随风，他们自随波逐流，自始至终，稳耐风波愿始从。</p>
<hr>
<p>这篇文章是我女票大概在2009年【那个时候她真是青涩又可爱(/▽＼=)】写在百度空间里的，但是百度空间在15年就关闭了。然后我就要来发到自己的博客里，作为一种回忆 o(^▽^)o【<del>还是自己的网站靠谱~</del>】</p>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2016/06/09/iverson/' title='稳耐风波愿始从' >稳耐风波愿始从</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2016/06/09/iverson/' title='稳耐风波愿始从' >http://www.cylong.com/blog/2016/06/09/iverson/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>艾已成诗</category>
      </categories>
      <tags>
        <tag>艾弗森</tag>
        <tag>艾已成诗</tag>
        <tag>篮球</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Eclipse 根据 WSDL 生成 Java 代码</title>
    <url>/blog/2016/07/01/wsdl-to-java/</url>
    <content><![CDATA[<hr>
<p>这学期的 SOA 课程已经结束了，但是我为什么感觉什么都没有学到呢！！反正学到什么就整理下好了！这次是使用 Eclipse 根据 WSDL 生成 Java 代码。整个过程都是自动的，完全是傻瓜式的！</p>
<a id="more"></a>

<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul>
<li>WSDL 地址【自己可以发布，如何发布我会在日后写，先挖个坑<del>一定要填上</del>】</li>
<li><a href="http://www.eclipse.org/downloads/eclipse-packages/" title="Eclipse IDE for Java EE Developers">Eclipse IDE for Java EE Developers</a></li>
</ul>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol>
<li>打开 Eclipse，<code>File -&gt; New -&gt; Dynamic Web Project</code></li>
<li>右键刚刚新建的项目，<code>New -&gt; Other -&gt; Web Services -&gt; Web Service Client</code></li>
<li>在 Service definition 输入 WSDL 的地址，之后点 <code>Next</code> 或者 <code>Finish</code> 即可</li>
<li>会生成类似下面这样的代码结构<img src="/blog/2016/07/01/wsdl-to-java/wsdl-to-java.png" class="" title="WSDL to Java"></li>
<li>其中 xxxProxy.java 中就有服务提供的接口方法，直接调用就行了。</li>
</ol>
<h1 id="参考-amp-感谢"><a href="#参考-amp-感谢" class="headerlink" title="参考&amp;感谢"></a>参考&amp;感谢</h1><blockquote>
<p><a href="http://andybang1981.blog.163.com/blog/static/177927368201426001589/" title="使用Eclipse生成Web Service Client - andybang1981的日志">使用Eclipse生成Web Service Client - andybang1981的日志</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2016/07/01/wsdl-to-java/' title='使用 Eclipse 根据 WSDL 生成 Java 代码' >使用 Eclipse 根据 WSDL 生成 Java 代码</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2016/07/01/wsdl-to-java/' title='使用 Eclipse 根据 WSDL 生成 Java 代码' >http://www.cylong.com/blog/2016/07/01/wsdl-to-java/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>wsdl</tag>
        <tag>web service client</tag>
        <tag>eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title>集中式和分布式版本控制学习整理</title>
    <url>/blog/2016/09/26/git-svn/</url>
    <content><![CDATA[<hr>
<p>在面试的时候被问到平时喜欢用 Git 还是 SVN，他们之间的区别是什么？这自然就谈到了分布式和集中式的区别。作为一个学生党，免费的 Github 给我提供了很大的便利，我的所有项目都是放在 Github 上，毕竟 Github 还是一个全球最大的同性交友网站 ╮(╯▽╰)╭。下面就说说集中式和分布式版本控制的区别。</p>
<a id="more"></a>

<h1 id="为什么使用版本控制"><a href="#为什么使用版本控制" class="headerlink" title="为什么使用版本控制"></a>为什么使用版本控制</h1><p>在我们平时的开发过程中，大部分情况下是团队开发，即使是个人开发，我们也想对整个项目进行代码管理与备份等等。每次复制一份达成压缩包分类命名这样的肯定不是一个河里的解决办法，这只会让我们的磁盘空间越来越小，备份版本越来越多。在团队开发的时候，对代码进行合并管理的时候，总需要一些工具可以自动合并，版本控制系统应运而生。运用版本控制系统，我们可以对代码进行版本管理，可以随时查看之前版本的内容，随时回溯到之前版本中。团队合作的时候也可以自动合并代码，而不需要用一个共享文件，或者是进行定期的备份。</p>
<h1 id="集中式和分布式"><a href="#集中式和分布式" class="headerlink" title="集中式和分布式"></a>集中式和分布式</h1><p>版本控制系统也分为两类，集中式和分布式版本控制，我们所熟知的 Git 是分布式，SVN 是集中式，下面说说两者的区别。</p>
<h2 id="集中式"><a href="#集中式" class="headerlink" title="集中式"></a>集中式</h2><p>集中式版本控制系统有一个中央服务器，每个人在工作的时候都需要从中央服务器获取最新版本，修改后提交到中央服务器。其他人再获取最新代码进行更改。这种方式的缺点就是，我们必须有一个中央服务器，由于网络原因没法连接到服务器，或者服务器宕机，我们就没法进行数据获取和提交。而且由于是联网操作，网络环境也会影响到提交和下载速度。</p>
<img src="/blog/2016/09/26/git-svn/%E9%9B%86%E4%B8%AD%E5%BC%8F.jpg" class="" title="集中式">

<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><p>那么分布式版本控制系统是如何解决这些问题的呢？首先，分布式版本控制系统没有所谓的中央服务器，每个站点【就是自己用来开发的电脑】都有一个完整的版本库，我们可以在本地进行修改提交。这样在没有网络的环境下也可以进行开发。当需要进行代码合并的时候，我们只要把自己的版本库推送给你的合作伙伴就可以了，这样他就可以看到你做的更改。同时，他也可以把他的版本库推送给你，这样你就可以看到他的修改了。由于每个人电脑里都是一个完整的版本库，所以自己不小心丢失数据的话，从其他地方里拷贝一份就可以了。不过平时开发中，我们不会用这样笨拙的方式来互相推送代码。毕竟每个人的电脑不是24小时开机，总不能打个电话给他说：我要推送代码给你啦！(╯‵□′)╯︵┻━┻因此，Github 就起到了一个“中央服务器”的作用。我们把代码提交到 Github 上，任何人都可以随时下载合并代码，给我们提供了很多便利。</p>
<img src="/blog/2016/09/26/git-svn/%E5%88%86%E5%B8%83%E5%BC%8F.jpg" class="" title="分布式">

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>看完以上的介绍，很多人可能会比较模糊，我们在开发的过程中不是总需要一个中央服务器嘛？感觉上平时使用 Git 或者 SVN 操作都是一样的啊！出现这种混淆是因为我们平时开发的时候总是有一个中央服务器，总是再联网状态下。首先说明，Git 不需要一个中央服务器，我们平时使用 Github 是为了让我们的团队开发更便利，如果你不嫌麻烦，完全可以不用中央服务器。而 SVN 是必须使用一个中央服务器，而且如果没法联网或者服务器宕机，所有人都没法工作。其次，Git 是可以在断网状态下提交，因为每个人的电脑里都是一个完整的代码仓库，包含提交历史等等。而 SVN 在断网的时候是没法提交的，也没法查看历史记录。当然，Git 优于 SVN 的不仅有上面的这些，还有很多强大的功能优于 SVN。比如强大的分支功能，Git 做一个小小的标记就会产生一个分支。而 SVN 是复制一份代码到分支目录。Git 还可以进行本地回滚【因为自己电脑里也是一个完整的版本库，但是提交到中央服务器上的时候可以减少冗余版本】</p>
<h1 id="参考-amp-感谢"><a href="#参考-amp-感谢" class="headerlink" title="参考&amp;感谢"></a>参考&amp;感谢</h1><p>以上这些知识都是参考下面这些连接里的内容，本意是我自己的学习笔记，特此对其进行感谢。</p>
<blockquote>
<p><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001374027586935cf69c53637d8458c9aec27dd546a6cd6000" title="集中式vs分布式 - 廖雪峰的官方网站">集中式vs分布式 - 廖雪峰的官方网站</a><br><a href="https://www.zhihu.com/question/20093241" title="如何理解 Git 的分布式？ - 知乎">如何理解 Git 的分布式？ - 知乎</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2016/09/26/git-svn/' title='集中式和分布式版本控制学习整理' >集中式和分布式版本控制学习整理</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2016/09/26/git-svn/' title='集中式和分布式版本控制学习整理' >http://www.cylong.com/blog/2016/09/26/git-svn/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>版本控制</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>svn</tag>
        <tag>分布式版本控制</tag>
        <tag>集中式版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title>笑话人生，才刚刚开始</title>
    <url>/blog/2016/10/20/my-life-is-just-beginning/</url>
    <content><![CDATA[<hr>
<p>很多人的人生都有三个重大的转折点，第一是中考，第二是高考，第三是大学毕业。我很庆幸在这三个转折点，我都选择了或者有幸得到了自己心仪的结果，虽然有自己努力的结果，但不乏有很多幸运的元素。中考高考分别都是自己在初中和高中所有考试中发挥最好的一次，也许总有那种一到关键时候就超长发挥的光环。但我坚信，努力就会有好的结果。</p>
<a id="more"></a>

<p>即将面临毕业的我也是很纠结的，在考研和工作中二选一，最后决定脚踏两条船，还好没有翻船。从9月份开始不断的投递各个公司，陆陆续续投了接近20家。不断的参加宣讲笔试面试、参加宣讲笔试面试……有成功也有失败，两个月的时光转瞬即逝，不得不说，找工作真是一件头疼的事情【其实考研更让我头疼啊！(╯‵□′)╯︵┻━┻】。</p>
<p>…………【此处省略10000字，最后确定下来再填坑】</p>
<p>这两个月完全是在煎熬，找工作的焦急导致心情跌落到了低谷，有一段时间甚至什么都不想干，就坐在那发呆。最后终于在收到某 Offer 后，跌落到低谷的心情瞬间上升到了天堂，一切都放松了下来，可以安心的做一些其他事情了呢~~我相信我的人生才刚刚开始，后面会有更大的挑战在等着我，加油！Fighting！【怎么中二起来了啊！而且文笔也不好啊！(╯‵□′)╯︵┻━┻另外我只想记录下这一天啊！但是又不知道说什么好啊！】</p>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2016/10/20/my-life-is-just-beginning/' title='笑话人生，才刚刚开始' >笑话人生，才刚刚开始</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2016/10/20/my-life-is-just-beginning/' title='笑话人生，才刚刚开始' >http://www.cylong.com/blog/2016/10/20/my-life-is-just-beginning/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>找出有序数组中 3 个和为 0 的数</title>
    <url>/blog/2016/11/08/three-number/</url>
    <content><![CDATA[<p>前几天偶尔看到一道题，感觉蛮有意思的，在自己思考，外加上网查询之后，找到了一个比较完美的算法解决。问题描述如下：</p>
<blockquote>
<p> 给定有序排列的N个整数，找出其中3个数相加和为0，输出所有的不重复的3个数，要求输出的结果依然有序。<br> 在单行内，输出的顺序和原来一致，每行之间的顺序和第一个数字在原数列中的顺序一致（如果相同则向后依次比较）<br> INPUT :<br> 5<br> -2 -1 0 1 2<br> OUTPUT:<br> -2 0 2<br> -1 0 1<br> INPUT :<br> 5<br> 2 2 0 -2 -4<br> OUTPUT:<br> 2 2 -4<br> 2 0 -2</p>
</blockquote>
<a id="more"></a>

<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>首先思考：寻找有序数组（下文说的数组均是升序排列的）中两个和为 k 的值。很简单，两个指针 i 和 j 分别指向数组两端，计算两数的和，大于 k 则 <code>j--</code>，否则 <code>i++</code>，直到寻找到两个数和为 k 或者 <code>i &gt; j</code> 时停止。</p>
</li>
<li><p>上题中可以转换为寻找数组中两个和为 -k 的数，k 为数组中的元素，我们只需要再加一层循环，遍历数组中的值，作为 k 就可以了。</p>
</li>
<li><p>那么如何解决结果中有重复值的情况呢？比如我们输入 [-4, -2, 0, 2, 2] 这5个数，会输出两次 [-2, 0, 2]。其实这个也很好判断，当我们确定了三个数中的一个数，那么后面求出的两个数就确定下来了，比如我们确定”第一个数”是 -5，那么可能求出后面两个数是 [2, 3] 和 [1, 4]，当我们循环到下一个”第一个数”的时候，如果还是 -5，那求出的数据肯定还是重复的，所以直接跳过就好。【这块的描述好像不是很清楚啊！(╯‵□′)╯︵┻━┻ 不明白的话看下面的代码肯定一下子就明白了呢！】</p>
</li>
</ol>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">findThreeNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr, <span class="keyword">bool</span> asc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;    <span class="comment">// 保存结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++) &#123;    <span class="comment">// 保证&quot;第一个数&quot;在数组中</span></span><br><span class="line">        <span class="keyword">int</span> m = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">size</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (m &lt; n) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = arr[m] + arr[n];    <span class="comment">// 另外两个数的和</span></span><br><span class="line">            <span class="keyword">if</span> (sum + arr[i]  &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                asc ? n-- : m++;    <span class="comment">// 升序和降序的操作不一样</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum + arr[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                asc ? m++ : n--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;    <span class="comment">// 找到三数和为0</span></span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(<span class="number">3</span>);</span><br><span class="line">                v[<span class="number">0</span>] = arr[i];</span><br><span class="line">                v[<span class="number">1</span>] = arr[m];</span><br><span class="line">                v[<span class="number">2</span>] = arr[n];</span><br><span class="line">                result.push_back(v);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// &quot;第二个数&quot;和&quot;第三个数&quot;分别判断其下个数是否重复</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    m++;</span><br><span class="line">                &#125; <span class="keyword">while</span> (m &lt; n &amp;&amp; arr[m - <span class="number">1</span>] == arr[m]);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    n--;</span><br><span class="line">                &#125; <span class="keyword">while</span> (m &lt; n &amp;&amp; arr[n + <span class="number">1</span>] == arr[n]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 外层循环&quot;第一个数&quot;，如果下一个&quot;第一个数&quot;相同，则为重复数据</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="built_in">size</span> - <span class="number">2</span> &amp;&amp; arr[i + <span class="number">1</span>] == arr[i]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> asc = <span class="literal">true</span>;    <span class="comment">// 升序</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; arr[i] &lt; arr[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            asc = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result = findThreeNumber(arr, asc);</span><br><span class="line">    <span class="function"><span class="keyword">for</span> <span class="title">each</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v in result)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2016/11/08/three-number/' title='找出有序数组中 3 个和为 0 的数' >找出有序数组中 3 个和为 0 的数</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2016/11/08/three-number/' title='找出有序数组中 3 个和为 0 的数' >http://www.cylong.com/blog/2016/11/08/three-number/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 集成 Disqus 评论</title>
    <url>/blog/2017/03/26/hexo-next-disqus/</url>
    <content><![CDATA[<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从创建博客的时候我就纠结用国内的多说还是国外的 Disqus，鉴于多说是国内的，是中文的，而且相比国内其他的系统更加稳定，功能多样，毅然选择了多说。不过后来多说经常崩溃，总是看不到评论，一直想换成 Disqus 或者国内其他的评论系统。这次好了，不用纠结了，用了一年的多说即将在<a href="http://dev.duoshuo.com/threads/58d1169ae293b89a20c57241" title="重要通知: 多说即将关闭">2017年6月1日关闭服务</a>，不得不换一个。在我刚开始使用 NexT 主题的时候，只支持多说和 Disqus，目前已经支持了很多，可以参考：</p>
<blockquote>
<p><a href="http://theme-next.iissnan.com/third-party-services.html" title="Next 第三方服务集成">NexT 第三方服务集成</a></p>
</blockquote>
<p>我后来还是选择了 Disqus 作为新的评论系统，虽然 Disqus 在国内有时候被墙掉了，英文读起来也比较费劲，但是强大的功能和用户体验让我对 Disqus 爱不释手。至于国内也有很多评论系统可以代替多说，但是根据先前的一些系统来看，最后都没有走下去呢╮(╯▽╰)╭。 我觉得 Disqus 不会半路 GG 吧 (╯‵□′)╯︵┻━┻</p>
<a id="more"></a>

<h1 id="NexT-主题集成-Disqus"><a href="#NexT-主题集成-Disqus" class="headerlink" title="NexT 主题集成 Disqus"></a>NexT 主题集成 Disqus</h1><ol>
<li>登陆 <a href="https://disqus.com/" title="Disqus">Disqus</a>，点击 <code>GET STARTED</code> 开始创建站点，之后就可以点击右上角的 <code>Admin</code> 进入后台管理。<img src="/blog/2017/03/26/hexo-next-disqus/disqus_index.png" class="" title="Disqus 创建站点"></li>
<li>点击第二条 <code>I want to install Disqus on my site</code>。<img src="/blog/2017/03/26/hexo-next-disqus/disqus_intent.png" class=""></li>
<li>按照表单填写信息，记住 <code>Website Name</code> 这条属性。<img src="/blog/2017/03/26/hexo-next-disqus/disqus_create.png" class=""></li>
<li>接下来按照指引填写信息，完成第三步 <code>3.Configure Disqus</code> 后点击最下面 <code>Complete Setup</code> 完成创建。【中间会有一个嵌入代码的案例，不是 NexT 主题的可以参考下】<img src="/blog/2017/03/26/hexo-next-disqus/disqus_settings.png" class=""></li>
<li>接下来配置主题下面的 <code>config.yml</code> 文件。<blockquote>
<p>大于等于5.1.1版本，将 disqus 下的 enable 设定为 true，同时提供您的 shortname。 count 用于指定是否显示评论数量。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">disqus:</span><br><span class="line">  enable: true</span><br><span class="line">  shortname:</span><br><span class="line">  count: true</span><br></pre></td></tr></table></figure>
<blockquote>
<p>小于5.1.1 版本，设定 disqus_shortname 的值即可。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">disqus_shortname: shortname</span><br></pre></td></tr></table></figure></li>
<li>接下来就可以进入后台管理设置你的评论了。</li>
</ol>
<h1 id="多说评论迁移至-Disqus"><a href="#多说评论迁移至-Disqus" class="headerlink" title="多说评论迁移至 Disqus"></a>多说评论迁移至 Disqus</h1><p>毕竟多说我也用了一年，积攒了一点评论，就这样放弃非常的舍不得，不过多说导出的评论文件无法直接导入到 Disqus 中，多说导出的是 JSON 文件，Disqus 支持的导入格式是 WordPress 导出的的 XML 文件。在网上找了一些，发现都不好用，于是自己就造了一个轮子，在下面的链接中有详细的说明。欢迎使用并提出宝贵的意见(●’◡’●)</p>
<blockquote>
<p><a href="/blog/2017/04/05/duoshuo-to-disqus/" title="多说评论迁移至 Disqus">多说评论迁移至 Disqus</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2017/03/26/hexo-next-disqus/' title='Hexo 集成 Disqus 评论' >Hexo 集成 Disqus 评论</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2017/03/26/hexo-next-disqus/' title='Hexo 集成 Disqus 评论' >http://www.cylong.com/blog/2017/03/26/hexo-next-disqus/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>Jackson - Java Object 与 JSON 之间的转化工具</title>
    <url>/blog/2017/03/31/jackson-java-json/</url>
    <content><![CDATA[<hr>
<p>一直在找一个 Java Object 与 JSON 之间方便快捷的转化工具，在舍友的推荐下了解到了 Jackson，使用之后对其爱不释手，现在推荐给大家。</p>
<h1 id="JSON-简介"><a href="#JSON-简介" class="headerlink" title="JSON 简介"></a>JSON 简介</h1><blockquote><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。 易于人阅读和编写。同时也易于机器解析和生成。 它基于JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。 这些特性使JSON成为理想的数据交换语言。</p>
<footer><strong>JSON 中文</strong><cite><a href="http://www.json.org/json-zh.html">介绍 JSON</a></cite></footer></blockquote>

<p>以上链接中包含了 JSON 的详细介绍，其实 JSON 对象【”名称/值”对的集合】和 Java 对象是对应的，JSON 数组【值的有序列表】和 Java 的数组是对应的。下面就用一些具体的实例來说明。</p>
<a id="more"></a>

<h1 id="JSON-和-Java-的映射"><a href="#JSON-和-Java-的映射" class="headerlink" title="JSON 和 Java 的映射"></a>JSON 和 Java 的映射</h1><ol>
<li>JSON 示例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot; : &quot;cylong&quot;,</span><br><span class="line">  &quot;age&quot; : 33,</span><br><span class="line">  &quot;position&quot; : &quot;Developer&quot;,</span><br><span class="line">  &quot;salary&quot; : 7500,</span><br><span class="line">  &quot;skills&quot; : [ &quot;java&quot;, &quot;python&quot; ],</span><br><span class="line">  &quot;date&quot; : &quot;2017-03-31 12:29:42&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>对应的 Java 类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Staff</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">private</span> String position;</span><br><span class="line">  <span class="keyword">private</span> BigDecimal salary;</span><br><span class="line">  <span class="keyword">private</span> List&lt;String&gt; skills;</span><br><span class="line">  <span class="comment">// Jackson 语法</span></span><br><span class="line">  <span class="meta">@JsonFormat(shape = JsonFormat.Shape.STRING, pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> Date date;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>相信以上的例子可以让你很好的理解两者之间的对应关系。其实不仅 Java，其他语言也类似。</p>
<h1 id="Jackson-使用"><a href="#Jackson-使用" class="headerlink" title="Jackson 使用"></a>Jackson 使用</h1><ol>
<li>在 <code>pom.xml</code> 中添加依赖项<figure class="highlight xml"><figcaption><span>pom.xml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>Java 对象转化成 JSON<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">Staff obj = <span class="keyword">new</span> Staff();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 Java 对象转化成 JSON 并写入文件中</span></span><br><span class="line">mapper.writeValue(<span class="keyword">new</span> File(<span class="string">&quot;c:\\file.json&quot;</span>), obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 Java 对象转化成 JSON 字符串</span></span><br><span class="line">String jsonInString = mapper.writeValueAsString(obj);</span><br></pre></td></tr></table></figure></li>
<li>JSON 转化成 Java 对象<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">String jsonInString = <span class="string">&quot;&#123;&#x27;name&#x27; : &#x27;mkyong&#x27;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从文件中读取 JSON 并转化成 Java 对象</span></span><br><span class="line">Staff obj = mapper.readValue(<span class="keyword">new</span> File(<span class="string">&quot;c:\\file.json&quot;</span>), Staff.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 URL 中读取 JSON 并转化成 Java 对象</span></span><br><span class="line">Staff obj = mapper.readValue(<span class="keyword">new</span> URL(<span class="string">&quot;http://mkyong.com/api/staff.json&quot;</span>), Staff.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 JSON 字符串转化成 Java 对象</span></span><br><span class="line">Staff obj = mapper.readValue(jsonInString, Staff.class);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="参考-amp-感谢"><a href="#参考-amp-感谢" class="headerlink" title="参考&amp;感谢"></a>参考&amp;感谢</h1><p>其实以上的内容在下面的链接中均有详细的介绍，我只是一个代码的搬运工( ╯□╰ )，就当是自己的笔记好了。</p>
<blockquote>
<p><a href="https://www.mkyong.com/java/jackson-2-convert-java-object-to-from-json/" title="Jackson 2 – Convert Java Object to / from JSON">Jackson 2 – Convert Java Object to / from JSON</a> 【Jackson 使用详细教程】<br><a href="http://www.baeldung.com/jackson-serialize-dates" title="Jackson Date">Jackson Date</a> 【有关 Jackson 对日期的处理】<br><a href="http://www.json.org/json-zh.html" title="JSON 中文文档">JSON 中文文档</a> 【概念性的东西，最下面也有不同语言的支持】<br><a href="http://wiki.jikexueyuan.com/project/json/" title="JSON 教程 - 极客学院">JSON 教程 - 极客学院</a> 【包含 JSON 基础介绍和在其他语言中使用 JSON】</p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2017/03/31/jackson-java-json/' title='Jackson - Java Object 与 JSON 之间的转化工具' >Jackson - Java Object 与 JSON 之间的转化工具</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2017/03/31/jackson-java-json/' title='Jackson - Java Object 与 JSON 之间的转化工具' >http://www.cylong.com/blog/2017/03/31/jackson-java-json/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jackson</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 通过 DOM 方式解析、创建 XML</title>
    <url>/blog/2017/04/04/java-dom-xml/</url>
    <content><![CDATA[<hr>
<h1 id="DOM-简介"><a href="#DOM-简介" class="headerlink" title="DOM 简介"></a>DOM 简介</h1><p>DOM（Document Object Model) 是 W3C 处理 XML 的标准 API，不仅 Java 其他很多语言，比如 Javascript、PHP等等语言都实现了该标准。Java 类库支持 DOM 操作【也就是说不需要下载依赖其他包】。DOM 以树状结构组织节点和信息的集合，这种结构允许开发人员对 XML 文档进行增删改查。为了分析该树状结构，我们需要加载整个 XML 文档进行构造分析，所以消耗资源比较大，建议在操作小文件的时候使用。</p>
<a id="more"></a>

<h1 id="创建-XML-文档"><a href="#创建-XML-文档" class="headerlink" title="创建 XML 文档"></a>创建 XML 文档</h1><ol>
<li>创建 XML Document 对象<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建 XML Document 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> XML Document 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cylong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2017年4月5日 上午12:19:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Document <span class="title">createXMLDocument</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</span><br><span class="line">    DocumentBuilder builder = <span class="keyword">null</span>;</span><br><span class="line">    Document document = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        builder = factory.newDocumentBuilder();</span><br><span class="line">        document = builder.newDocument();</span><br><span class="line">        Element root = document.createElement(<span class="string">&quot;college&quot;</span>);</span><br><span class="line">        document.appendChild(root);</span><br><span class="line"></span><br><span class="line">        Element student = document.createElement(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">        student.setAttribute(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">        Element name = document.createElement(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        name.appendChild(document.createTextNode(<span class="string">&quot;cylong&quot;</span>));</span><br><span class="line">        student.appendChild(name);</span><br><span class="line">        Element biography = document.createElement(<span class="string">&quot;biography&quot;</span>);</span><br><span class="line">        biography.appendChild(document.createCDATASection(<span class="string">&quot;Hello&quot;</span>));</span><br><span class="line">        student.appendChild(biography);</span><br><span class="line">        Element age = document.createElement(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        age.appendChild(document.createTextNode(<span class="string">&quot;24&quot;</span>));</span><br><span class="line">        student.appendChild(age);</span><br><span class="line"></span><br><span class="line">        Element student1 = document.createElement(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">        student1.setAttribute(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        Element name1 = document.createElement(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        name1.appendChild(document.createTextNode(<span class="string">&quot;cylong1&quot;</span>));</span><br><span class="line">        student1.appendChild(name1);</span><br><span class="line">        Element biography1 = document.createElement(<span class="string">&quot;biography&quot;</span>);</span><br><span class="line">        biography1.appendChild(document.createCDATASection(<span class="string">&quot;World&quot;</span>));</span><br><span class="line">        student1.appendChild(biography1);</span><br><span class="line">        Element age1 = document.createElement(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        age1.appendChild(document.createTextNode(<span class="string">&quot;25&quot;</span>));</span><br><span class="line">        student1.appendChild(age1);</span><br><span class="line"></span><br><span class="line">        root.appendChild(document.createComment(<span class="string">&quot;学生0&quot;</span>));</span><br><span class="line">        root.appendChild(student);</span><br><span class="line">        root.appendChild(document.createComment(<span class="string">&quot;学生1&quot;</span>));</span><br><span class="line">        root.appendChild(student1);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ParserConfigurationException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> document;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>将创建的 XML Document 写入到文件中<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将创建的 XML Document 写入到文件中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> document</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> path 文件路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cylong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2017年4月3日 上午2:39:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeXML</span><span class="params">(Document document, String path)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    TransformerFactory tf = TransformerFactory.newInstance();</span><br><span class="line">    Transformer transformer = tf.newTransformer();</span><br><span class="line">    DOMSource source = <span class="keyword">new</span> DOMSource(document);</span><br><span class="line">    transformer.setOutputProperty(OutputKeys.ENCODING, <span class="string">&quot;utf8&quot;</span>);</span><br><span class="line">    transformer.setOutputProperty(OutputKeys.INDENT, <span class="string">&quot;yes&quot;</span>);</span><br><span class="line">    PrintWriter pw = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileOutputStream(path));</span><br><span class="line">    StreamResult result = <span class="keyword">new</span> StreamResult(pw);</span><br><span class="line">    transformer.transform(source, result);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (TransformerConfigurationException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (TransformerException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="解析-XML-文档"><a href="#解析-XML-文档" class="headerlink" title="解析 XML 文档"></a>解析 XML 文档</h1><ol>
<li><p>解析 XML 文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析 XML 文档</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> path XML 文档路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cylong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2017年4月3日 上午2:48:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parserXML</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span><br><span class="line">        DocumentBuilder db = dbf.newDocumentBuilder();</span><br><span class="line">        Document document = db.parse(path);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// optional, but recommended</span></span><br><span class="line">        <span class="comment">// read this - http://stackoverflow.com/questions/13786607/normalization-in-dom-parsing-with-java-how-does-it-work</span></span><br><span class="line">        document.getDocumentElement().normalize();</span><br><span class="line"></span><br><span class="line">        Element root = document.getDocumentElement();</span><br><span class="line">        System.out.println(<span class="string">&quot;Root element : &quot;</span> + root.getNodeName());</span><br><span class="line">        NodeList students = root.getElementsByTagName(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; students.getLength(); i++) &#123;</span><br><span class="line">            Node student = students.item(i);</span><br><span class="line">            System.out.println(student.getNodeName());</span><br><span class="line"></span><br><span class="line">            NodeList info = student.getChildNodes();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; info.getLength(); j++) &#123;</span><br><span class="line">                Node meta = info.item(j);</span><br><span class="line">                <span class="keyword">if</span> (meta.getNodeType() == Node.ELEMENT_NODE) &#123;</span><br><span class="line">                    System.out.println(meta.getNodeName() + <span class="string">&quot;:&quot;</span> + meta.getTextContent());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ParserConfigurationException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SAXException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意<br>可以 <a href="http://stackoverflow.com/questions/13786607/normalization-in-dom-parsing-with-java-how-does-it-work">点此链接</a> 了解其用处。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// optional, but recommended</span></span><br><span class="line"><span class="comment">// read this - http://stackoverflow.com/questions/13786607/normalization-in-dom-parsing-with-java-how-does-it-work</span></span><br><span class="line">document.getDocumentElement().normalize();</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h1 id="参考-amp-感谢"><a href="#参考-amp-感谢" class="headerlink" title="参考&amp;感谢"></a>参考&amp;感谢</h1><blockquote>
<p><a href="https://github.com/cylong1016/CodeJava/blob/master/src/cylong/xml/ParserXML.java">Github 完整的代码案例</a><br><a href="https://www.mkyong.com/java/how-to-read-xml-file-in-java-dom-parser/">How to read XML file in Java – (DOM Parser)</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2017/04/04/java-dom-xml/' title='Java 通过 DOM 方式解析、创建 XML' >Java 通过 DOM 方式解析、创建 XML</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2017/04/04/java-dom-xml/' title='Java 通过 DOM 方式解析、创建 XML' >http://www.cylong.com/blog/2017/04/04/java-dom-xml/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>dom</tag>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title>多说评论迁移至 Disqus - Java 实现</title>
    <url>/blog/2017/04/05/duoshuo-to-disqus/</url>
    <content><![CDATA[<hr>
<p>在网上找了一圈后，很多人都造过轮子，但是由于年代久远，多说和 Disqus 的评论格式可能发生变化，试了一些后并没有一个成功。无奈自己开始造轮子，不过看完两种评论文件格式后，发现其实还是瞒简单的，于是就用 Java 实现了一个。【为了节省时间就用自己最擅长的 Java 了，虽然其他语言可能会更快更方便的使用( ╯□╰ )】。下面附上工具链接和使用方法。</p>
<blockquote>
<p><a href="https://github.com/cylong1016/DuoshuoToDisqus" title="工具源码地址">工具源码地址</a></p>
</blockquote>
<a id="more"></a>

<h1 id="导出多说评论"><a href="#导出多说评论" class="headerlink" title="导出多说评论"></a>导出多说评论</h1><ol>
<li>进入多说后台选择 <code>工具-&gt;导出数据</code>。</li>
<li>勾上 <code>包含文章数据</code> 和 <code>包含评论数据</code> 两个选项。</li>
<li>导出后是一个 JSON 文件，为了方便查看可以使用 <a href="http://tool.oschina.net/codeformat/json" title="在线代码格式化">在线代码格式化</a> 工具。</li>
</ol>
<h1 id="使用工具转化"><a href="#使用工具转化" class="headerlink" title="使用工具转化"></a>使用工具转化</h1><ol>
<li><a href="https://github.com/cylong1016/DuoshuoToDisqus/archive/master.zip">点击下载</a> 转化工具，并解压。</li>
<li>将导出的多说 JSON 文件重命名为 <code>duoshuo.json</code> 放入 <code>data</code> 文件夹下。【先删除掉存在的文件吧，其实是我的多说评论数据】</li>
<li>双击运行 <code>run.bat</code>。将会在 <code>data</code> 文件夹下生成 <code>duoshuo-format.json</code> 【格式化后的多说评论文件，方便查看】和 <code>disqus.xml</code>【导入到 Disqus 的 XML 文件】。</li>
</ol>
<p><strong>注意：如果发现并没有生成以上的两个文件，或者生成的文件数据有误，请使用以下方式运行程序。</strong></p>
<ol start="5">
<li>按住 <code>Shift</code> + 鼠标右键选择 <code>在此处打开命令行窗口</code>【Windows】或者打开终端进入项目目录下【Linux】。</li>
<li>输入以下命令并回车：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar DuoshuoToDisqus.jar</span><br></pre></td></tr></table></figure></li>
<li>这种方式运行的好处是可以看到程序出错信息，同时你可以在命令最后输入你的多说评论文件路径【就不用将多说评论文件放入到 <code>data</code> 文件夹下了。】<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar DuoshuoToDisqus.jar C:\duoshuo.json</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="导入到-Disqus-中"><a href="#导入到-Disqus-中" class="headerlink" title="导入到 Disqus 中"></a>导入到 Disqus 中</h1><ol>
<li><a href="https://import.disqus.com/" title="Import and Export - Disqus">点击链接</a> 进入到导入页面，选择你要导入评论的站点。</li>
<li>选择刚刚生成的 <code>disqus.xml</code> 文件，后面的选项选择 <code>WordPress(WXR)</code>，点击 <code>Upload</code>。</li>
<li>接下来静静的等待导入完成，可以看到导入的评论和文章数量，如果出错的话可以看到错误。</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>整个工具其实就是解析多说的 JSON 文件并转化成 Disqus 评论的 XML 文件。想要自己用 Java 实现的可以参考以下链接：</p>
<blockquote>
<p><a href="http://dev.duoshuo.com/docs/500fc3cdb17b12d24b00000a" title="多说评论格式">多说评论格式</a><br><a href="https://help.disqus.com/customer/portal/articles/472150-custom-xml-import-format" title="Custom XML Import Format">Disqus 评论格式</a><br><a href="/blog/2017/03/31/jackson-java-json/" title="Jackson - Java Object 与 JSON 之间的转化工具">Jackson - Java Object 与 JSON 之间的转化工具</a><br><a href="/blog/2017/04/04/java-dom-xml/" title="Java 通过 DOM 方式解析、创建 XML">Java 通过 DOM 方式解析、创建 XML</a><br><a href="https://github.com/cylong1016/DuoshuoToDisqus" title="工具源码地址">工具源码地址</a></p>
</blockquote>
<p>此工具需要 Java 运行环境，可以去网上搜索安装配置一下。另外此工具没有做什么非法输入的处理，所以不要尝试做一些奇怪的事情。如果运行出错请检查一下你的源多说 JSON 文件是否有错误或者使用方式是否有错，有任何问题或者想要我帮忙转化的请在下方留言或者 <a href="/about/" title="关于我">联系我</a>。很高兴可以帮助到你(●’◡’●)。</p>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2017/04/05/duoshuo-to-disqus/' title='多说评论迁移至 Disqus - Java 实现' >多说评论迁移至 Disqus - Java 实现</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2017/04/05/duoshuo-to-disqus/' title='多说评论迁移至 Disqus - Java 实现' >http://www.cylong.com/blog/2017/04/05/duoshuo-to-disqus/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>java</tag>
        <tag>disqus</tag>
      </tags>
  </entry>
  <entry>
    <title>Chrome 配置 SwitchyOmega</title>
    <url>/blog/2017/04/09/chrome-SwitchyOmega/</url>
    <content><![CDATA[<hr>
<p>此文章是以 Shadowsocks 代理为例，若想使用 Shadowsocks 请先安装对应系统的客户端并启动。详情请参考：</p>
<blockquote>
<p><a href="/blog/2016/05/26/shadowsocks/" title="站在 Shadowsocks 的肩膀上发现精彩的世界">站在 Shadowsocks 的肩膀上发现精彩的世界</a></p>
</blockquote>
<h1 id="Chrome-浏览器"><a href="#Chrome-浏览器" class="headerlink" title="Chrome 浏览器"></a>Chrome 浏览器</h1><p>无论是用户体验、强大的功能还是丰富的扩展程序都完爆国内的各种浏览器好不好(╯‵□′)╯︵┻━┻。强烈推荐啊！目前已经可以在不翻墙的情况下去 <a href="http://www.google.cn/chrome/browser/desktop/index.html" title="Chrome（桌面版）">下载 Chrome（桌面版）</a>了，账号数据同步方面也不需要翻墙了。【鼓掌撒花★,°:.☆(￣▽￣)/$:.°★ 。】</p>
<h1 id="SwitchyOmega"><a href="#SwitchyOmega" class="headerlink" title="SwitchyOmega"></a>SwitchyOmega</h1><p>Google Chrome 浏览器上的一个代理扩展程序，可以轻松快捷地管理和切换多个代理设置。比如我们接下来要介绍的 <code>自动切换模式</code>。</p>
<a id="more"></a>

<h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>点击 <a href="https://github.com/FelisCatus/SwitchyOmega/releases" title="FelisCatus/SwitchyOmega">Github-SwitchyOmega</a>，下载页面有详细的安装教程，仔细看一下就好。</p>
<h2 id="配置-Shadowsocks-情景模式"><a href="#配置-Shadowsocks-情景模式" class="headerlink" title="配置 Shadowsocks 情景模式"></a>配置 Shadowsocks 情景模式</h2><ol>
<li>打开 Chrome， 点击右上角的 <span class="fa fa-globe" aria-hidden="true"></span> 图标，再点击 <code>选项</code>。<img src="/blog/2017/04/09/chrome-SwitchyOmega/Shadowsocks-icon.png" class="" title="Shadowsocks 图标"></li>
<li>点击左侧的 <code>新建情景模式</code>，输入情景模式名称 <code>Shadowsocks</code>【自己任意设置名称】，类型选择第一个<code>代理服务器</code>。创建完成后做如下配置：<img src="/blog/2017/04/09/chrome-SwitchyOmega/new.png" class="" title="新建情景模式">
你也可以自己设置不代理的地址列表。如上图。</li>
<li>保存后你就可以通过这个情景模式科学上网了~</li>
</ol>
<h2 id="配置自动切换模式"><a href="#配置自动切换模式" class="headerlink" title="配置自动切换模式"></a>配置自动切换模式</h2><p>配置好 Shadowsocks 情景模式后虽然可以使用 Chrome 浏览器科学上网了，但是这样的话无论你访问什么网站都会走代理，有时候访问国内的一些网站反而会很慢，这时候自动切换模式就解决了这个问题。下面介绍一下如何配置自动切换模式。</p>
<ol>
<li>点击左侧的 <code>自动切换</code>，或者自己新建情景模式，类型选择第二个 <code>自动切换模式</code>。然后做如下配置：<img src="/blog/2017/04/09/chrome-SwitchyOmega/auto.png" class="" title="自动切换模式"></li>
</ol>
<ul>
<li><code>切换规则</code> 是在访问 <code>条件设置</code> 的域名时候使用后面设置的 <code>情景模式</code>。比如图中我设置 <code>*.google.com</code> 和 <code>*.github.com</code> 使用 <code>Shadowsocks</code> 情景模式【刚刚创建的那个情景模式】。我们可以点击 <code>添加条件</code> 来添加自己的规则。</li>
<li>将图中 <code>规则列表规则</code> 前面的框打√，再将后面的 <code>情景模式</code> 设置为 <code>Shadowsocks</code>，意思是规则列表中的内容，我们使用 <code>Shadowsocks</code> 情景模式。然后 <code>规则列表设置</code> 中：<ul>
<li>规则列表格式： AutoProxy；</li>
<li>规则列表网址： <a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</a></li>
</ul>
</li>
<li>这样设置完成 <code>规则列表规则</code> 后就不需要在切换规则中一个一个添加条件了。</li>
<li><code>切换规则</code> 最后一行的 <code>默认情景模式</code> 代表不在规则列表中网址我们使用 <code>直接连接</code> 情景模式，也就是说不走代理。</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote>
<p><a href="https://github.com/FelisCatus/SwitchyOmega" title="FelisCatus/SwitchyOmega">Github-SwitchyOmega</a><br><a href="https://github.com/gfwlist/gfwlist" title="gfwlist/gfwlist">Github-gfwlist</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2017/04/09/chrome-SwitchyOmega/' title='Chrome 配置 SwitchyOmega' >Chrome 配置 SwitchyOmega</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2017/04/09/chrome-SwitchyOmega/' title='Chrome 配置 SwitchyOmega' >http://www.cylong.com/blog/2017/04/09/chrome-SwitchyOmega/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>Shadowsocks</category>
      </categories>
      <tags>
        <tag>shadowsocks</tag>
        <tag>翻墙</tag>
        <tag>SwitchyOmega</tag>
      </tags>
  </entry>
  <entry>
    <title>520·答辩·校庆·校园文化夜·非酋高级成就</title>
    <url>/blog/2017/05/20/520/</url>
    <content><![CDATA[<hr>
<p>经过了几个月的时间，终于完成了大学的最后一项任务：毕业设计（包括毕业项目和毕业论文）。当然，答辩这天正好赶上校庆，赶上校园文化夜，赶上期待已久的阴阳师高级非酋成就。赶上一切的一切。这一天给我的惊喜太多，给我的纪念太多，这一天，应该是本科毕业前第一个有意义的一天（以后还有毕业典礼什么的啊！o(<em>￣▽￣</em>)ブ）必须把这么重要的一天记下来！【以下图片都是手机拍摄的！原谅我的渣画质！】</p>
<a id="more"></a>

<h1 id="毕业答辩"><a href="#毕业答辩" class="headerlink" title="毕业答辩"></a>毕业答辩</h1><p>之前还在想，这是大学最后一次“作业”了，而且并不是那么容易。没想到真投入进去的时候，好像并没有那么难。之前还听学长说论文有多难写，要修改很多遍。答辩时还有人不过，等着第二次答辩。但真正自己做起来，投入进去后，就不会有什么担心了，写完论文的时候，我还在想，我竟然不知不觉写了这么多字。为了防止学校查重不过，自己还花了钱提前查重！进到答辩现场的时候，说不紧张是肯定没人信的，好歹评审老师是那种比较逗逼的人（CZY &amp; LJ），并没有给学生太大的压力。一下午竟然就这么快过去了！宣布通过名单的时候还是难以置信，自己就这样要毕业了呢，以至于后面我一直问思思姐，我真的过了么？可以毕业了么？其实只要自己认真做了，毕业还是很简单的。最重要的一点是！我忘记拍照留念了啊！还是当时太紧张了啊！(╯‵□′)╯︵┻━┻</p>
<h1 id="校庆"><a href="#校庆" class="headerlink" title="校庆"></a>校庆</h1><p>520这天还是南大的校庆，每次校庆，学校都会发两张5元餐券，以前一直都是用一张留一张纪念，但是后来都找不到了呢！所以这次要拍照留念！哈哈哈哈！(●’◡’●)</p>
<img src="/blog/2017/05/20/520/520%E6%A0%A1%E5%BA%86%E9%A4%90%E5%88%B8.jpg" class="" title="520校庆餐券">

<p>答辩完出来的时候看到了热烈庆祝南京大学建校115周年的展板【其实去答辩的时候就看到了，但那个时候谁还有心思拍照呢？】不完美的是展板上写满了祝福的话或者名字啥的，虽然大家并无恶意，不过整个展板拍照后就感觉好乱╮(╯▽╰)╭</p>
<img src="/blog/2017/05/20/520/%E6%A0%A1%E5%BA%86.jpg" class="" title="校庆">

<h1 id="非酋高级成就"><a href="#非酋高级成就" class="headerlink" title="非酋高级成就"></a>非酋高级成就</h1><p>就在去仙林校区【我在鼓楼校区】参加校园文化夜的地铁上，思思姐帮我抽卡，庆祝下答辩完成。意料之内的没有SSR，但是发现拿到了期待已久的高级非酋成就！【抽卡400张没有SSR的成就】虽然这是非洲人的一种表现，但是我早就习惯了呢，而且我在意的是500连抽没有SSR的非洲阴阳师成就，会送一个稀有头像框——月见黑。这比抽到SSR的概率低的多啊。</p>
<img src="/blog/2017/05/20/520/%E9%9D%9E%E9%85%8B%E9%AB%98%E7%BA%A7%E6%88%90%E5%B0%B1.jpg" class="" title="非酋高级成就">

<h1 id="校园文化夜"><a href="#校园文化夜" class="headerlink" title="校园文化夜"></a>校园文化夜</h1><p>这是大学四年里第三次参加了，也是最后一次。大一大二就在仙林，每年都会参加，大三搬到鼓楼，有事耽搁了一次没去。文化夜还是老样子，社团、院系都有自己的展台，在宿舍区中间的路上。先去领盖章的一页纸，每去一个展台玩小游戏都会帮你盖章，然后去领奖品。由于答辩结束的比较晚，去到仙林都已经快8点了，首先当然是找软院的展台啊！我和思思姐正玩着呢，突然看到有人坐在电脑前，玩着小游戏。我就好奇的凑过去，这不是软院的传统，大一时候程序设计大赛做的小游戏么？赶紧上去试玩了一下，相比之下，真的比我当时做的好多了呢，长江后浪推前浪啊~接下来看到了漂亮的汉服社小姐姐，思思姐每次来都会试穿汉服让我拍照呢。</p>
<img src="/blog/2017/05/20/520/%E5%A4%A7%E5%9B%9B%E7%A9%BF%E6%B1%89%E6%9C%8D%E7%9A%84%E6%80%9D%E6%80%9D%E5%A7%90.jpg" class="" title="大四穿汉服的思思姐">

<p>下面这张是从思思姐那要来的大一时候穿汉服的思思姐，因为那个时候还没在一起呢。【// 相比之下是不是胖了好多！つ﹏⊂】</p>
<img src="/blog/2017/05/20/520/%E5%A4%A7%E4%B8%80%E7%A9%BF%E6%B1%89%E6%9C%8D%E7%9A%84%E6%80%9D%E6%80%9D%E5%A7%90.jpg" class="" title="大一穿汉服的思思姐">

<p>后来又遇到了一个听歌识曲的游戏，我问他，有动漫方面的么？他先放了一首魔卡少女樱的主题曲，又放了一首四驱兄弟的主题曲，都被我猜到了，毕竟这都是童年呢！最后放了一首虹猫蓝兔七侠传，我竟然没听出来，看来要补番了！没逛几个展台，发现大家基本上都在收拾东西，差不多结束了，我和思思姐准备去换礼物了，然后……工作人员说礼物已经发完了。(╯‵□′)╯︵┻━┻</p>
<h1 id="520"><a href="#520" class="headerlink" title="520"></a>520</h1><p>520这天怎么少得了秀恩爱呢！毕设一起做、一起答辩、一起去仙林参加校园文化夜，感谢思思姐一直的陪伴。以后也会是开开心心的每一天呢(^_^)</p>
<img src="/blog/2017/05/20/520/%E5%9B%9E%E6%9D%A5%E7%9A%84%E5%9C%B0%E9%93%81%E4%B8%8A.jpg" class="" title="回来的地铁上">

<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2017/05/20/520/' title='520·答辩·校庆·校园文化夜·非酋高级成就' >520·答辩·校庆·校园文化夜·非酋高级成就</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2017/05/20/520/' title='520·答辩·校庆·校园文化夜·非酋高级成就' >http://www.cylong.com/blog/2017/05/20/520/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>2018年立个FLAG-坚持写博客！</title>
    <url>/blog/2018/06/24/new-2018/</url>
    <content><![CDATA[<hr>
<p>时隔一年，终于想起来还有博客这种事情。工作忙的昏天黑地，但是又学不到什么太多的东西，看到很多周围的同学变得越来越厉害，有自己的目标，我也不想一直这样平淡的度过，总的想点提升不是？开始为自己的将来做准备吧！</p>
<p>FLAG我就立在这了！一定要坚持下去！积少成多！(╯‵□′)╯︵┻━┻</p>
<a id="more"></a>

<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2018/06/24/new-2018/' title='2018年立个FLAG-坚持写博客！' >2018年立个FLAG-坚持写博客！</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2018/06/24/new-2018/' title='2018年立个FLAG-坚持写博客！' >http://www.cylong.com/blog/2018/06/24/new-2018/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言头文件使用总结</title>
    <url>/blog/2018/06/25/c-header/</url>
    <content><![CDATA[<hr>
<p>在平时工作中看到前人写的一些C头文件，很有感触。自己在写的时候也遇到了很多问题，比如重复引用导致宏或者常量重复定义，不知道该使用双引号还是使用尖括号引用等问题，决定先总结一下。做个笔记，随时复习。o(￣▽￣)ブ</p>
<h1 id="C语言头文件"><a href="#C语言头文件" class="headerlink" title="C语言头文件"></a>C语言头文件</h1><p>C语言头文件一般包含了函数声明，宏定义，常量等代码。我们在使用#include引用头文件。可以被多个c文件引用，避免了重复代码，减少了错误。让代码更加规范。<br>A simple practice in C 或 C++ 程序中，建议把所有的常量、宏、系统全局变量和函数原型写在头文件中，在需要的时候随时引用这些头文件。</p>
<a id="more"></a>

<h1 id="头文件引用"><a href="#头文件引用" class="headerlink" title="头文件引用"></a>头文件引用</h1><p>系统已经存在了很多头文件，当然，我们也可以自己编写。c文件引用头文件相当于直接复制到文件中，但是这样多个文件要使用这段代码的时候，就产生了很多重复代码，也不方便管理。引用存在两种引用形式。一种<code>#include &quot;cylong.h&quot;</code>，一种是 <code>#include &lt;cylong.h&gt;</code>。那这两种方式有什么区别呢？我们平时使用的时候又怎么用呢？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cylong.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>这种形式是引用系统文件，在系统目录下搜索此头文件。比如<code>#include &lt;stdio.h&gt;</code>等</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cylong.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>这种形式是引用用户文件，优先在当前目录下搜索此头文件，然后再去系统目录下搜索此头文件。</p>
<p>所以无论是我们自己写的头文件还是引用系统头文件，使用<code>#include &quot;cylong.h&quot;</code>都不会出错。但是这样并不标准，标准规定，<b>包含标准头文件或系统头文件时应使用尖括号，包含自定义头文件时可使用双引号。</b></p>
<h1 id="避免重复引用"><a href="#避免重复引用" class="headerlink" title="避免重复引用"></a>避免重复引用</h1><p>经常在写代码的时候，不经意间，我们会引用同一个头文件两次，那么我们会遇到很多重复定义的错误，为了避免这样的事情发生，我们需要将头文件里的内容放到编译宏中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CYONG_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CYLONG_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span> <span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// some codes</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> CYLONG_H</span></span><br></pre></td></tr></table></figure>

<p>当我们第一次引用的时候，未定义<code>CYLONG_H</code>宏，所以会继续编译下面的代码，当第二次引用的时候，<code>#ifndef CYLONG_H</code>为假，就不会编译下面的代码了，自然不会存在重复定义等问题。</p>
<h1 id="公共头文件"><a href="#公共头文件" class="headerlink" title="公共头文件"></a>公共头文件</h1><p>在程序代码中，经常很多c文件会引用一些相同的头文件，这个时候，我们就可以定义一个包含这些相同头文件的头文件<code>common.h</code>。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> COMMON_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMMON_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cylong.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;lsyu.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> COMMON_H</span></span><br></pre></td></tr></table></figure>

<p>然后我们就可以在每个需要的c文件中引用这个<code>common.h</code>头文件。但是需要注意的是，这个文件里除了头文件引用以外，建议不要再写其他的代码。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote>
<p><a href="http://www.runoob.com/cprogramming/c-header-files.html" title="C 头文件 | 菜鸟教程">C 头文件 | 菜鸟教程</a><br><a href="http://c.biancheng.net/cpp/biancheng/view/66.html" title="C++ #include—尖括号和双引号的区别 | C语言中文网">C++ #include—尖括号和双引号的区别 | C语言中文网</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2018/06/25/c-header/' title='C语言头文件使用总结' >C语言头文件使用总结</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2018/06/25/c-header/' title='C语言头文件使用总结' >http://www.cylong.com/blog/2018/06/25/c-header/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>头文件</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 8 的 Lambda 表达式和 Stream API</title>
    <url>/blog/2019/03/18/lambda/</url>
    <content><![CDATA[<hr>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Java 8 的 Lambda 表达式提供了强大的函数化的编程能力，将函数作为参数传递进方法中。免去了使用匿名方法的麻烦，这样使可读性更好，表达更清晰。它是推动 Java 8 发布的最重要新特性。Lambda 表达式的简洁让人非常激动，但是如果第一次看到一段复杂的Lambda表达式的代码，会让你非常头疼，对于初学者来说，可能就是一段垃圾代码，因为你并不知道 Lambda 表达式到底在表达什么╮(╯▽╰)╭下面我们就举一些小例子由浅入深的了解下 Lambda 表达式。</p>
<a id="more"></a>

<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><p><code>(parameters) -&gt; expression</code> 或者 <code>(parameters) -&gt;&#123; statements; &#125;</code></p>
<p>个人理解，把 Lambda 表达式看成咱们上学的时候学的函数 <code>f(x) = x + 1</code> 会让你更容易理解。</p>
<p>以下是lambda表达式的重要特征:</p>
<ul>
<li><b>可选类型声明：</b>不需要声明参数类型，编译器可以统一识别参数值。</li>
<li><b>可选的参数圆括号：</b>一个参数无需定义圆括号，但多个参数需要定义圆括号。</li>
<li><b>可选的大括号：</b>如果主体包含了一个语句，就不需要使用大括号。</li>
<li><b>可选的返回关键字：</b>如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</li>
</ul>
<h1 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Greeting</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, Operation operation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> operation.calc(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String msg, Greeting greeting)</span> </span>&#123;</span><br><span class="line">        greeting.say(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 类型声明</span></span><br><span class="line">        Operation addition = (<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; a + b;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不用类型声明</span></span><br><span class="line">        Operation subtraction = (a, b) -&gt; a - b;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 大括号中的返回语句。</span></span><br><span class="line">        <span class="comment">// 一般只有存在多行语句的时候才会使用，单行语句不需要使用，部分IDE会提示去掉大括号。</span></span><br><span class="line">        Operation multiplication = (<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> a * b;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有大括号及返回语句</span></span><br><span class="line">        Operation division = (<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; a / b;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;10 + 5 = &quot;</span> + LambdaTest.calc(<span class="number">10</span>, <span class="number">5</span>, addition));</span><br><span class="line">        System.out.println(<span class="string">&quot;10 - 5 = &quot;</span> + LambdaTest.calc(<span class="number">10</span>, <span class="number">5</span>, subtraction));</span><br><span class="line">        System.out.println(<span class="string">&quot;10 x 5 = &quot;</span> + LambdaTest.calc(<span class="number">10</span>, <span class="number">5</span>, multiplication));</span><br><span class="line">        System.out.println(<span class="string">&quot;10 / 5 = &quot;</span> + LambdaTest.calc(<span class="number">10</span>, <span class="number">5</span>, division));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不用括号</span></span><br><span class="line">        Greeting sayHello = message -&gt; System.out.println(<span class="string">&quot;Hello &quot;</span> + message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用括号</span></span><br><span class="line">        Greeting sayBye = (message) -&gt; System.out.println(<span class="string">&quot;Bye &quot;</span> + message);</span><br><span class="line"></span><br><span class="line">        LambdaTest.say(<span class="string">&quot;cylong&quot;</span>, sayHello);</span><br><span class="line">        LambdaTest.say(<span class="string">&quot;cylong&quot;</span>, sayBye);</span><br><span class="line">        LambdaTest.say(<span class="string">&quot;cylong&quot;</span>, message -&gt; System.out.println(<span class="string">&quot;Hi &quot;</span> + message));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以前的匿名类</span></span><br><span class="line">        LambdaTest.say(<span class="string">&quot;cylong&quot;</span>, <span class="keyword">new</span> Greeting() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hello &quot;</span> + msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码的输出为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 + 5 &#x3D; 15</span><br><span class="line">10 - 5 &#x3D; 5</span><br><span class="line">10 x 5 &#x3D; 50</span><br><span class="line">10 &#x2F; 5 &#x3D; 2</span><br><span class="line">Hello cylong</span><br><span class="line">Bye cylong</span><br><span class="line">Hello cylong</span><br><span class="line">Hello cylong</span><br></pre></td></tr></table></figure>

<h1 id="Java-8-的-Stream-API"><a href="#Java-8-的-Stream-API" class="headerlink" title="Java 8 的 Stream API"></a>Java 8 的 Stream API</h1><p>其实目前用 Lambda 表达式最多的地方就是 Java 8 的新特性——Stream API，借助于 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。Java 8 中的 Stream 是对集合（Collection）对象功能的增强，Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的。在以前的 Java API中，我们更多的是使用for或者Iterator来遍历集合，同时我们可能会对集合里的数据进行过滤，计算等等处理，导致代码量非常的多，还容易出错。而使用 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。下面我们就看一些例子，深入了解下 Stream 的使用。</p>
<h2 id="集合迭代"><a href="#集合迭代" class="headerlink" title="集合迭代"></a>集合迭代</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通的 for 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n : numList) &#123;</span><br><span class="line">    System.out.println(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Lambda 表达式</span></span><br><span class="line">numList.forEach(n -&gt; System.out.println(n));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Java 8 的方法引用</span></span><br><span class="line"><span class="comment">// 看起来像C++的作用域解析运算符</span></span><br><span class="line">numList.forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>上面的例子包含普通的for循环，Lambda表达式遍历的方式，最后一种方式是方法引用，让代码量再次减少，代码更加清晰。</p>
<h2 id="集合过滤"><a href="#集合过滤" class="headerlink" title="集合过滤"></a>集合过滤</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出集合中所有大于5的值</span></span><br><span class="line">numList.stream().filter(n -&gt; n &gt; <span class="number">5</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>上面的代码中 <code>filter(n -&gt; n &gt; 5)</code>就是获得集合中大于5的所有值，filter 的参数是 <code>java.util.function.Predicate</code>，返回值是一个 Stream。使用 Predicate 可以向API方法添加逻辑，用更少的代码支持更多的动态行为。上面的例子就是使用 Predicate 对集合进行过滤。在 filter() 方法中，我们可以写更多复杂的逻辑来过滤集合元素。甚至可以使用 <code>and()</code> 或者 <code>or()</code>等合并多个条件，如下面这样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出集合中所有大于5并且小于8的值</span></span><br><span class="line">Predicate&lt;Integer&gt; start = n -&gt; n &gt;<span class="number">5</span>;</span><br><span class="line">Predicate&lt;Integer&gt; end = n -&gt; n &lt;<span class="number">8</span>;</span><br><span class="line">numList.stream().filter(start.and(end)).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>另外，关于 filter() 方法有个常见误解。在现实生活中，做过滤的时候，通常会丢弃部分，但使用filter()方法则是获得一个新的列表，且其每个元素符合过滤原则。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个新的集合，所有元素的值大于5</span></span><br><span class="line">List&lt;Integer&gt; newNumList = numList.stream().filter(n -&gt; n &gt; <span class="number">5</span>).collect(Collectors.toList());</span><br><span class="line">newNumList.forEach(System.out::println);</span><br><span class="line">System.out.println();</span><br><span class="line">numList.forEach(System.out::print);</span><br></pre></td></tr></table></figure>

<p>输出是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">678910</span><br><span class="line">12345678910</span><br></pre></td></tr></table></figure>

<h2 id="Stream-的-map-示例"><a href="#Stream-的-map-示例" class="headerlink" title="Stream 的 map 示例"></a>Stream 的 map 示例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将集合中的所有值计算平方后输出</span></span><br><span class="line">numList.stream().map(n -&gt; n * n).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>本例介绍最广为人知的函数式编程概念 map。它允许你将对象进行转换。例如在本例中，我们将 <code>n -&gt; n * n</code> lambda 表达式传到 map() 方法，后者将其应用到流中的每一个元素。然后用 <code>forEach()</code> 将列表元素打印出来。</p>
<h2 id="Stream-的-Reduce-示例"><a href="#Stream-的-Reduce-示例" class="headerlink" title="Stream 的 Reduce 示例"></a>Stream 的 Reduce 示例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将集合中的所有值求和</span></span><br><span class="line"><span class="keyword">int</span> result = numList.stream().reduce((sum, n) -&gt; sum + n).get();</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure>

<p>在上个例子中，可以看到map将集合类（例如列表）元素进行转换的。还有一个 reduce() 函数可以将所有值合并成一个。Map和Reduce操作是函数式编程的核心操作，因为其功能，reduce 又被称为折叠操作。另外，reduce 并不是一个新的操作，你有可能已经在使用它。SQL中类似 sum()、avg() 或者 count() 的聚集函数，实际上就是 reduce 操作，因为它们接收多个值并返回一个值。流API定义的 reduce() 函数可以接受lambda表达式，并对所有值进行合并。IntStream这样的类有类似 average()、count()、sum() 的内建方法来做 reduce 操作，也有mapToLong()、mapToDouble() 方法来做转换。这并不会限制你，你可以用内建方法，也可以自己定义。</p>
<h2 id="计算集合元素的最大值、最小值、总和以及平均值"><a href="#计算集合元素的最大值、最小值、总和以及平均值" class="headerlink" title="计算集合元素的最大值、最小值、总和以及平均值"></a>计算集合元素的最大值、最小值、总和以及平均值</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算集合元素的最大值、最小值、总和以及平均值</span></span><br><span class="line">IntSummaryStatistics stats = numList.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line">System.out.println(<span class="string">&quot;Highest prime number in List : &quot;</span> + stats.getMax());</span><br><span class="line">System.out.println(<span class="string">&quot;Lowest prime number in List : &quot;</span> + stats.getMin());</span><br><span class="line">System.out.println(<span class="string">&quot;Sum of all prime numbers : &quot;</span> + stats.getSum());</span><br><span class="line">System.out.println(<span class="string">&quot;Average of all prime numbers : &quot;</span> + stats.getAverage());</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Highest prime number in List : 10</span><br><span class="line">Lowest prime number in List : 1</span><br><span class="line">Sum of all prime numbers : 55</span><br><span class="line">Average of all prime numbers : 5.5</span><br></pre></td></tr></table></figure>

<h2 id="并行流-parallelStream"><a href="#并行流-parallelStream" class="headerlink" title="并行流 parallelStream"></a>并行流 parallelStream</h2><p>上文有提到，Stream API 提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势。串行流就是上面的 stream，而想要并行操作，就需要使用 parallelSteram。下面举一个例子来看看 stream 和 parallelStream 的区别。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParallelStreamTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; numList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        doFor(numList);</span><br><span class="line">        doStream(numList);</span><br><span class="line">        doParallelStream(numList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doFor</span><span class="params">(List&lt;Integer&gt; numList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : numList) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(num);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">long</span> stop = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;doFor: &quot;</span> + (stop - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doStream</span><span class="params">(List&lt;Integer&gt; numList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        numList.stream().forEach(num -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(num);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">long</span> stop = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;doStream: &quot;</span> + (stop - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doParallelStream</span><span class="params">(List&lt;Integer&gt; numList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        numList.parallelStream().forEach(num -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(num);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">long</span> stop = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;doParallelStream: &quot;</span> + (stop - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12345</span><br><span class="line">doFor: 5003</span><br><span class="line">12345</span><br><span class="line">doStream: 5003</span><br><span class="line">34251</span><br><span class="line">doParallelStream: 1009</span><br></pre></td></tr></table></figure>

<p>代码上 stream 和 parallelStream 语法差异较小，用法基本一样。从执行结果来看，stream 顺序输出，而 parallelStream 无序输出；parallelStream 执行耗时是 stream 的五分之一，stream 和 for 循环用时一样。可以看到在当前测试场景下，parallelStream 获得的相对较好的执行性能，那 parallelStream 背后到底是什么呢？<br>要深入了解 parallelStream，首先要弄明白 ForkJoin 框架和 ForkJoinPool。ForkJoin 框架是 java 7 中提供的并行执行框架，他的策略是分而治之。说白了，就是把一个大的任务切分成很多小的子任务，子任务执行完毕后，再把结果合并起来。</p>
<h2 id="parallelStream-使用注意点"><a href="#parallelStream-使用注意点" class="headerlink" title="parallelStream 使用注意点"></a>parallelStream 使用注意点</h2><p>在开发过程中，经常会遇到遍历一个很大的集合做重复的操作，这时候如果使用串行执行会相当耗时，因此一般会采用多线程来提速。但是 parallelStream 若使用不当，很容易掉进陷阱中。总结以下几点需要注意：</p>
<ul>
<li>parallelStream 对集合操作是无序的，所以若需要顺序操作，请使用 stream 或者使用 parallelStream().forEachOrdered，后者执行时间就和 stream一样了，并不会提高效率。</li>
<li>parallelStream 速度并不会总是比 stream 快。将上面的例子修改为 <code>Thread.sleep(1)</code>，输出结果为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12345</span><br><span class="line">doFor: 10</span><br><span class="line">12345</span><br><span class="line">doStream: 12</span><br><span class="line">32154</span><br><span class="line">doParallelStream: 13</span><br></pre></td></tr></table></figure>

<p>可见并不是并行执行就是性能最好的，要根据具体的应用场景测试分析。这个例子中，每个子任务执行时间较短，而线程切换消耗了大量时间。</p>
<ul>
<li>paralleStream 是非线程安全的！非线程安全！非线程安全！重要的事情说三遍。下面看一个例子就可以很明显的看到了。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; list3 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">10000</span>).forEach(list1::add);</span><br><span class="line"></span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">10000</span>).parallel().forEach(list2::add);</span><br><span class="line"></span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">10000</span>).forEach(i -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                list3.add(i);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;串行执行的大小：&quot;</span> + list1.size());</span><br><span class="line">        System.out.println(<span class="string">&quot;并行执行的大小：&quot;</span> + list2.size());</span><br><span class="line">        System.out.println(<span class="string">&quot;加锁并行执行的大小：&quot;</span> + list3.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">串行执行的大小：10000</span><br><span class="line">并行执行的大小：9592</span><br><span class="line">加锁并行执行的大小：10000</span><br></pre></td></tr></table></figure>

<p>显而易见，stream.parallel.forEach()中执行的操作并非线程安全。如果需要线程安全，可以把集合转换为同步集合，即：Collections.synchronizedList(new ArrayList&lt;&gt;())。也可以像例子中的那样，对操作进行加锁。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>Lambda 表达式提供了 Java 的函数化编程能力，取代了匿名内部类。让我们的代码量更少更美观。</li>
<li>Lambda表达式在Java中又称为闭包或匿名函数。</li>
<li>Stream API 提供了强大的集合操作。让我们在开发过程中更关心逻辑，而不是怎么详细的去实现。</li>
<li>stream 是串行的，线程安全的。parallelStream 是并行的，线程不安全的，在使用过程中尤其要注意。</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote>
<p><a href="http://www.runoob.com/java/java8-lambda-expressions.html" title="Java 8 Lambda 表达式 | 菜鸟教程">Java 8 Lambda 表达式 | 菜鸟教程</a><br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/index.html" title="Java 8 中的 Streams API 详解 | IBM Developer">Java 8 中的 Streams API 详解 | IBM Developer</a><br><a href="http://www.importnew.com/16436.html" title="Java 8 Lambda 表达式10个示例 | ImportNew">Java 8 Lambda 表达式10个示例 | ImportNew</a><br><a href="https://zhuanlan.zhihu.com/p/43039062" title="Java 8 parallelStream 浅析 | 知乎">Java 8 parallelStream 浅析 | 知乎</a><br><a href="https://www.cnblogs.com/puyangsky/p/7608741.html" title="Java 8 parallelStream 并发安全的思考 | puyangsky 博客园">Java 8 parallelStream 并发安全的思考 | puyangsky 博客园</a><br><a href="https://blog.csdn.net/u011001723/article/details/52794455" title="深入浅出 parallelStream | 梦铃之境的专栏">深入浅出 parallelStream | 梦铃之境的专栏</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2019/03/18/lambda/' title='Java 8 的 Lambda 表达式和 Stream API' >Java 8 的 Lambda 表达式和 Stream API</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2019/03/18/lambda/' title='Java 8 的 Lambda 表达式和 Stream API' >http://www.cylong.com/blog/2019/03/18/lambda/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>lambda</tag>
        <tag>流API</tag>
      </tags>
  </entry>
  <entry>
    <title>愚人节快乐</title>
    <url>/blog/2019/04/01/april-fools-day/</url>
    <content><![CDATA[<hr>
<p>事情起因是看到一个面试题，原题大概是，生成 N 个 1 到 1000 之间的随机数(N &lt;= 1000)，对于重复的数字，只取其中一个，并对结果进行从小到大排序。正好前几天了解了下 Java 的 Lambda 表达式和 Stream API，突然想起来，这可以一行代码搞定啊。于是就尝试的写了一下。【原题还是比较复杂的，我就提取了精华部分】</p>
<a id="more"></a>

<p>一行代码能搞定的事情从不会多写【为了美观我还是换行了】。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream.range(<span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">    .map(x -&gt; (<span class="keyword">int</span>)(Math.random() * <span class="number">1000</span> + <span class="number">1</span>))</span><br><span class="line">    .distinct()</span><br><span class="line">    .sorted()</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>自从 Java 8 增加了 Lambda 表达式和 Stream API 后，很多操作都非常的方便，可以参考我上一篇博客：</p>
<blockquote>
<p><a href="http://www.cylong.com/blog/2019/03/18/lambda/" title="Java 8 的 Lambda 表达式和 Stream API | 笑话人生">Java 8 的 Lambda 表达式和 Stream API | 笑话人生</a></p>
</blockquote>
<p><span style="background-color:#000000">其实这就是一篇愚人节凑数用的博客，顺便祝愿下女票可以找到心仪的实习，相信自己，努力终将不会白费 (^_^)</span></p>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2019/04/01/april-fools-day/' title='愚人节快乐' >愚人节快乐</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2019/04/01/april-fools-day/' title='愚人节快乐' >http://www.cylong.com/blog/2019/04/01/april-fools-day/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>随笔</tag>
        <tag>lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和</title>
    <url>/blog/2019/11/06/two-sum/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>给定 nums = [2, 7, 11, 15], target = 9<br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p>
</blockquote>
<a id="more"></a>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>使用哈希表将会使问题特别简单，首先，我们将使用一次遍历将数组中的元素加入到Map中，key是当前元素的值，value是当前元素的索引。接下来，我们进行第二次遍历，第二次遍历我们将查找当前元素的目标元素（target−nums[i]）是否在Map中，如果在，即找到目标值，返回两个元素的索引。注意一点的是，目标元素不能是当前元素！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, map.get(complement)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，我们把上面的两步合成一步，只用一次遍历即可完成，当遍历到第i个值后，我们把此元素的需要的目标值保存到Map中，后续遍历，找到目标的值，即完成遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(nums.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(nums[i])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(nums[i]), i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(target - nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/two-sum" title="两数之和 | 力扣（LeetCode）">两数之和 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-2/" title="两数之和 | 题解（LeetCode）">两数之和 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2019/11/06/two-sum/' title='两数之和' >两数之和</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2019/11/06/two-sum/' title='两数之和' >http://www.cylong.com/blog/2019/11/06/two-sum/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>哈希表</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>罗马数字转整数</title>
    <url>/blog/2019/11/07/roman-to-integer/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure>
<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li>
<li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li>
<li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<p><strong>示例 1:</strong></p>
<blockquote>
<p>输入: “III”<br>输出: 3</p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p>输入: “IV”<br>输出: 4</p>
</blockquote>
<p><strong>示例 3:</strong></p>
<blockquote>
<p>输入: “IX”<br>输出: 9</p>
</blockquote>
<p><strong>示例 4:</strong></p>
<blockquote>
<p>输入: “LVIII”<br>输出: 58<br>解释: L = 50, V= 5, III = 3.</p>
</blockquote>
<p><strong>示例 5:</strong></p>
<blockquote>
<p>输入: “MCMXCIV”<br>输出: 1994<br>解释: M = 1000, CM = 900, XC = 90, IV = 4.</p>
</blockquote>
<a id="more"></a>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>针对题目的对应关系我们首先构建一个Map，将罗马数字与整数的对应关系建立起来。根据题意，我们只需要将罗马字符一个一个转换成整数相加就行了。对于特例情况，当小数在大数的左边的时候，原本相加的操作，要变成相减操作。代码实现上，我们在处理当前数的时候，同时获取后面的一位数，如果大于当前数，则当前操作为减去当前的数，否则为加上当前的数。</p>
<img src="/blog/2019/11/07/roman-to-integer/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0.png" class="" title="罗马数字转整数">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Character, Integer&gt; kv = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">7</span>);</span><br><span class="line">    kv.put(<span class="string">&#x27;I&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">    kv.put(<span class="string">&#x27;V&#x27;</span>, <span class="number">5</span>);</span><br><span class="line">    kv.put(<span class="string">&#x27;X&#x27;</span>, <span class="number">10</span>);</span><br><span class="line">    kv.put(<span class="string">&#x27;L&#x27;</span>, <span class="number">50</span>);</span><br><span class="line">    kv.put(<span class="string">&#x27;C&#x27;</span>, <span class="number">100</span>);</span><br><span class="line">    kv.put(<span class="string">&#x27;D&#x27;</span>, <span class="number">500</span>);</span><br><span class="line">    kv.put(<span class="string">&#x27;M&#x27;</span>, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">char</span>[] roman = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; roman.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; roman.length &amp;&amp; kv.get(roman[i]) &lt; kv.get(roman[i + <span class="number">1</span>])) &#123;</span><br><span class="line">            result -= kv.get(roman[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result += kv.get(roman[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/roman-to-integer/" title="罗马数字转整数 | 力扣（LeetCode）">罗马数字转整数 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/roman-to-integer/solution/yong-shi-9993nei-cun-9873jian-dan-jie-fa-by-donesp/" title="罗马数字转整数 | 题解（LeetCode）">罗马数字转整数 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2019/11/07/roman-to-integer/' title='罗马数字转整数' >罗马数字转整数</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2019/11/07/roman-to-integer/' title='罗马数字转整数' >http://www.cylong.com/blog/2019/11/07/roman-to-integer/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>哈希表</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>两数相加</title>
    <url>/blog/2019/11/25/add-two-numbers/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p><strong>示例：</strong></p>
<blockquote>
<p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p>
</blockquote>
<a id="more"></a>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>由于各自的位数是按照逆序的方式存储的，所以我们只要一位一位进行加法就可以了，同时考虑溢出的情况，使用进位 carry 来表示。</p>
<img src="/blog/2019/11/25/add-two-numbers/add_two_numbers.svg" class="" title="两数相加图解">

<p>对于两个相加的链表，可能出现长度不一样的情况，这个时候，我们只要处理长的链表，单独加此链表的值即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> carry;</span><br><span class="line">    ListNode l3 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode l3_res = l3;</span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            l3.val += l2.val;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            l3.val += l1.val;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l3.val += (l1.val + l2.val);</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        carry = l3.val / <span class="number">10</span>;</span><br><span class="line">        l3.val = l3.val % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span> || carry == <span class="number">1</span>) &#123;</span><br><span class="line">            l3.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">            l3 = l3.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l3_res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外一种处理两个链表长度不一样的方法就是，我们就将短的链表补0，继续与长的链表相加即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode p = l1;</span><br><span class="line">    ListNode q = l2;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (q != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = carry + p.val + q.val;</span><br><span class="line">        p.val = sum % <span class="number">10</span>;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (p.next == <span class="keyword">null</span> &amp;&amp; q.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p.next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p.next != <span class="keyword">null</span> &amp;&amp; q.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            q.next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p.next == <span class="keyword">null</span> &amp;&amp; q.next == <span class="keyword">null</span> &amp;&amp; carry != <span class="number">0</span>) &#123;</span><br><span class="line">            p.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">        q = q.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：Ο(max(m,n))，假设 m 和 n 分别表示 l1 和 l2 的长度，上面的算法最多重复 max(m,n) 次。</li>
<li>空间复杂度：Ο(max(m,n))，新列表的长度最多为 max(m,n) + 1。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/add-two-numbers/" title="两数相加 | 力扣（LeetCode）">两数相加 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/add-two-numbers/solution/" title="两数相加 | 题解（LeetCode）">两数相加 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2019/11/25/add-two-numbers/' title='两数相加' >两数相加</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2019/11/25/add-two-numbers/' title='两数相加' >http://www.cylong.com/blog/2019/11/25/add-two-numbers/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>链表</tag>
        <tag>单向链表</tag>
      </tags>
  </entry>
  <entry>
    <title>无重复字符的最长子串</title>
    <url>/blog/2019/11/26/longest-substring-without-repeating-characters/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。</p>
<p><strong>示例 1:</strong></p>
<blockquote>
<p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p>
</blockquote>
<p><strong>示例 3:</strong></p>
<blockquote>
<p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br> 注意，你的答案必须是子串的长度，”pwke” 是一个子序列，不是子串。</p>
</blockquote>
<a id="more"></a>

<h1 id="队列实现"><a href="#队列实现" class="headerlink" title="队列实现"></a>队列实现</h1><p>本题是计算最长的不重复子串，而子串肯定是连续的。我们肯定都能想到，要遍历下输入的字符串，那么遍历的过程中，我们需要做什么呢？既然是计算字串的长度，那么我们遍历的过程中就要将字串保存下来。同时，每次保存新的字符的时候，需要判断原有的子串中是否包含了这个字符，如果包含了，那么我们要从字串的第一个字符开始，一直删除字符，直到不存在即将要加入的字符，然后计算当前子串的长度，与之前计算的长度比较，取较大值。拿 <code>abcdefce</code> 举例，我们遍历到第二个c字符的时候，已有的不含有重复字符的子串是 <code>abcdef</code> ，当要把c加入到已有的子串的时候，需要将前面的  <code>abc</code> 删除，那么新的子串为 <code>defc</code>。由于子串有后进后出的特性，于是我们使用队列来保存子串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring1</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    Queue&lt;Character&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> length = s.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        <span class="keyword">while</span> (queue.contains(c)) &#123;</span><br><span class="line">            queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        queue.offer(c);</span><br><span class="line">        count = Math.max(queue.size(), count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="双指针实现"><a href="#双指针实现" class="headerlink" title="双指针实现"></a>双指针实现</h1><p>双指针实现的思路和队列的实现一致，只不过使用两个指针i和j来指向子串的两端，判断 <code>s.substring(i, j)</code> 中是否包含当前的字符，若包含，则移动左指针i++，否则移动右指针j++。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s.length();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxLength = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; s.length()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!s.substring(i, j).contains(String.valueOf(s.charAt(j)))) &#123;</span><br><span class="line">            maxLength = Math.max(maxLength, j - i + <span class="number">1</span>);</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" title="无重复字符的最长子串 | 力扣（LeetCode）">无重复字符的最长子串 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetc-2/" title="无重复字符的最长子串 | 题解（LeetCode）">无重复字符的最长子串 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2019/11/26/longest-substring-without-repeating-characters/' title='无重复字符的最长子串' >无重复字符的最长子串</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2019/11/26/longest-substring-without-repeating-characters/' title='无重复字符的最长子串' >http://www.cylong.com/blog/2019/11/26/longest-substring-without-repeating-characters/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>链表</tag>
        <tag>指针</tag>
        <tag>双指针</tag>
        <tag>队列</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串转换整数</title>
    <url>/blog/2019/12/21/string-to-integer-atoi/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：</p>
<ul>
<li>如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。</li>
<li>假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。</li>
<li>该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。</li>
</ul>
<p><strong>注意：</strong> 假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。在任何情况下，若函数不能进行有效的转换时，请返回 0 。</p>
<p><strong>提示：</strong></p>
<ul>
<li>本题中的空白字符只包括空格字符 ‘ ‘ 。</li>
<li>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2³¹,  2³¹ − 1]。如果数值超过这个范围，请返回  INT_MAX (2³¹ − 1) 或 INT_MIN (−2³¹) 。
 </li>
</ul>
<p><strong>示例 1:</strong></p>
<blockquote>
<p>输入: “42”<br>输出: 42</p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p>输入: “   -42”<br>输出: -42<br>解释: 第一个非空白字符为 ‘-‘, 它是一个负号。我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</p>
</blockquote>
<p><strong>示例 3:</strong></p>
<blockquote>
<p>输入: “4193 with words”<br>输出: 4193<br>解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。</p>
</blockquote>
<p><strong>示例 4:</strong></p>
<blockquote>
<p>输入: “words and 987”<br>输出: 0<br>解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。因此无法执行有效的转换。</p>
</blockquote>
<p><strong>示例 5:</strong></p>
<blockquote>
<p>输入: “-91283472332”<br>输出: -2147483648<br>解释: 数字 “-91283472332” 超过 32 位有符号整数范围。因此返回 INT_MIN (−2³¹) 。</p>
</blockquote>
<a id="more"></a>

<h1 id="正常遍历"><a href="#正常遍历" class="headerlink" title="正常遍历"></a>正常遍历</h1><p>正常遍历字符串，首先去掉空格，然后用flag记录正负，接下来遍历字符串中的数字，不断的转换为整数，直到遍历到无用字符为止。考虑到溢出的情况。我们在计算result的时候，先判断计算后的值是否对int行溢出了，使用表达式 <code>(Integer.MAX_VALUE - (c - &#39;0&#39;)) * 1.0 / 10 &gt;= result</code> 判断即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    str = str.trim();</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (str.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str.charAt(<span class="number">0</span>) == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Character.isDigit(str.charAt(<span class="number">0</span>))) &#123;</span><br><span class="line">        result += str.charAt(<span class="number">0</span>) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str.charAt(<span class="number">0</span>) != <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = str.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (Character.isDigit(c)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((Integer.MAX_VALUE - (c - <span class="string">&#x27;0&#x27;</span>)) * <span class="number">1.0</span> / <span class="number">10</span> &gt;= result) &#123;</span><br><span class="line">                result = result * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> flag ? Integer.MIN_VALUE : Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag ? -result : result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(n)，其中 n 为字符串的长度。我们只需要依次处理所有的字符，处理每个字符需要的时间为 O(1)。</li>
<li>空间复杂度：Ο(1)。</li>
</ul>
<h1 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h1><p>针对有限状态机的学习还需要深入，先参考下官方的解答：<a href="https://leetcode-cn.com/problems/string-to-integer-atoi/solution/zi-fu-chuan-zhuan-huan-zheng-shu-atoi-by-leetcode-/" title="字符串转换整数 | 题解（LeetCode）">字符串转换整数 | 题解</a></p>
<p><strong>2020-09-04 更新</strong><br>时隔这么久，终于静下心来研究了下有限状态机的解法。有限状态机在遇到类似“判断一个字符串，是否满足某种规则”这种问题的时候，可以非常有条理的去解决。有限状态机的主要思想是，在程序运行的时候有一个状态 state，我们从当前输入中取出一个字符，根据当前字符的类型，转移到下一个状态。我们还需要定义一个初始状态和结束状态，这样我们只要建立一个覆盖所有状态的表格，就可以解决本题的问题。先看下官方题解的状态机：</p>
<img src="/blog/2019/12/21/string-to-integer-atoi/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA.png" class="" title="有限状态机">

<p>我们建立的表格如下（为了配合下面自己的代码，我把上面的状态做了微小修改）：</p>
<table>
<thead>
<tr>
<th align="center">状态\字符类型</th>
<th align="center">space</th>
<th align="center">+/-</th>
<th align="center">number</th>
<th align="center">other</th>
</tr>
</thead>
<tbody><tr>
<td align="center">space</td>
<td align="center">space</td>
<td align="center">sign</td>
<td align="center">number</td>
<td align="center">end</td>
</tr>
<tr>
<td align="center">sign</td>
<td align="center">end</td>
<td align="center">end</td>
<td align="center">number</td>
<td align="center">end</td>
</tr>
<tr>
<td align="center">number</td>
<td align="center">end</td>
<td align="center">end</td>
<td align="center">number</td>
<td align="center">end</td>
</tr>
<tr>
<td align="center">end</td>
<td align="center">end</td>
<td align="center">end</td>
<td align="center">end</td>
<td align="center">end</td>
</tr>
</tbody></table>
<p>接下来我们写代码只要构造这个 stateTable ，然后遍历字符串并不断更新状态即可。对于本题，我们要在遇到数字的时候进行计算，遇到符号的时候记录正负。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 记录当前状态，初始为空格状态</span></span><br><span class="line">State state = State.SPACE;</span><br><span class="line"><span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造表格，记录当前状态遇到某个类型字符可以转移到的下一个状态</span></span><br><span class="line">Map&lt;State, Map&lt;CharType, State&gt;&gt; stateTable = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    Map&lt;CharType, State&gt; spaceMap = <span class="keyword">new</span> HashMap&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">        put(CharType.SPACE, State.SPACE);</span><br><span class="line">        put(CharType.SIGN, State.SIGN);</span><br><span class="line">        put(CharType.NUMBER, State.NUMBER);</span><br><span class="line">        put(CharType.OTHER, State.END);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    Map&lt;CharType, State&gt; signMap = <span class="keyword">new</span> HashMap&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">        put(CharType.SPACE, State.END);</span><br><span class="line">        put(CharType.SIGN, State.END);</span><br><span class="line">        put(CharType.NUMBER, State.NUMBER);</span><br><span class="line">        put(CharType.OTHER, State.END);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    Map&lt;CharType, State&gt; numberMap = <span class="keyword">new</span> HashMap&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">        put(CharType.SPACE, State.END);</span><br><span class="line">        put(CharType.SIGN, State.END);</span><br><span class="line">        put(CharType.NUMBER, State.NUMBER);</span><br><span class="line">        put(CharType.OTHER, State.END);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    Map&lt;CharType, State&gt; otherMap = <span class="keyword">new</span> HashMap&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">        put(CharType.SPACE, State.END);</span><br><span class="line">        put(CharType.SIGN, State.END);</span><br><span class="line">        put(CharType.NUMBER, State.END);</span><br><span class="line">        put(CharType.OTHER, State.END);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    stateTable.put(State.SPACE, spaceMap);</span><br><span class="line">    stateTable.put(State.SIGN, signMap);</span><br><span class="line">    stateTable.put(State.NUMBER, numberMap);</span><br><span class="line">    stateTable.put(State.END, otherMap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : str.toCharArray()) &#123;</span><br><span class="line">        changeState(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)ans * sign;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeState</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    state = stateTable.get(state).get(getCharType(c));</span><br><span class="line">    <span class="keyword">if</span> (state == State.NUMBER) &#123;</span><br><span class="line">        ans = ans * <span class="number">10</span> + (c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        ans = sign == <span class="number">1</span> ? Math.min(ans, Integer.MAX_VALUE) : Math.min(ans, -(<span class="keyword">long</span>) Integer.MIN_VALUE);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == State.SIGN) &#123;</span><br><span class="line">        sign = c == <span class="string">&#x27;-&#x27;</span> ? -sign : sign;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> CharType <span class="title">getCharType</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> CharType.SPACE;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> CharType.SIGN;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Character.isDigit(c)) &#123;</span><br><span class="line">        <span class="keyword">return</span> CharType.NUMBER;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> CharType.OTHER;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> State &#123;</span><br><span class="line">    SPACE,</span><br><span class="line">    SIGN,</span><br><span class="line">    NUMBER,</span><br><span class="line">    END</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> CharType &#123;</span><br><span class="line">    SPACE,</span><br><span class="line">    SIGN,</span><br><span class="line">    NUMBER,</span><br><span class="line">    OTHER</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(n)，其中 n 为字符串的长度。我们只需要依次处理所有的字符，处理每个字符需要的时间为 O(1)。</li>
<li>空间复杂度：Ο(1)，自动机的状态只需要常数空间存储。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" title="字符串转换整数 | 力扣（LeetCode）">字符串转换整数 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/solution/zi-fu-chuan-zhuan-huan-zheng-shu-atoi-by-leetcode-/" title="字符串转换整数 | 题解（LeetCode）">字符串转换整数 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2019/12/21/string-to-integer-atoi/' title='字符串转换整数' >字符串转换整数</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2019/12/21/string-to-integer-atoi/' title='字符串转换整数' >http://www.cylong.com/blog/2019/12/21/string-to-integer-atoi/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>字符串</tag>
        <tag>整数</tag>
        <tag>有限状态机</tag>
      </tags>
  </entry>
  <entry>
    <title>Z 字形变换</title>
    <url>/blog/2019/12/30/zigzag-conversion/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L   C   I   R</span><br><span class="line">E T O E S I I G</span><br><span class="line">E   D   H   N</span><br></pre></td></tr></table></figure>
<p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。</p>
<p><strong>示例 1:</strong></p>
<blockquote>
<p>输入: s = “LEETCODEISHIRING”, numRows = 3<br>输出: “LCIRETOESIIGEDHN”</p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p>输入: s = “LEETCODEISHIRING”, numRows = 4<br>输出: “LDREOEIIECIHNTSG”</p>
</blockquote>
<p>解释:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L     D     R</span><br><span class="line">E   O E   I I</span><br><span class="line">E C   I H   N</span><br><span class="line">T     S     G</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先我们可以知道numRows为行数，输出的时候我们只要把每行的字符按顺序输出即可，其实上面的输出，为了美观，使用了空格，当我们把空格拿掉，就转换成了下面的输出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L C I R</span><br><span class="line">E T O E S I I G</span><br><span class="line">E D H N</span><br></pre></td></tr></table></figure>
<p>那么我们只要知道第i个字符，要放到哪一行即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numRows &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;List&lt;Character&gt;&gt; zList = <span class="keyword">new</span> ArrayList&lt;&gt;(numRows);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">        zList.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> j; <span class="comment">// 判断字符放到哪一行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        <span class="comment">// 多少字母为一个循环</span></span><br><span class="line">        <span class="keyword">int</span> cycle = numRows + numRows - <span class="number">2</span>;</span><br><span class="line">        j = i % cycle;</span><br><span class="line">        j = Math.min(cycle - j, j);</span><br><span class="line">        zList.get(j).add(c);</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder sBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">        zList.get(i).forEach(sBuilder::append);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sBuilder.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>官方解法和我的思路差不多，只不过他细节上处理的比我好，行数是 <code>numRows</code> 和 <code>len(s)</code> 的较小值，其每行数据没有使用<code>List&lt;Character&gt;</code>，而是使用StringBuilder，另外使用了方向变量<code>goingDown</code>来判断此时在哪一行。以下是官方解法：</p>
<p>我们可以使用 <code>min(numRows, len(s))</code> 个列表来表示 Z 字形图案中的非空行。从左到右迭代 s，将每个字符添加到合适的行。可以使用当前行和当前方向这两个变量对合适的行进行跟踪。只有当我们向上移动到最上面的行或向下移动到最下面的行时，当前方向才会发生改变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numRows == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    List&lt;StringBuilder&gt; rows = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Math.min(numRows, s.length()); i++)</span><br><span class="line">        rows.add(<span class="keyword">new</span> StringBuilder());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> curRow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> goingDown = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">        rows.get(curRow).append(c);</span><br><span class="line">        <span class="keyword">if</span> (curRow == <span class="number">0</span> || curRow == numRows - <span class="number">1</span>)</span><br><span class="line">            goingDown = !goingDown;</span><br><span class="line">        curRow += goingDown ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StringBuilder ret = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (StringBuilder row : rows)</span><br><span class="line">        ret.append(row);</span><br><span class="line">    <span class="keyword">return</span> ret.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/zigzag-conversion/" title="Z 字形变换 | 力扣（LeetCode）">Z 字形变换 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/zigzag-conversion/solution/z-zi-xing-bian-huan-by-leetcode/" title="Z 字形变换 | 题解（LeetCode）">Z 字形变换 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2019/12/30/zigzag-conversion/' title='Z 字形变换' >Z 字形变换</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2019/12/30/zigzag-conversion/' title='Z 字形变换' >http://www.cylong.com/blog/2019/12/30/zigzag-conversion/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>字符串</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>整数反转</title>
    <url>/blog/2020/01/04/reverse-integer/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<p><strong>示例 1:</strong></p>
<blockquote>
<p>输入: 123<br>输出: 321</p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p>输入: -123<br>输出: -321</p>
</blockquote>
<p><strong>示例 3:</strong></p>
<blockquote>
<p>输入: 120<br>输出: 21</p>
</blockquote>
<p><strong>注意:</strong><br>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2³¹,  2³¹ − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p>
<a id="more"></a>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>根据题意，我们定义返回值为res，初始为0，我们对入参不断的进行 <code>x % 10</code> 操作，这样就会倒序取得每一位数，同时做 <code>x /= 10</code> 操作更新x的值，针对res，我们每次需要做 <code>res * 10 + x % 10</code> 操作，这样就对x进行了反转。考虑到溢出的情况，我们这边投机取巧，将res定义为long类型，这样int类型的整数就不会溢出。最后判断反转的值是否对int型数溢出即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        res = res * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res &gt; Integer.MAX_VALUE || res &lt; Integer.MIN_VALUE) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果res使用int型，那么我们需要在处理 <code>res = res * 10 + x % 10;</code>之前判断整数是否溢出。通过判断 <code>(Integer.MAX_VALUE - x % 10) * 1.0 / 10 &gt;= res</code>即可，针对负数同理。</p>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(logn)，对于每次迭代，我们会将输入除以 10，因此时间复杂度为 O(logn)，也可以理解为输入的整数的位数。</li>
<li>空间复杂度：Ο(1)。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/reverse-integer/" title="整数反转 | 力扣（LeetCode）">整数反转 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/reverse-integer/solution/zheng-shu-fan-zhuan-by-leetcode/" title="整数反转 | 题解（LeetCode）">整数反转 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/01/04/reverse-integer/' title='整数反转' >整数反转</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/01/04/reverse-integer/' title='整数反转' >http://www.cylong.com/blog/2020/01/04/reverse-integer/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>整数</tag>
      </tags>
  </entry>
  <entry>
    <title>回文数</title>
    <url>/blog/2020/01/10/palindrome-number/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<p><strong>示例 1:</strong></p>
<blockquote>
<p>输入: 121<br>输出: true</p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p>输入: -121<br>输出: false<br>解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</p>
</blockquote>
<p><strong>示例 3:</strong></p>
<blockquote>
<p>输入: 10<br>输出: false<br>解释: 从右向左读, 为 01 。因此它不是一个回文数。</p>
</blockquote>
<a id="more"></a>

<p>针对输入是负数的情况下，一定不是回文数，因为没有整数是以负号结尾的。接下来考虑，既然回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。那么我们将整数反转，判断反转后的数和原来的数是否相等，就可以判断此整数是否是回文数。关于整数反转的操作，可以参考另外一道Leetcode题目：<a href="/blog/2020/01/04/reverse-integer/" title="整数反转">整数反转</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> origin = x;</span><br><span class="line">    <span class="comment">// 使用long防止整数反转溢出</span></span><br><span class="line">    <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        result = result * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">        x = x / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若反转后的值溢出，则一定不是回文数</span></span><br><span class="line">    <span class="keyword">if</span> (result &gt; Integer.MAX_VALUE || result &lt; Integer.MIN_VALUE) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) result == origin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>考虑到反转溢出的情况，若整数反转后溢出，那么肯定原来的值和反转后的值不相等，也就是说其实我们上面并不需要特意的去判断反转后的整数是否溢出，于是代码优化如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> origin = x;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        result = result * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">        x = x / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result == origin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(logn)，对于每次迭代，我们会将输入除以 10，因此时间复杂度为 O(logn)，也可以理解为输入的整数的位数。</li>
<li>空间复杂度：Ο(1)。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/palindrome-number/" title="回文数 | 力扣（LeetCode）">回文数 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/palindrome-number/solution/hui-wen-shu-by-leetcode-solution/" title="回文数 | 题解（LeetCode）">回文数 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/01/10/palindrome-number/' title='回文数' >回文数</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/01/10/palindrome-number/' title='回文数' >http://www.cylong.com/blog/2020/01/10/palindrome-number/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>整数</tag>
      </tags>
  </entry>
  <entry>
    <title>盛最多水的容器</title>
    <url>/blog/2020/01/16/container-with-most-water/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p><strong>说明：</strong> 你不能倾斜容器，且 n 的值至少为 2。</p>
<img src="/blog/2020/01/16/container-with-most-water/%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8%E6%8F%8F%E8%BF%B0.jpg" class="" title="盛水最多的容器">

<p>图中垂直线代表输入数组 [1, 8, 6, 2, 5, 4, 8, 3, 7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p>
<p><strong>示例：</strong></p>
<blockquote>
<p>输入：[1, 8, 6, 2, 5, 4, 8, 3, 7]<br>输出：49</p>
</blockquote>
<a id="more"></a>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>通过题目描述的图中可以容易看出来，我们既然想盛更多的水，那么我们需要让垂直x轴的两条线尽量的高，也让这两条线距离尽量的远。两条线最大的距离就是数组的长度，于是我们使用双指针 <code>i，j 且 i &lt; j</code> 分别指向数组的两端，作为初始的容器大小 <code>Math.min(height[i], height[j]) * (j - i)</code>。接下来，我们就要移动左右指针，移动哪个呢？我们直觉上，要移动指针指的值较小的一个。因为我们既然移动了指针，那么肯定会让 <code>j - i</code> 变小，那么如果我们想要让容器盛水更多，那么肯定要让 <code>Math.min(height[i], height[j])</code> 更大才行。否则如果我们移动指针指的值较大的一个，那么最后计算出来的 <code>Math.min(height[i], height[j])</code> 肯定小于等于原有的值，那么盛水也将小于等于原有的值。我们不需要这样的结果。最后，我们只要取每次指针移动后，计算值中最大的值，即为盛水的最大值。更详细的介绍可以参考<a href="https://leetcode-cn.com/problems/container-with-most-water/solution/sheng-zui-duo-shui-de-rong-qi-by-leetcode-solution/" title="盛最多水的容器 | 题解（LeetCode）">Leetcode官方题解</a>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (height == <span class="keyword">null</span> || height.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = height.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        result = Math.max(Math.min(height[i], height[j]) * (j - i), result);</span><br><span class="line">        <span class="keyword">if</span> (height[i] &lt; height[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下只是看到了有大佬写的更简单的代码，拿来学习下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (height == <span class="keyword">null</span> || height.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = height.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">int</span> minH = height[i] &lt; height[j] ? height[i++] : height[j--];</span><br><span class="line">        result = Math.max(minH * (j - i + <span class="number">1</span>), result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(N)，双指针总计最多遍历整个数组一次。</li>
<li>空间复杂度：O(1)，只需要额外的常数级别的空间。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/container-with-most-water/" title="盛最多水的容器 | 力扣（LeetCode）">盛最多水的容器 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/container-with-most-water/solution/sheng-zui-duo-shui-de-rong-qi-by-leetcode-solution/" title="盛最多水的容器 | 题解（LeetCode）">盛最多水的容器 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/01/16/container-with-most-water/' title='盛最多水的容器' >盛最多水的容器</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/01/16/container-with-most-water/' title='盛最多水的容器' >http://www.cylong.com/blog/2020/01/16/container-with-most-water/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>数组</tag>
        <tag>指针</tag>
        <tag>双指针</tag>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title>拼写单词</title>
    <url>/blog/2020/03/17/find-words-that-can-be-formed-by-characters/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。返回词汇表 words 中你掌握的所有单词的长度之和。</p>
<p><strong>注意：每次拼写（指拼写词汇表中的一个单词）时，chars 中的每个字母都只能用一次。</strong></p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：words = [“cat”, “bt”, “hat”, “tree”], chars = “atach”<br>输出：6<br>解释：可以形成字符串 “cat” 和 “hat”，所以答案是 3 + 3 = 6。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：words = [“hello”, “world”, “leetcode”], chars = “welldonehoneyr”<br>输出：10<br>解释：可以形成字符串 “hello” 和 “world”，所以答案是 5 + 5 = 10。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= words.length &lt;= 1000</li>
<li>1 &lt;= words[i].length, chars.length &lt;= 100</li>
<li>所有字符串中都仅包含小写英文字母</li>
</ul>
<a id="more"></a>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>最简单的方法，暴力方法，我们遍历全部的word，判断word的中的所有字符是否都在chars中存在，同时我们标记下已经被记录的字符，防止重复使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countCharacters</span><span class="params">(String[] words, String chars)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] charArr = chars.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">        <span class="comment">// 判断chars中是否包含word</span></span><br><span class="line">        <span class="keyword">if</span> (findWord(word, charArr)) &#123;</span><br><span class="line">            length += word.length();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findWord</span><span class="params">(String word, <span class="keyword">char</span>[] charArr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[charArr.length];</span><br><span class="line">    <span class="keyword">char</span>[] wordArr = word.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wordArr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 从chars中找到word中的字符</span></span><br><span class="line">        <span class="keyword">if</span> (!findChar(wordArr[i], charArr, flag)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findChar</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">char</span>[] charArr, <span class="keyword">boolean</span>[] flag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; charArr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (charArr[i] == c &amp;&amp; !flag[i]) &#123;</span><br><span class="line">            <span class="comment">// 保证每个字符只用到一次</span></span><br><span class="line">            flag[i] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：Ο(M x N)，M为words中所有字符数，N为chars字符数。</li>
</ul>
<h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><p>显然，对于一个单词 word，只要其中的每个字母的数量都不大于 chars 中对应的字母的数量，那么就可以用 chars 中的字母拼写出 word。由于题目中的限制条件是小写英文字母，所以我们只要使用int[26]数组，分别保存字母表中的字母出现次数和word中字母出现的次数即可。</p>
<img src="/blog/2020/03/17/find-words-that-can-be-formed-by-characters/%E5%9B%BE%E8%A7%A3.gif" class="" title="统计字母出现次数">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countCharacters</span><span class="params">(String[] words, String chars)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 统计字母表中字符出现的次数</span></span><br><span class="line">    <span class="keyword">int</span>[] charNum = getCharNum(chars);</span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">        <span class="comment">// 统计word中字符出现的次数</span></span><br><span class="line">        <span class="keyword">int</span>[] wordNum = getCharNum(word);</span><br><span class="line">        <span class="keyword">if</span> (isContain(charNum, wordNum)) &#123;</span><br><span class="line">            len += word.length();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isContain</span><span class="params">(<span class="keyword">int</span>[] charNum, <span class="keyword">int</span>[] wordNum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wordNum.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 判断如果word中的字符数大于chars中的字符数，则无法拼写单词</span></span><br><span class="line">        <span class="keyword">if</span> (charNum[i] &lt; wordNum[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] getCharNum(String word) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] charNum = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">        charNum[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> charNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：Ο(n)，其中 n 为所有字符串的长度和。我们需要遍历每个字符串，包括 chars 以及数组 words 中的每个单词。</li>
<li>空间复杂度：Ο(S)，其中 S 为字符集大小，在本题中 S 的值为 26（所有字符串仅包含小写字母）。程序运行过程中，最多同时存在两个统计字符数的数组，使用的空间均不超过字符集大小 S，因此空间复杂度为 O(S)。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters/" title="二叉搜索树的第k大节点 | 力扣（LeetCode）">拼写单词 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters/solution/tong-ji-zi-mu-chu-xian-de-ci-shu-shu-zu-ji-qiao-cj/" title="二叉搜索树的第k大节点 | 题解（LeetCode）">拼写单词 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/03/17/find-words-that-can-be-formed-by-characters/' title='拼写单词' >拼写单词</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/03/17/find-words-that-can-be-formed-by-characters/' title='拼写单词' >http://www.cylong.com/blog/2020/03/17/find-words-that-can-be-formed-by-characters/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>数组</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>根据身高重建队列</title>
    <url>/blog/2020/04/09/queue-reconstruction-by-height/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。</p>
<p><strong>注意：</strong> 总人数少于1100人。</p>
<p><strong>示例</strong></p>
<blockquote>
<p>输入: [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]<br>输出: [[5, 0], [7, 0], [5, 2], [6, 1], [4, 4], [7, 1]]</p>
</blockquote>
<a id="more"></a>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>让我们从最简单的情况下思考，当队列中所有人的 (h, k) 都是相同的高度 h，只有 k 不同时，解决方案很简单：每个人在队列的索引 index = k。</p>
<img src="/blog/2020/04/09/queue-reconstruction-by-height/%E6%89%80%E6%9C%89%E4%BA%BA%E7%AD%89%E9%AB%98.jpg" class="" title="所有人等高的情况">

<p>即使不是所有人都是同一高度，这个策略也是可行的。因为个子矮的人相对于个子高的人是 “看不见” 的，所以可以先安排个子高的人。下图中我们先安排身高为 7 的人，将它放置在与 k 值相等的索引上；再安排身高为 6 的人，同样的将它放置在与 k 值相等的索引上。</p>
<img src="/blog/2020/04/09/queue-reconstruction-by-height/%E4%B8%8D%E7%AD%89%E9%AB%98.jpg" class="" title="不等高的情况">

<p>该策略可以递归进行：</p>
<ul>
<li>将最高的人按照 k 值升序排序，然后将它们放置到输出队列中与 k 值相等的索引位置上。</li>
<li>按降序取下一个高度，同样按 k 值对该身高的人升序排序，然后逐个插入到输出队列中与 k 值相等的索引位置上。</li>
<li>直到完成为止。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] reconstructQueue(<span class="keyword">int</span>[][] people) &#123;</span><br><span class="line">    <span class="comment">// 按照高度降序排列，同高度的人，按照k值升序排列。</span></span><br><span class="line">    Arrays.sort(people, (o1, o2) -&gt; o1[<span class="number">0</span>] == o2[<span class="number">0</span>] ? o1[<span class="number">1</span>] - o2[<span class="number">1</span>] : o2[<span class="number">0</span>] - o1[<span class="number">0</span>]);</span><br><span class="line">    LinkedList&lt;<span class="keyword">int</span>[]&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 逐个地把它们放在输出队列中，索引等于它们的 k 值。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] person : people) &#123;</span><br><span class="line">        list.add(person[<span class="number">1</span>], person);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[list.size()][]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(N²)，排序使用了 O(NlogN) 的时间，每个人插入到输出队列中需要 O(k) 的时间，其中 k 是当前输出队列的元素个数。总共的时间复杂度为O(N²)。</li>
<li>空间复杂度：O(N)，输出队列使用的空间。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/" title="根据身高重建队列 | 力扣（LeetCode）">根据身高重建队列 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/solution/gen-ju-shen-gao-zhong-jian-dui-lie-by-leetcode/" title="根据身高重建队列 | 题解（LeetCode）">根据身高重建队列 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/04/09/queue-reconstruction-by-height/' title='根据身高重建队列' >根据身高重建队列</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/04/09/queue-reconstruction-by-height/' title='根据身高重建队列' >http://www.cylong.com/blog/2020/04/09/queue-reconstruction-by-height/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>数组</tag>
        <tag>链表</tag>
        <tag>贪心算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>打家劫舍</title>
    <url>/blog/2020/05/29/house-robber/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。偷窃到的最高金额 = 1 + 3 = 4 。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：[2,7,9,3,1]<br>输出：12<br>解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。偷窃到的最高金额 = 2 + 9 + 1 = 12 。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>0 &lt;= nums.length &lt;= 100</li>
<li>0 &lt;= nums[i] &lt;= 400</li>
</ul>
<a id="more"></a>

<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>对于此题，我们从起始位置，第一家开始出发，有两种情况，偷第一家，跳过第二家，然后从第三家开始继续选择（偷第三家或者第四家）；或者偷第二家，然后从第四家开始选择（偷第四家或者第五家）。选择两种情况的最大值。之后递归处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>] + rob(nums, <span class="number">2</span>), nums[<span class="number">1</span>] + rob(nums, <span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[index];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &gt; nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(nums[index] + rob(nums, index + <span class="number">2</span>), nums[index + <span class="number">1</span>] + rob(nums, index + <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是一个最容易理解的解法，但是会超时，原因是，描述中我们可以发现，两种情况都会计算从第四家开始偷的情况。后面递归也是一样的，导致了大量的重复计算。于是我们进行优化，使用 <code>int[] money</code> 数组表示从第i家计算能偷的最大值，递归的时候，同时记录递归中间值，这样我们当有重复计算的时候，比如上面所说的第二种情况偷第四家的时候，可以使用第一种情况计算好的从第四家开始偷的最大值。避免了重复递归计算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] money = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    money = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    Arrays.fill(money, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>] + rob(nums, <span class="number">2</span>), nums[<span class="number">1</span>] + rob(nums, <span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[index];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &gt; nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        money[index] = money[index] == -<span class="number">1</span> ? nums[index] + rob(nums, index + <span class="number">2</span>) : money[index];</span><br><span class="line">        money[index + <span class="number">1</span>] = money[index + <span class="number">1</span>] == -<span class="number">1</span> ? nums[index + <span class="number">1</span>] + rob(nums, index + <span class="number">3</span>) : money[index + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> Math.max(money[index], money[index + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>首先考虑最简单的情况。如果只有一间房屋，则偷窃该房屋，可以偷窃到最高总金额。如果只有两间房屋，则由于两间房屋相邻，不能同时偷窃，只能偷窃其中的一间房屋，因此选择其中金额较高的房屋进行偷窃，可以偷窃到最高总金额。如果房屋数量大于两间，应该如何计算能够偷窃到的最高总金额呢？对于第 k (k &gt; 2) 间房屋，有两个选项：</p>
<ol>
<li>偷窃第 k 间房屋，那么就不能偷窃第 k−1 间房屋，偷窃总金额为前 k−2 间房屋的最高总金额与第 k 间房屋的金额之和。</li>
<li>不偷窃第 k 间房屋，偷窃总金额为前 k−1 间房屋的最高总金额。</li>
</ol>
<p>在两个选项中选择偷窃总金额较大的选项，该选项对应的偷窃总金额即为前 k 间房屋能偷窃到的最高总金额。用 dp[i] 表示前 i 间房屋能偷窃到的最高总金额，那么就有如下的状态转移方程：</p>
<blockquote>
<p>dp[i] = max(dp[i − 2] + nums[i], dp[i − 1])</p>
</blockquote>
<p>边界条件为：</p>
<blockquote>
<p>dp[0]=nums[0] 只有一间房屋，则偷窃该房屋<br>dp[1]=max(nums[0], nums[1]) 只有两间房屋，选择其中金额较高的房屋进行偷窃</p>
</blockquote>
<p>最终的答案即为 dp[n − 1]，其中 n 是数组的长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> length = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; length; i++) &#123;</span><br><span class="line">        dp[i] = Math.max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述方法使用了数组存储结果。考虑到每间房屋的最高总金额只和该房屋的前两间房屋的最高总金额相关，因此可以使用滚动数组，在每个时刻只需要存储前两间房屋的最高总金额。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> length = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> first = nums[<span class="number">0</span>], second = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = second;</span><br><span class="line">        second = Math.max(first + nums[i], second);</span><br><span class="line">        first = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/house-robber/" title="打家劫舍 | 力扣（LeetCode）">打家劫舍 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/house-robber/solution/da-jia-jie-she-by-leetcode-solution/" title="打家劫舍 | 题解（LeetCode）">打家劫舍 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/05/29/house-robber/' title='打家劫舍' >打家劫舍</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/05/29/house-robber/' title='打家劫舍' >http://www.cylong.com/blog/2020/05/29/house-robber/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>递归</tag>
        <tag>记忆化</tag>
        <tag>动态规划</tag>
        <tag>滚动数组</tag>
      </tags>
  </entry>
  <entry>
    <title>三数之和</title>
    <url>/blog/2020/05/30/three-sum/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c，使得 a + b + c = 0？请你找出所有满足条件且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>给定数组 nums = [-1, 0, 1, 2, -1, -4]，<br>满足要求的三元组集合为：<br>[[-1, 0, 1], [-1, -1, 2]]</p>
</blockquote>
<a id="more"></a>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p> 之前做过<a href="https://leetcode-cn.com/problems/two-sum" title="两数之和 | 力扣（LeetCode）">两数之和</a>这道题，所以第一想法就是转化成两次两数之和解决，思路就是先求 b + c 两数之和 z，再求 a + z 两数之和等于0，也就是相反数。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 求出两数之和的组合，和为-nums[i]</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; twoSumList = twoSum(nums, i + <span class="number">1</span>, -nums[i]);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; list : twoSumList) &#123;</span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">            Collections.sort(list);</span><br><span class="line">            result.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.stream().distinct().collect(Collectors.toList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; nums.length; i++) &#123;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">            list.add(nums[map.get(complement)]);</span><br><span class="line">            result.add(list);</span><br><span class="line">            <span class="comment">// 去重，防止重复执行超时</span></span><br><span class="line">            map.remove(nums[i]);</span><br><span class="line">            map.remove(complement);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 其实这道题有更好的解法，受之前两数之和的影响，两数之和的那道题，是没法给数组排序的，因为输出是数组下标，而这道题，输出是三元组，可以进行数组排序的，以下是来自LeetCode的题解：</p>
<ul>
<li><p>首先对数组进行排序，排序后固定一个数 nums[i]，再使用左右指针指向 nums[i] 后面的两端，数字分别为 nums[L] 和 nums[R]，计算三个数的和 sum 判断是否满足为 0，满足则添加进结果集。</p>
</li>
<li><p>如果 nums[i]大于 0，则三数之和必然无法等于 0，结束循环。</p>
</li>
<li><p>如果 nums[i] == nums[i−1]，则说明该数字重复，会导致结果重复，所以应该跳过。</p>
</li>
<li><p>当 sum == 0 时，nums[L] == nums[L+1] 则会导致结果重复，应该跳过，L++。</p>
</li>
<li><p>当 sum == 0 时，nums[R] == nums[R−1] 则会导致结果重复，应该跳过，R−−。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">   List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   <span class="keyword">int</span> len = nums.length;</span><br><span class="line">   <span class="keyword">if</span> (nums == <span class="keyword">null</span> || len &lt; <span class="number">3</span>)</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   Arrays.sort(nums);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">       <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">break</span>; <span class="comment">// 如果当前数字大于0，则三数之和一定大于0，所以结束循环</span></span><br><span class="line">       <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">           <span class="keyword">continue</span>; <span class="comment">// 去重</span></span><br><span class="line">       <span class="keyword">int</span> L = i + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> R = len - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">           <span class="keyword">int</span> sum = nums[i] + nums[L] + nums[R];</span><br><span class="line">           <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">               res.add(Arrays.asList(nums[i], nums[L], nums[R]));</span><br><span class="line">               <span class="keyword">while</span> (L &lt; R &amp;&amp; nums[L] == nums[L + <span class="number">1</span>])</span><br><span class="line">                   L++; <span class="comment">// 去重</span></span><br><span class="line">               <span class="keyword">while</span> (L &lt; R &amp;&amp; nums[R] == nums[R - <span class="number">1</span>])</span><br><span class="line">                   R--; <span class="comment">// 去重</span></span><br><span class="line">               L++;</span><br><span class="line">               R--;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>)</span><br><span class="line">               L++;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>)</span><br><span class="line">               R--;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/3sum" title="三数之和 | 力扣（LeetCode）">三数之和 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/3sum/solution/hua-jie-suan-fa-15-san-shu-zhi-he-by-guanpengchn/" title="三数之和 | 题解（LeetCode）">三数之和 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/05/30/three-sum/' title='三数之和' >三数之和</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/05/30/three-sum/' title='三数之和' >http://www.cylong.com/blog/2020/05/30/three-sum/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>数组</tag>
        <tag>双指针</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>拥有最多糖果的孩子</title>
    <url>/blog/2020/06/01/kids-with-the-greatest-number-of-candies/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个数组 candies 和一个整数 extraCandies ，其中 candies[i] 代表第 i 个孩子拥有的糖果数目。对每一个孩子，检查是否存在一种方案，将额外的 extraCandies 个糖果分配给孩子们之后，此孩子有最 的糖果。<br><strong>注意：</strong> 允许有多个孩子同时拥有最多的糖果数目。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：candies = [2, 3, 5, 1, 3], extraCandies = 3<br>输出：[true, true, true, false, true]<br>解释：<br>孩子 1 有 2 个糖果，如果他得到所有额外的糖果（3个），那么他总共有 5 个糖果，他将成为拥有最多糖果的孩子。<br>孩子 2 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。<br>孩子 3 有 5 个糖果，他已经是拥有最多糖果的孩子。<br>孩子 4 有 1 个糖果，即使他得到所有额外的糖果，他也只有 4 个糖果，无法成为拥有糖果最多的孩子。<br>孩子 5 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：candies = [4, 2, 1, 1, 2], extraCandies = 1<br>输出：[true, false, false, false, false]<br>解释：只有 1 个额外糖果，所以不管额外糖果给谁，只有孩子 1 可以成为拥有糖果最多的孩子。</p>
</blockquote>
<p><strong>示例 3：</strong></p>
<blockquote>
<p>输入：candies = [12, 1, 12], extraCandies = 10<br>输出：[true, false, true]</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>2 &lt;= candies.length &lt;= 100</li>
<li>1 &lt;= candies[i] &lt;= 100</li>
<li>1 &lt;= extraCandies &lt;= 50</li>
</ul>
<a id="more"></a>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>我们只要先遍历一遍小朋友拥有的糖果数，找出最大值，然后再遍历一次小朋友的糖果数，加上额外的糖果，是否大于等于之前求出的最大值即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Boolean&gt; <span class="title">kidsWithCandies</span><span class="params">(<span class="keyword">int</span>[] candies, <span class="keyword">int</span> extraCandies)</span> </span>&#123;</span><br><span class="line">    OptionalInt max = Arrays.stream(candies).max();</span><br><span class="line">    List&lt;Boolean&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : candies) &#123;</span><br><span class="line">        result.add(num + extraCandies &gt;= max.getAsInt());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此题使用了Java流API <code>Arrays.stream(candies).max()</code>，可以很方便的处理集合或者数组相关的问题，比如数组求和，求最大值等等。关于流API的介绍可以参考：</p>
<blockquote>
<p><a href="/blog/2019/03/18/lambda/" title="Java 8 的 Lambda 表达式和 Stream API">Java 8 的 Lambda 表达式和 Stream API</a></p>
</blockquote>
<p>另外此题是六一儿童节LeetCode的每日一题，官方是想让我们过一个快乐的六一啊，在这里也祝各位大孩子们六一儿童节快乐^o^/</p>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(n)，我们首先使用 O(n) 的时间预处理出所有小朋友拥有的糖果数目最大值。对于每一个小朋友，我们需要 O(1) 的时间判断这个小朋友是否可以拥有最多的糖果，故渐进时间复杂度为 O(n)。</li>
<li>空间复杂度：Ο(1)。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies/" title="拥有最多糖果的孩子 | 力扣（LeetCode）">拥有最多糖果的孩子 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies/solution/yong-you-zui-duo-tang-guo-de-hai-zi-by-leetcode-so/" title="拥有最多糖果的孩子 | 题解（LeetCode）">拥有最多糖果的孩子 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/06/01/kids-with-the-greatest-number-of-candies/' title='拥有最多糖果的孩子' >拥有最多糖果的孩子</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/06/01/kids-with-the-greatest-number-of-candies/' title='拥有最多糖果的孩子' >http://www.cylong.com/blog/2020/06/01/kids-with-the-greatest-number-of-candies/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>流API</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>数组</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>求1-n的和</title>
    <url>/blog/2020/06/03/qiu-12n-lcof/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入: n = 3<br>输出: 6</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入: n = 9<br>输出: 45</p>
</blockquote>
<p><strong>限制：</strong></p>
<blockquote>
<p>1 &lt;= n &lt;= 10000</p>
</blockquote>
<a id="more"></a>

<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>由于题目限制了很多，其中比较常用的for循环方法也被禁用，那么不用for循环，最容易想到的就是递归，于是我们很容易就能写出递归的版本</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">0</span> ? <span class="number">0</span> : n + sumNums(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是题目要求不允许使用条件判断语句，那么我们是否能使用别的办法来确定递归出口呢？答案就是逻辑运算符的短路性质。以逻辑运算符 &amp;&amp; 为例，对于 A &amp;&amp; B 这个表达式，如果 A 表达式返回 false ，那么 A &amp;&amp; B 已经确定为 false ，此时不会去执行表达式 B。同理，对于逻辑运算符 ||， 对于 A || B 这个表达式，如果 A 表达式返回 true ，那么 A || B 已经确定为 true ，此时不会去执行表达式 B。</p>
<p>利用这一特性，我们可以将判断是否为递归的出口看作 A &amp;&amp; B 表达式中的 A 部分，递归的主体函数看作 B 部分。如果不是递归出口，则返回 true，并继续执行表达式 B 的部分，否则递归结束。当然，你也可以用逻辑运算符 || 给出类似的实现，这里我们只提供结合逻辑运算符 &amp;&amp; 的递归实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> flag = n &gt; <span class="number">0</span> &amp;&amp; (n += sumNums(n - <span class="number">1</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(n)，递归函数递归 n 次，每次递归中计算时间复杂度为 O(1)，因此总时间复杂度为 O(n)。</li>
<li>空间复杂度：Ο(n)，递归函数的空间复杂度取决于递归调用栈的深度，这里递归函数调用栈深度为 O(n)，因此空间复杂度为 O(n)。</li>
</ul>
<h1 id="Java流API"><a href="#Java流API" class="headerlink" title="Java流API"></a>Java流API</h1><p>其实这种数学计算，包含求和，求大小等等操作，Java引入很多方便的方法，此题使用了Java流API <code>IntStream.range(1, n + 1).sum()</code>，求指定范围的整数和。关于流API的介绍可以参考：</p>
<blockquote>
<p><a href="/blog/2019/03/18/lambda/" title="Java 8 的 Lambda 表达式和 Stream API">Java 8 的 Lambda 表达式和 Stream API</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> IntStream.range(<span class="number">1</span>, n + <span class="number">1</span>).sum();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/" title="求1-n的和 | 力扣（LeetCode）">求1-n的和 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/solution/qiu-12n-by-leetcode-solution/" title="求1-n的和 | 题解（LeetCode）">求1-n的和 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/06/03/qiu-12n-lcof/' title='求1-n的和' >求1-n的和</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/06/03/qiu-12n-lcof/' title='求1-n的和' >http://www.cylong.com/blog/2020/06/03/qiu-12n-lcof/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>流API</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>递归</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>顺时针打印矩阵</title>
    <url>/blog/2020/06/05/shun-shi-zhen-da-yin-ju-zhen-lcof/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]<br>输出：[1, 2, 3, 6, 9, 8, 7, 4, 5]</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]<br>输出：[1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]</p>
</blockquote>
<p><strong>限制：</strong></p>
<blockquote>
<p>0 &lt;= matrix.length &lt;= 100<br>0 &lt;= matrix[i].length &lt;= 100</p>
</blockquote>
<a id="more"></a>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>可以模拟打印矩阵的路径。初始位置是矩阵的左上角，初始方向是向右，当路径超出界限或者进入之前访问过的位置时，则顺时针旋转，进入下一个方向。判断路径是否进入之前访问过的位置需要使用一个与输入矩阵大小相同的辅助矩阵 visited，其中的每个元素表示该位置是否被访问过。当一个元素被访问时，将 visited 中的对应位置的元素设为已访问。</p>
<p>如何判断路径是否结束？由于矩阵中的每个元素都被访问一次，因此路径的长度即为矩阵中的元素数量，当路径的长度达到矩阵中的元素数量时即为完整路径，将该路径返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> rows = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> columns = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">// 判断路径是否被访问过</span></span><br><span class="line">    <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][columns];</span><br><span class="line">    <span class="keyword">int</span> total = rows * columns;</span><br><span class="line">    <span class="comment">// 总路径长度为矩阵的元素数量</span></span><br><span class="line">    <span class="keyword">int</span>[] order = <span class="keyword">new</span> <span class="keyword">int</span>[total];</span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> column = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 移动的方向</span></span><br><span class="line">    <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> directionIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line">        order[i] = matrix[row][column];</span><br><span class="line">        visited[row][column] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> nextRow = row + directions[directionIndex][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> nextColumn = column + directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (nextRow &lt; <span class="number">0</span> || nextRow &gt;= rows || nextColumn &lt; <span class="number">0</span> || nextColumn &gt;= columns</span><br><span class="line">                || visited[nextRow][nextColumn]) &#123;</span><br><span class="line">            directionIndex = (directionIndex + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        row += directions[directionIndex][<span class="number">0</span>];</span><br><span class="line">        column += directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(mn)，其中 m 和 n 分别是输入矩阵的行数和列数。矩阵中的每个元素都要被访问一次。</li>
<li>空间复杂度：O(mn)。需要创建一个大小为 m × n 的矩阵 visited 记录每个位置是否被访问过。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/" title="顺时针打印矩阵 | 力扣（LeetCode）">顺时针打印矩阵 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/shun-shi-zhen-da-yin-ju-zhen-by-leetcode-solution/" title="顺时针打印矩阵 | 题解（LeetCode）">顺时针打印矩阵 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/06/05/shun-shi-zhen-da-yin-ju-zhen-lcof/' title='顺时针打印矩阵' >顺时针打印矩阵</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/06/05/shun-shi-zhen-da-yin-ju-zhen-lcof/' title='顺时针打印矩阵' >http://www.cylong.com/blog/2020/06/05/shun-shi-zhen-da-yin-ju-zhen-lcof/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>数组</tag>
        <tag>指针</tag>
        <tag>记忆化</tag>
        <tag>剑指Offer</tag>
        <tag>回溯算法</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>最长公共前缀</title>
    <url>/blog/2020/06/15/longest-common-prefix/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。</p>
<p><strong>示例 1:</strong></p>
<blockquote>
<p>输入: [“flower”, “flow”, “flight”]<br>输出: “fl”</p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p>输入: [“dog”, “racecar”, “car”]<br>输出: “”<br>解释: 输入不存在公共前缀。</p>
</blockquote>
<p><strong>说明:</strong></p>
<blockquote>
<p>所有输入只包含小写字母 a-z 。</p>
</blockquote>
<a id="more"></a>

<h1 id="横向扫描"><a href="#横向扫描" class="headerlink" title="横向扫描"></a>横向扫描</h1><p>我们求所有字符串的最长公共前缀，可以发现，对于字符串S₁……Sn，我们只要依次遍历每个字符串，对于每个遍历到的字符串，更新当前的最长公共前缀，遍历所有的字符串以后，即可得到字符串数组中的最长公共前缀。下面是给了递归和遍历两种方式代码。如果在尚未遍历完所有的字符串时，最长公共前缀已经是空串，则最长公共前缀一定是空串，因此不需要继续遍历剩下的字符串，直接返回空串即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strs.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> longestCommonPrefixTwoStr(strs[<span class="number">0</span>], longestCommonPrefix(strs, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == strs.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> strs[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归处理当前字符串和(后续所有字符传最长公共前缀)的最长公共前缀。</span></span><br><span class="line">    <span class="keyword">return</span> longestCommonPrefixTwoStr(strs[index], longestCommonPrefix(strs, index + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefixTwoStr</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = Math.min(str1.length(), str2.length());</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; len &amp;&amp; str1.charAt(index) == str2.charAt(index)) &#123;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str1.substring(<span class="number">0</span>, index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String prefix = strs[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">        prefix = longestCommonPrefixTwoStr(prefix, strs[i]);</span><br><span class="line">        <span class="keyword">if</span> (prefix.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prefix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefixTwoStr</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = Math.min(str1.length(), str2.length());</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; len &amp;&amp; str1.charAt(index) == str2.charAt(index)) &#123;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str1.substring(<span class="number">0</span>, index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(mn)，其中 m 是字符串数组中的字符串的平均长度，n 是字符串的数量。最坏情况下，字符串数组中的每个字符串的每个字符都会被比较一次。</li>
<li>空间复杂度：遍历是O(1)，只需要额外的常数级别的空间。递归是O(n)，其中 n 是字符串的数量。</li>
</ul>
<h1 id="纵向扫描"><a href="#纵向扫描" class="headerlink" title="纵向扫描"></a>纵向扫描</h1><p>前面的方法是横向扫描，依次遍历每个字符串，更新最长公共前缀。另一种方法是纵向扫描。纵向扫描时，从前往后遍历所有字符串的每一列，比较相同列上的字符是否相同，如果相同则继续对下一列进行比较，如果不相同则当前列不再属于公共前缀，当前列之前的部分为最长公共前缀。</p>
<img src="/blog/2020/06/15/longest-common-prefix/%E7%BA%B5%E5%90%91%E6%89%AB%E6%8F%8F.png" class="" title="纵向扫描">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> length = strs[<span class="number">0</span>].length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = strs[<span class="number">0</span>].charAt(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; strs.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == strs[j].length() || strs[j].charAt(i) != c) &#123;</span><br><span class="line">                <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(mn)，其中 m 是字符串数组中的字符串的平均长度，n 是字符串的数量。最坏情况下，字符串数组中的每个字符串的每个字符都会被比较一次。</li>
<li>空间复杂度：O(1)，只需要额外的常数级别的空间。</li>
</ul>
<h1 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h1><p>针对横向扫描的方法，我们可以发现，可以使用分治法得到字符串的最长公共前缀，我们可以将字符串数组一分为二，分别求分开的两个字符串数组的最长公共前缀，并不断递归处理，最后合并求出子问题的最长公共前缀。</p>
<img src="/blog/2020/06/15/longest-common-prefix/%E5%88%86%E6%B2%BB%E6%B3%95.png" class="" title="分治法">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> longestCommonPrefix(strs, <span class="number">0</span>, strs.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">        <span class="keyword">return</span> strs[start];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (end - start) / <span class="number">2</span> + start;</span><br><span class="line">        String left = longestCommonPrefix(strs, start, mid);</span><br><span class="line">        String right = longestCommonPrefix(strs, mid + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> longestCommonPrefixTwoStr(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefixTwoStr</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = Math.min(str1.length(), str2.length());</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; len &amp;&amp; str1.charAt(index) == str2.charAt(index)) &#123;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str1.substring(<span class="number">0</span>, index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(mn)，其中 m 是字符串数组中的字符串的平均长度，n 是字符串的数量。时间复杂度的递推式是 T(n)=2⋅T(n/2)+O(m)，通过计算可得 T(n)=O(mn)。</li>
<li>空间复杂度：O(mlogn)，其中 m 是字符串数组中的字符串的平均长度，n 是字符串的数量。空间复杂度主要取决于递归调用的层数，层数最大为 logn，每层需要 m 的空间存储返回结果。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/longest-common-prefix/" title="最长公共前缀 | 力扣（LeetCode）">最长公共前缀 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/longest-common-prefix/solution/zui-chang-gong-gong-qian-zhui-by-leetcode-solution/" title="最长公共前缀 | 题解（LeetCode）">最长公共前缀 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/06/15/longest-common-prefix/' title='最长公共前缀' >最长公共前缀</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/06/15/longest-common-prefix/' title='最长公共前缀' >http://www.cylong.com/blog/2020/06/15/longest-common-prefix/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>数组</tag>
        <tag>字符串</tag>
        <tag>指针</tag>
        <tag>双指针</tag>
        <tag>递归</tag>
        <tag>分治法</tag>
      </tags>
  </entry>
  <entry>
    <title>删除链表的倒数第N个节点</title>
    <url>/blog/2020/06/16/remove-nth-node-from-end-of-list/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>
<p><strong>示例：</strong></p>
<blockquote>
<p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.<br>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</p>
</blockquote>
<p><strong>说明：</strong></p>
<blockquote>
<p>给定的 n 保证是有效的。</p>
</blockquote>
<p><strong>进阶：</strong></p>
<blockquote>
<p>你能尝试使用一趟扫描实现吗？</p>
</blockquote>
<a id="more"></a>

<h1 id="两次遍历"><a href="#两次遍历" class="headerlink" title="两次遍历"></a>两次遍历</h1><p>最简单的思路，我们发现其实是删除从列表开头数起的第 <code>(L - n + 1)</code> 个结点，其中 L 是列表的长度。只要我们找到列表的长度 L，这个问题就很容易解决。我们先遍历一次链表，求出链表的长度 L，然后再遍历一次链表，删除倒数第 n 个节点即可。需要注意的是如果 <code>L = n</code>，那么要直接返回 <code>head.next</code>。</p>
<img src="/blog/2020/06/16/remove-nth-node-from-end-of-list/%E4%B8%A4%E6%AC%A1%E9%81%8D%E5%8E%86.png" class="" title="两次遍历">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    ListNode node = head;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        len++;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (node != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (len == n) &#123;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    node = head;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (++index == len - n) &#123;</span><br><span class="line">            node.next = node.next.next;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (node != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(L)，该算法对列表进行了两次遍历，首先计算了列表的长度 L 其次找到第 <code>L - n</code> 个结点。 操作执行了 <code>2L - n</code> 步，时间复杂度为 O(L)。</li>
<li>空间复杂度：O(1)，只需要额外的常数级别的空间。</li>
</ul>
<h1 id="一次遍历"><a href="#一次遍历" class="headerlink" title="一次遍历"></a>一次遍历</h1><p>上述算法可以优化为只使用一次遍历。我们可以使用两个指针而不是一个指针。第一个指针从列表的开头向前移动 <code>n + 1</code> 步，而第二个指针将从列表的开头出发。现在，这两个指针被 n 个结点分开。我们通过同时移动两个指针向前来保持这个恒定的间隔，直到第一个指针到达最后一个结点。此时第二个指针将指向从最后一个结点数起的第 n 个结点。我们重新链接第二个指针所引用的结点的 next 指针指向该结点的下下个结点。</p>
<img src="/blog/2020/06/16/remove-nth-node-from-end-of-list/%E4%B8%80%E6%AC%A1%E9%81%8D%E5%8E%86.png" class="" title="一次遍历">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    ListNode first = dummy;</span><br><span class="line">    ListNode second = dummy;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        first = first.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = first.next;</span><br><span class="line">        second = second.next;</span><br><span class="line">    &#125;</span><br><span class="line">    second.next = second.next.next;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(L)，该算法对含有 L 个结点的列表进行了一次遍历。因此时间复杂度为 O(L)。</li>
<li>空间复杂度：O(1)，只需要额外的常数级别的空间。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" title="删除链表的倒数第N个节点 | 力扣（LeetCode）">删除链表的倒数第N个节点 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/solution/shan-chu-lian-biao-de-dao-shu-di-nge-jie-dian-by-l/" title="删除链表的倒数第N个节点 | 题解（LeetCode）">删除链表的倒数第N个节点 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/06/16/remove-nth-node-from-end-of-list/' title='删除链表的倒数第N个节点' >删除链表的倒数第N个节点</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/06/16/remove-nth-node-from-end-of-list/' title='删除链表的倒数第N个节点' >http://www.cylong.com/blog/2020/06/16/remove-nth-node-from-end-of-list/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>链表</tag>
        <tag>指针</tag>
        <tag>双指针</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>验证回文串</title>
    <url>/blog/2020/06/19/valid-palindrome/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。<br><strong>说明：</strong> 本题中，我们将空字符串定义为有效的回文串。</p>
<p><strong>示例 1:</strong></p>
<blockquote>
<p>输入: “A man, a plan, a canal: Panama”<br>输出: true</p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p>输入: “race a car”<br>输出: false</p>
</blockquote>
<a id="more"></a>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>我们先假设，字符串中仅包含英文字母，那么判断是否是回文串，我们只需要使用两个指针i和j，同时指向字符串的首尾，然后判断i和j指向的字母是否相等，然后同时进行 <code>i++</code> 和 <code>j--</code> 操作，直到 <code>i == j</code>。用这个思路解决此题，由于字符串中包含很多非英文字母，那么我们就需要多一步处理，如果i和j指向的字符不是英文字母，那么我们就不断的进行 <code>i++</code> 和 <code>j--</code> 操作，直到i和j指向的字符是英文字母，然后进行比较即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = s.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; !Character.isLetterOrDigit(s.charAt(i))) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; !Character.isLetterOrDigit(s.charAt(j))) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j &amp;&amp; Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(n)，其中 n 是字符串的长度。</li>
<li>空间复杂度：O(1)，只需要额外的常数级别的空间。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/valid-palindrome/" title="验证回文串 | 力扣（LeetCode）">验证回文串 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/valid-palindrome/solution/yan-zheng-hui-wen-chuan-by-leetcode-solution/" title="验证回文串 | 题解（LeetCode）">验证回文串 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/06/19/valid-palindrome/' title='验证回文串' >验证回文串</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/06/19/valid-palindrome/' title='验证回文串' >http://www.cylong.com/blog/2020/06/19/valid-palindrome/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>字符串</tag>
        <tag>指针</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>另一个树的子树</title>
    <url>/blog/2020/06/22/subtree-of-another-tree/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定的树 s:</span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   2</span><br><span class="line"></span><br><span class="line">给定的树 t：</span><br><span class="line">   4</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   2</span><br><span class="line">返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定的树 s：</span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   2</span><br><span class="line">    &#x2F;</span><br><span class="line">   0</span><br><span class="line"></span><br><span class="line">给定的树 t：</span><br><span class="line">   4</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   2</span><br><span class="line">返回 false。</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先我们需要一个可以判断二叉树是否是相同树的方法，使用递归方式处理，递归的结束条件就是 t1 或者 t2 为空，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEqual</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t1 == <span class="keyword">null</span> || t2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t1.val == t2.val &amp;&amp; isEqual(t1.left, t2.left) &amp;&amp; isEqual(t1.right, t2.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，回到原题，判断树 t 是否是树 s 的子树，同样使用递归，不断的判断树 s 的左子树和右子树，是否包含子树 t，递归的结束条件就是树 s 为空，或者树 s 与树 t 相等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isEqual(s, t)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isSubtree(s.left, t) || isSubtree(s.right, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/subtree-of-another-tree/" title="另一个树的子树 | 力扣（LeetCode）">另一个树的子树 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/subtree-of-another-tree/solution/ling-yi-ge-shu-de-zi-shu-by-leetcode-solution/" title="另一个树的子树 | 题解（LeetCode）">另一个树的子树 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/06/22/subtree-of-another-tree/' title='另一个树的子树' >另一个树的子树</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/06/22/subtree-of-another-tree/' title='另一个树的子树' >http://www.cylong.com/blog/2020/06/22/subtree-of-another-tree/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>递归</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>用两个栈实现队列</title>
    <url>/blog/2020/06/30/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/</url>
    <content><![CDATA[<hr>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：<br>[“CQueue”, “appendTail”, “deleteHead”, “deleteHead”]<br>[[], [3], [], []]<br>输出：[null, null, 3, -1]</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：<br>[“CQueue”, “deleteHead”, “appendTail”, “appendTail”, “deleteHead”, “deleteHead”]<br>[[], [], [5], <a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/solution/mian-shi-ti-09-yong-liang-ge-zhan-shi-xian-dui-l-3/" title="用两个栈实现队列 | 题解（LeetCode）">2</a>, [], []]<br>输出：[null, -1, null, null, 5, 2]</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= values &lt;= 10000</li>
<li>最多会对 appendTail、deleteHead 进行 10000 次调用</li>
</ul>
<a id="more"></a>

<h1 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h1><p>队列的特性是先进先出，栈的特性是后进先出。维护两个栈，第一个栈支持插入操作，第二个栈支持删除操作。</p>
<p>根据栈先进后出的特性，我们每次往第一个栈里插入元素后，第一个栈的底部元素是最后插入的元素，第一个栈的顶部元素是下一个待删除的元素。为了维护队列先进先出的特性，我们引入第二个栈，用第二个栈维护待删除的元素，在执行删除操作的时候我们首先看下第二个栈是否为空。如果为空，我们将第一个栈里的元素一个个弹出插入到第二个栈里，这样第二个栈里元素的顺序就是待删除的元素的顺序，要执行删除操作的时候我们直接弹出第二个栈的元素返回即可。</p>
<img src="/blog/2020/06/30/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.gif" class="" title="两个栈实现队列">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stack&lt;Integer&gt; st1;</span><br><span class="line">Stack&lt;Integer&gt; st2;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    st1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    st2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    st1.push(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (st2.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!st1.isEmpty()) &#123;</span><br><span class="line">            st2.push(st1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> st2.isEmpty() ? -<span class="number">1</span> : st2.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：对于插入和删除操作，时间复杂度均为 O(1)。插入不多说，对于删除操作，虽然看起来是 O(n) 的时间复杂度，但是仔细考虑下每个元素只会「至多被插入和弹出 st2 一次」，因此均摊下来每个元素被删除的时间复杂度仍为 O(1)。</li>
<li>空间复杂度：O(n)。需要使用两个栈存储已有的元素。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" title="用两个栈实现队列 | 力扣（LeetCode）">用两个栈实现队列 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/solution/mian-shi-ti-09-yong-liang-ge-zhan-shi-xian-dui-l-3/" title="用两个栈实现队列 | 题解（LeetCode）">用两个栈实现队列 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/06/30/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/' title='用两个栈实现队列' >用两个栈实现队列</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/06/30/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/' title='用两个栈实现队列' >http://www.cylong.com/blog/2020/06/30/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>队列</tag>
        <tag>剑指Offer</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>最长重复子数组</title>
    <url>/blog/2020/07/01/maximum-length-of-repeated-subarray/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。</p>
<p><strong>示例：</strong></p>
<blockquote>
<p>输入：<br>A: [1, 2, 3, 2, 1]<br>B: [3, 2, 1, 4, 7]<br>输出：3<br>解释：长度最长的公共子数组是 [3, 2, 1] 。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= len(A), len(B) &lt;= 1000</li>
<li>0 &lt;= A[i], B[i] &lt; 100</li>
</ul>
<a id="more"></a>

<h1 id="暴力方法"><a href="#暴力方法" class="headerlink" title="暴力方法"></a>暴力方法</h1><p>最简单的方法，暴力方法，我们知道最长公共子数组长度最大值为数组A和B中长度较小值。我们先固定最长值为min(len(A), len(B))，然后遍历A和B，判断此长度是否有公共子数组，找到，则返回此值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = Math.min(A.length, B.length);</span><br><span class="line">    <span class="keyword">int</span> res_len = len;</span><br><span class="line">    <span class="keyword">while</span> (res_len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ai = <span class="number">0</span>; ai + res_len &lt;= len; ai++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> bi = <span class="number">0</span>; bi + res_len &lt;= len; bi++) &#123;</span><br><span class="line">                <span class="comment">// 判断固定长度的子数组是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (subArrayIsSame(A, B, ai, bi, res_len)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> res_len;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不相等，最大长度减一</span></span><br><span class="line">        res_len--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res_len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">subArrayIsSame</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span> ai, <span class="keyword">int</span> bi, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[ai + i] != B[bi + i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：Ο(N³)，因为要遍历A、B和公共子数组。</li>
<li>空间复杂度：Ο(1)。</li>
</ul>
<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p>以题目为例，它们的最长重复子数组是 [3, 2, 1]，在 A 与 B 中的开始位置不同。但如果我们知道了开始位置，我们就可以根据它们将 A 和 B 进行「对齐」，即：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A &#x3D; [1, 2, 3, 2, 1]</span><br><span class="line">B &#x3D;       [3, 2, 1, 4, 7]</span><br><span class="line">           ↑  ↑  ↑</span><br></pre></td></tr></table></figure>

<p>此时，最长重复子数组在 A 和 B 中的开始位置相同，我们就可以对这两个数组进行一次遍历，得到子数组的长度。我们可以枚举 A 和 B 所有的对齐方式。对齐的方式有两类：第一类为 A 不变，B 的首元素与 A 中的某个元素对齐；第二类为 B 不变，A 的首元素与 B 中的某个元素对齐。对于每一种对齐方式，我们计算它们相对位置相同的重复子数组即可。</p>
<img src="/blog/2020/07/01/maximum-length-of-repeated-subarray/%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84.gif" class="" title="最长重复子数组">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lenA = A.length;</span><br><span class="line">    <span class="keyword">int</span> lenB = B.length;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenA; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = Math.min(lenA - i, lenB);</span><br><span class="line">        <span class="keyword">int</span> maxLen = maxLength(A, B, i, <span class="number">0</span>, len);</span><br><span class="line">        ret = Math.max(ret, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenB; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = Math.min(lenB - i, lenA);</span><br><span class="line">        <span class="keyword">int</span> maxLen = maxLength(A, B, <span class="number">0</span>, i, len);</span><br><span class="line">        ret = Math.max(ret, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对齐后计算最长公共子数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxLength</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span> indexA, <span class="keyword">int</span> indexB, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[indexA + i] == B[indexB + i]) &#123;</span><br><span class="line">            maxLen++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            maxLen = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = Math.max(ret, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度： Ο((M + N) × min(M, N))。</li>
<li>空间复杂度： Ο(1)。<blockquote>
<p>M 表示数组 A 的长度，N 表示数组 B 的长度。</p>
</blockquote>
</li>
</ul>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>我们使用A[i]，B[j]分别表示两个数组对应下标的值。如果 A[i] == B[j]，那么我们知道 A[i:] 与 B[j:] 的最长公共前缀为 A[i + 1:] 与 B[j + 1:] 的最长公共前缀的长度加一，否则我们知道 A[i:] 与 B[j:] 的最长公共前缀为零。这样我们就可以提出动态规划的解法：令 dp[i][j] 表示 A[i:] 和 B[j:] 的最长公共前缀，那么答案即为所有 dp[i][j] 中的最大值。如果 A[i] == B[j]，那么 dp[i][j] = dp[i + 1][j + 1] + 1，否则 dp[i][j] = 0。<br>考虑到这里 dp[i][j] 的值从 dp[i + 1][j + 1] 转移得到，所以我们需要倒过来，首先计算 dp[len(A) - 1][len(B) - 1]，最后计算 dp[0][0]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = A.length, m = B.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            dp[i][j] = A[i] == B[j] ? dp[i + <span class="number">1</span>][j + <span class="number">1</span>] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            ret = Math.max(ret, dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度： O(M × N)。</li>
<li>空间复杂度： O(M × N)。<blockquote>
<p>N 表示数组 A 的长度，M 表示数组 B 的长度。</p>
</blockquote>
</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/" title="最长重复子数组 | 力扣（LeetCode）">最长重复子数组 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/solution/zui-chang-zhong-fu-zi-shu-zu-by-leetcode-solution/" title="最长重复子数组 | 题解（LeetCode）">最长重复子数组 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/07/01/maximum-length-of-repeated-subarray/' title='最长重复子数组' >最长重复子数组</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/07/01/maximum-length-of-repeated-subarray/' title='最长重复子数组' >http://www.cylong.com/blog/2020/07/01/maximum-length-of-repeated-subarray/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>数组</tag>
        <tag>滑动窗口</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>路经总和</title>
    <url>/blog/2020/07/06/path-sum/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。<br><strong>说明: 叶子节点是指没有子节点的节点。</strong></p>
<p><strong>示例:</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定如下二叉树，以及目标和 sum &#x3D; 22</span><br><span class="line">        5</span><br><span class="line">       &#x2F; \</span><br><span class="line">      4   8</span><br><span class="line">     &#x2F;   &#x2F; \</span><br><span class="line">    11  13  4</span><br><span class="line">   &#x2F;  \      \</span><br><span class="line">  7    2      1</span><br><span class="line">返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>此题使用递归解决思路就会比较清晰，针对 root 节点，我们求其左右两棵子树的路径和是否为 root.val - sum，针对左右子树，同样递归解决。递归的结束条件就是遍历到叶子节点，直接判断 sum 是否等于 val 即可。因为到达叶子节点的时候，sum 的值已经被减去走过的路径的值了。需要注意的是给定的 root 可能为空。同样的，递归的结束条件也要判断节点是否为空。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum == root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：Ο(N)，其中 N 是树的节点数。对每个节点访问一次。</li>
<li>空间复杂度：Ο(H)，其中 H 是树的高度。空间复杂度主要取决于递归时栈空间的开销，最坏情况下，树呈现链状，空间复杂度为 Ο(N)。平均情况下树的高度与节点数的对数正相关，空间复杂度为 Ο(logN)。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/path-sum/" title="路径总和 | 力扣（LeetCode）">路径总和 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/path-sum/solution/lu-jing-zong-he-by-leetcode-solution/" title="路径总和 | 题解（LeetCode）">路径总和 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/07/06/path-sum/' title='路经总和' >路经总和</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/07/06/path-sum/' title='路经总和' >http://www.cylong.com/blog/2020/07/06/path-sum/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>递归</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
        <tag>深度优先搜索</tag>
        <tag>中序遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>路径总和 II</title>
    <url>/blog/2020/07/07/path-sum-ii/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。<br><strong>说明: 叶子节点是指没有子节点的节点。</strong></p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定如下二叉树，以及目标和 sum &#x3D; 22，</span><br><span class="line">      5</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   8</span><br><span class="line">   &#x2F;   &#x2F; \</span><br><span class="line">  11  13  4</span><br><span class="line"> &#x2F;  \    &#x2F; \</span><br><span class="line">7    2  5   1</span><br><span class="line">返回:</span><br><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>做此题之前，可以先做一道简单版的<a href="https://leetcode-cn.com/problems/path-sum/" title="路径总和 | 力扣（LeetCode）">路径总和</a>，简单版的只要遍历全部节点，遇到满足条件的路径返回 true 即可，而此题不仅要遍历全部节点，还要记录满足条件的路径。此题是典型的回溯算法，思路就是，先声明一个<code>LinkedList&lt;Integer&gt; path</code>保存路径，<code>List&lt;List&lt;Integer&gt;&gt; ans</code>保存所有路径，我们每遍历到一个节点，就将这个节点的值保存在 path 中，当判断到子节点，如果此节点的值满足 sum 等于 val，则将 path 加入到 ans 中，否则继续进行递归遍历左右子树。注意入参 root 可能为空，另外递归的结束条件也包含节点为空。当递归回溯的时候，我们就删除最后加入到 path 中的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    path.add(root.val);</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == root.val) &#123;</span><br><span class="line">            <span class="comment">// 此处new LinkedList&lt;&gt;(path)新建一个链表</span></span><br><span class="line">            <span class="comment">// 因为如果直接add(path)，ans中的路径和path是相同的引用，后面操作path后，ans中的路径也将一起被修改。</span></span><br><span class="line">            ans.add(<span class="keyword">new</span> LinkedList&lt;&gt;(path));</span><br><span class="line">            <span class="comment">// 此处无需return，因为后续pathSum递归的时候root.left和root.right都为空，满足递归结束条件。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pathSum(root.left, sum - root.val);</span><br><span class="line">    pathSum(root.right, sum - root.val);</span><br><span class="line">    <span class="comment">// 递归回溯的时候删除最后一个节点，此处使用LinkedList提升效率</span></span><br><span class="line">    path.removeLast();</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/path-sum-ii/" title="路径总和 II | 力扣（LeetCode）">路径总和 II | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/path-sum-ii/solution/" title="路径总和 II | 题解（LeetCode）">路径总和 II | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/07/07/path-sum-ii/' title='路径总和 II' >路径总和 II</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/07/07/path-sum-ii/' title='路径总和 II' >http://www.cylong.com/blog/2020/07/07/path-sum-ii/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>递归</tag>
        <tag>回溯算法</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
        <tag>深度优先搜索</tag>
        <tag>中序遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>跳水板</title>
    <url>/blog/2020/07/08/diving-board-lcci/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。返回的长度需要从小到大排列。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：<br>shorter = 1<br>longer = 2<br>k = 3<br>输出： [3, 4, 5, 6]<br>解释：可以使用 3 次 shorter，得到结果 3；使用 2 次 shorter 和 1 次 longer，得到结果 4 。以此类推，得到最终结果。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>0 &lt; shorter &lt;= longer</li>
<li>0 &lt;= k &lt;= 100000</li>
</ul>
<a id="more"></a>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>考虑两种情况，如果k为0，那么不会建造任何跳水板，直接返回空数组。另外一种情况，如果shorter与longer相等，那么跳水板的长度是唯一的，就是 <code>shorter * k</code> ，于是返回长度为 1 的数组，数组中的元素为 <code>shorter ∗ k</code>。</p>
<p>当shorter不等于longer的情况，我们考虑跳水板最短的情况，就是全是短木板，此时的长度是 <code>shorter * k</code>，我们每次增加一块长木板，减少一块短木板，由于共有 k 块木板，于是共有 <code>k + 1</code> 种长度 <code>k + 1</code> 种组合。每次木板的长度变化是 <code>longer - shorter</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] divingBoard(<span class="keyword">int</span> shorter, <span class="keyword">int</span> longer, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> min = shorter * k;</span><br><span class="line">    <span class="keyword">int</span> difference = longer - shorter;</span><br><span class="line">    <span class="keyword">if</span> (difference == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;min&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>];</span><br><span class="line">    ans[<span class="number">0</span>] = min;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        ans[i] = ans[i - <span class="number">1</span>] + difference;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(k)，其中 k 是木板数量。短木板和长木板一共使用 k 块，一共有 k + 1 种组合，对于每种组合都要计算跳水板的长度。</li>
<li>空间复杂度：O(1)，只需要额外的常数级别的空间。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/diving-board-lcci/" title="跳水板 | 力扣（LeetCode）">跳水板 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/diving-board-lcci/solution/tiao-shui-ban-by-leetcode-solution/" title="跳水板 | 题解（LeetCode）">跳水板 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/07/08/diving-board-lcci/' title='跳水板' >跳水板</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/07/08/diving-board-lcci/' title='跳水板' >http://www.cylong.com/blog/2020/07/08/diving-board-lcci/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>数组</tag>
        <tag>程序员面试金典</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>恢复空格</title>
    <url>/blog/2020/07/09/re-space-lcci/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子”I reset the computer. It still didn’t boot!”已经变成了”iresetthecomputeritstilldidntboot”。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典dictionary，不过，有些词没在词典里。假设文章用sentence表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。</p>
<p><strong>示例：</strong></p>
<blockquote>
<p>输入：<br>dictionary = [“looked”, “just”, “like”, “her”, “brother”]<br>sentence = “jesslookedjustliketimherbrother”<br>输出： 7<br>解释： 断句后为”jess looked just like tim her brother”，共7个未识别字符。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>0 &lt;= len(sentence) &lt;= 1000</li>
<li>dictionary中总字符数不超过 150000。</li>
<li>你可以认为dictionary和sentence中只包含小写字母。</li>
</ul>
<a id="more"></a>

<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>这里采用动态规划，创建一个数组 dp 用来记录结果。句子从前往后看，其中 <code>dp[0]=0</code> 表示句子是空字符串时没有未识别的字符，dp[i] 表示句子前 i 个字符中最少的未识别字符数。然后来找状态转移方程。对于前 i 个字符，即句子字符串的 [0,i)，它可能是由最前面的 [0,j) 子字符串加上一个字典匹配的单词得到，也就是 <code>dp[i]=dp[j]</code>, <code>j &lt; i</code>；也可能没找到字典中的单词，可以用它前 <code>i - 1</code> 个字符的结果加上一个没有匹配到的第 i 个字符，即 <code>dp[i] = dp[i-1] + 1</code>。要注意的是，即使前面存在匹配的单词，也不能保证哪一种剩下的字符最少，所以每轮都要比较一次最小值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">respace</span><span class="params">(String[] dictionary, String sentence)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; dic = Arrays.asList(dictionary);</span><br><span class="line">    <span class="keyword">int</span> len = sentence.length();</span><br><span class="line">    <span class="comment">// dp[i]表示sentence前i个字符所得结果</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;  <span class="comment">// 先假设当前字符作为单词不在字典中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dic.contains(sentence.substring(j, i))) &#123;</span><br><span class="line">                dp[i] = Math.min(dp[i], dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：Ο(n²)，其中 n 是字符串长度。</li>
<li>空间复杂度：O(n)，其中 n 是字符串长度，保存dp的中间值。</li>
</ul>
<h1 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h1><p>这里重点讲述Trie字典树的解法。首先看一个字典树的例子：</p>
<img src="/blog/2020/07/09/re-space-lcci/%E5%AD%97%E5%85%B8%E6%A0%91.png" class="" title="字典树">

<p>该树包含的单词集合为 {“at”, “bee”, “ben”, “bt”, “q”}。每一个节点保存一个字符，因为题目说只包含小写字母，所以一个节点最多可以有 26 个子节点。每次查找单词都从空白的根节点开始，比如查找单词 “cat”，第一个字符 ‘c’ 就不存在，直接返回 false；查找单词 “bee”，根节点下有 b，b 的子节点有 e，下面还有 e 所以查到了。但是如果查找单词”be”,同样的方法 ‘b’ 和 ‘e’ 都存在，但是字典里没有 “be” 这个单词，所以在树里还需要一个 boolean 变量表示当前节点是不是一个单词的结尾，如图绿色表示。如果往字典中插入一个 “be” 单词，此时 b 节点下的 e 节点也应该标绿，此时再查找 “be”，在 e 节点发现它是个单词，所以返回 true。</p>
<p>使用字典树可利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">respace</span><span class="params">(String[] dictionary, String sentence)</span> </span>&#123;</span><br><span class="line">    root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    makeTrie(dictionary);   <span class="comment">//创建字典树</span></span><br><span class="line">    <span class="keyword">int</span> n = sentence.length();</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//这里从sentence最后一个字符开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        dp[i] = n - i;    <span class="comment">//初始默认后面全不匹配</span></span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = sentence.charAt(j) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.childs[c] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//例如&quot;abcde&quot;,i=1,j=2 可找出长度关系</span></span><br><span class="line">                dp[i] = Math.min(dp[i], j - i + <span class="number">1</span> + dp[j + <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.childs[c].isWord) &#123;</span><br><span class="line">                dp[i] = Math.min(dp[i], dp[j + <span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i] = Math.min(dp[i], j - i + <span class="number">1</span> + dp[j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.childs[c];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeTrie</span><span class="params">(String[] dictionary)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String str : dictionary) &#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; str.length(); k++) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = str.charAt(k) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.childs[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                node.childs[i] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.childs[i];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isWord = <span class="keyword">true</span>; <span class="comment">//单词的结尾</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义一个TrieNode类型。</span></span><br><span class="line"><span class="comment"> * 这里不用建一个变量来存当前节点表示的字符，</span></span><br><span class="line"><span class="comment"> * 因为只要该节点不为null，就说明存在这个字符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    TrieNode[] childs;</span><br><span class="line">    <span class="keyword">boolean</span> isWord;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        childs = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">        isWord = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/re-space-lcci/" title="恢复空格 | 力扣（LeetCode）">恢复空格 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/re-space-lcci/solution/cong-bao-li-ru-shou-you-hua-yi-ji-triezi-dian-shu-/" title="恢复空格 | 题解（LeetCode）">恢复空格 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/07/09/re-space-lcci/' title='恢复空格' >恢复空格</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/07/09/re-space-lcci/' title='恢复空格' >http://www.cylong.com/blog/2020/07/09/re-space-lcci/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>字符串</tag>
        <tag>动态规划</tag>
        <tag>程序员面试金典</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>三角形最小路径和</title>
    <url>/blog/2020/07/14/triangle/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。相邻的结点，在这里指的是下标与上一层结点下标相同或者等于上一层结点下标 + 1 的两个结点。</p>
<p>例如，给定三角形：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">     [2],</span><br><span class="line">    [3, 4],</span><br><span class="line">   [6, 5, 7],</span><br><span class="line">  [4, 1, 8, 3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</p>
<a id="more"></a>

<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>给定的三角形的行数为 n，并且第 i 行（从 0 开始编号）包含了 <code>i + 1</code> 个数。如果将每一行的左端对齐，那么会形成一个等腰直角三角形，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[2],</span><br><span class="line">[3, 4],</span><br><span class="line">[6, 5, 7],</span><br><span class="line">[4, 1, 8, 3]</span><br></pre></td></tr></table></figure>

<p>这样，我们可以从顶点自上而下递归处理最小路径和，首先从顶点开始，他的最小路径和是顶点的数2加上下面的以3为顶点的最短路径和，或者顶点2加上下面以4为顶点的最短路径和，取其中的最小值，并不断递归处理。这里需要注意的一点是，对于第二行的顶点3和4，计算他们下一层的最短路径和的时候，会计算两遍第三行的以5为顶点的三角形最短路径和。所以我们在递归的同时，记录下计算过的路径和，防止重复计算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (triangle == <span class="keyword">null</span> || triangle.isEmpty() || triangle.get(<span class="number">0</span>).isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用来保存某个顶点计算过的最短路径和</span></span><br><span class="line">    <span class="keyword">int</span>[][] minValue = <span class="keyword">new</span> <span class="keyword">int</span>[triangle.size() + <span class="number">1</span>][triangle.size() + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; minValue.length; i++) &#123;</span><br><span class="line">        Arrays.fill(minValue[i], Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> value = triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> leftValue = value + minimumTotal(triangle, <span class="number">1</span>, <span class="number">0</span>, minValue);</span><br><span class="line">    <span class="keyword">int</span> rightValue = value + minimumTotal(triangle, <span class="number">1</span>, <span class="number">1</span>, minValue);</span><br><span class="line">    <span class="keyword">return</span> Math.min(leftValue, rightValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle, <span class="keyword">int</span> row, <span class="keyword">int</span> column, <span class="keyword">int</span>[][] minValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (row &gt;= triangle.size() || column &gt;= triangle.get(row).size()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> value = triangle.get(row).get(column);</span><br><span class="line">    <span class="keyword">int</span> leftValue = value + (minValue[row + <span class="number">1</span>][column] &lt; Integer.MAX_VALUE ? minValue[row + <span class="number">1</span>][column]</span><br><span class="line">            : minimumTotal(triangle, row + <span class="number">1</span>, column, minValue));</span><br><span class="line">    <span class="keyword">int</span> rightValue = value + (minValue[row + <span class="number">1</span>][column + <span class="number">1</span>] &lt; Integer.MAX_VALUE ? minValue[row + <span class="number">1</span>][column + <span class="number">1</span>]</span><br><span class="line">            : minimumTotal(triangle, row + <span class="number">1</span>, column + <span class="number">1</span>, minValue));</span><br><span class="line">    <span class="keyword">return</span> minValue[row][column] = Math.min(leftValue, rightValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(n²)，其中 n 是三角形的行数。</li>
<li>空间复杂度：O(n²)，我们需要一个 n ∗ n 的二维数组存放记录的值。</li>
</ul>
<h1 id="动态规划-自顶向下"><a href="#动态规划-自顶向下" class="headerlink" title="动态规划-自顶向下"></a>动态规划-自顶向下</h1><p>我们用 <code>f[i][j]</code> 表示从三角形顶部走到位置 <code>(i, j)</code> 的最小路径和。这里的位置 <code>(i, j)</code> 指的是三角形中第 i 行第 j 列（均从 0 开始编号）的位置。由于每一步只能移动到下一行「相邻的节点」上，因此要想走到位置 <code>(i, j)</code>，上一步就只能在位置 <code>(i - 1, j - 1)</code> 或者位置 <code>(i - 1, j)</code>。我们在这两个位置中选择一个路径和较小的来进行转移，状态转移方程为：</p>
<blockquote>
<p>f[i][j] = min(f[i − 1][j − 1], f[i − 1][j]) + c[i][j]</p>
</blockquote>
<p>其中 <code>c[i][j]</code> 表示位置 <code>(i, j)</code> 对应的元素值。<br>注意第 i 行有 <code>i + 1</code> 个元素，它们对应的 j 的范围为 <code>[0, i]</code>。当 <code>j = 0</code> 或 <code>j = i</code> 时，上述状态转移方程中有一些项是没有意义的。例如当 <code>j = 0</code> 时，<code>f[i − 1][j − 1]</code> 没有意义，因此状态转移方程为：</p>
<blockquote>
<p>f[i][0] = f[i − 1][0] + c[i][0]</p>
</blockquote>
<p>即当我们在第 i 行的最左侧时，我们只能从第 <code>i − 1</code> 行的最左侧移动过来。当 <code>j = i</code> 时，<code>f[i - 1][j]</code> 没有意义，因此状态转移方程为：</p>
<blockquote>
<p>f[i][i] = f[i − 1][i − 1] + c[i][i]</p>
</blockquote>
<p>即当我们在第 i 行的最右侧时，我们只能从第 <code>i − 1</code> 行的最右侧移动过来。<br>最终的答案即为 <code>f[n − 1][0]</code> 到 <code>f[n − 1][n − 1]</code> 中的最小值，其中 n 是三角形的行数。<br>边界条件为：</p>
<blockquote>
<p>f[0][0] = c[0][0]</p>
</blockquote>
<p>即在三角形的顶部时，最小路径和就等于对应位置的元素值。这样一来，我们从 1 开始递增地枚举 i，并在 <code>[0, i]</code> 的范围内递增地枚举 j，就可以完成所有状态的计算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = triangle.size();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + triangle.get(i).get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">            dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]) + triangle.get(i).get(j);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][i] = dp[i - <span class="number">1</span>][i - <span class="number">1</span>] + triangle.get(i).get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> minTotal = dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        minTotal = Math.min(minTotal, dp[n - <span class="number">1</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minTotal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(n²)，其中 n 是三角形的行数。</li>
<li>空间复杂度：O(n²)，我们需要一个 n ∗ n 的二维数组存放所有的状态。</li>
</ul>
<h1 id="动态规划-自底向上"><a href="#动态规划-自底向上" class="headerlink" title="动态规划-自底向上"></a>动态规划-自底向上</h1><p>跟上述的方法一致，只不过我们采用自底向上的方法，状态转移方程为：</p>
<blockquote>
<p>dp[i][j] = min(dp[i + 1][j], dp[i + 1][j + 1]) + c[i][j]</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = triangle.size();</span><br><span class="line">    <span class="comment">// 多申请1空间防止越界</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            dp[i][j] = Math.min(dp[i + <span class="number">1</span>][j], dp[i + <span class="number">1</span>][j + <span class="number">1</span>]) + triangle.get(i).get(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(n²)，其中 n 是三角形的行数。</li>
<li>空间复杂度：O(n²)，我们需要一个 n ∗ n 的二维数组存放所有的状态。</li>
</ul>
<h1 id="动态规划-空间优化"><a href="#动态规划-空间优化" class="headerlink" title="动态规划-空间优化"></a>动态规划-空间优化</h1><p>在上述代码中，我们定义了一个 N 行 N 列 的 dp 数组（N 是三角形的行数）。但是在实际递推中我们发现，计算 <code>dp[i][j]</code> 时，只用到了下一行的 <code>dp[i + 1][j]</code> 和 <code>dp[i + 1][j + 1]</code>。因此 dp 数组不需要定义 N 行，只要定义 1 行就行。所以我们稍微修改一下上述代码，将 i 所在的维度去掉（如下），就可以将 O(N²) 的空间复杂度优化成 O(N)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = triangle.size();</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            dp[j] = Math.min(dp[j], dp[j + <span class="number">1</span>]) + triangle.get(i).get(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(n²)，其中 n 是三角形的行数。</li>
<li>空间复杂度：O(n)，我们需要一个 n 的一维数组存放所有的状态。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/triangle/" title="三角形最小路径和 | 力扣（LeetCode）">三角形最小路径和 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/triangle/solution/di-gui-ji-yi-hua-dp-bi-xu-miao-dong-by-sweetiee/" title="三角形最小路径和 | 题解（LeetCode）">三角形最小路径和 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/07/14/triangle/' title='三角形最小路径和' >三角形最小路径和</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/07/14/triangle/' title='三角形最小路径和' >http://www.cylong.com/blog/2020/07/14/triangle/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>数组</tag>
        <tag>递归</tag>
        <tag>记忆化</tag>
        <tag>动态规划</tag>
        <tag>滚动数组</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树的第k大节点</title>
    <url>/blog/2020/07/15/kda-jie-dian-lcof/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3, 1, 4, null, 2], k &#x3D; 1</span><br><span class="line">   3</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [5, 3, 6, 2, 4, null, null, 1], k &#x3D; 3</span><br><span class="line">       5</span><br><span class="line">      &#x2F; \</span><br><span class="line">     3   6</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   4</span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p>限制：<br>1 ≤ k ≤ 二叉搜索树元素个数</p>
<a id="more"></a>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>二叉搜索树的中序遍历是递增序列，那么倒序就是递减序列。</p>
<blockquote>
<p>中序遍历为“左、根、右”的顺序<br>中序遍历的倒序为“右、根、左”的顺序</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    dfs(root.left); <span class="comment">// 左</span></span><br><span class="line">    System.out.println(root.val); <span class="comment">// 根</span></span><br><span class="line">    dfs(root.right); <span class="comment">// 右</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们只要求出二叉搜索树的中序遍历倒序的第k个节点即可。</p>
<p><strong>递归解析：</strong></p>
<ul>
<li>递归的终止条件：当节点为空的时候，越过了叶子节点，则直接返回;</li>
<li>递归右子树：dfs(root.right);</li>
<li>递归操作：先进行k - 1，然后判断 k 是否等于0，是则找到第k大的节点，将节点的值返回。</li>
<li>递归左子树：dfs(root.left);</li>
</ul>
<img src="/blog/2020/07/15/kda-jie-dian-lcof/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.png" class="" title="中序遍历">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.k = k;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(t.right);</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (--k == <span class="number">0</span>) &#123;</span><br><span class="line">        res = t.val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(t.left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度 Ο(N) ： 当树退化为链表时（全部为右子节点），无论 k 的值大小，递归深度都为 N ，占用 Ο(N) 时间。</li>
<li>空间复杂度 Ο(N) ： 当树退化为链表时（全部为右子节点），系统使用 Ο(N) 大小的栈空间。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/" title="二叉搜索树的第k大节点 | 力扣（LeetCode）">二叉搜索树的第k大节点 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/solution/mian-shi-ti-54-er-cha-sou-suo-shu-de-di-k-da-jie-d/" title="二叉搜索树的第k大节点 | 题解（LeetCode）">二叉搜索树的第k大节点 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/07/15/kda-jie-dian-lcof/' title='二叉搜索树的第k大节点' >二叉搜索树的第k大节点</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/07/15/kda-jie-dian-lcof/' title='二叉搜索树的第k大节点' >http://www.cylong.com/blog/2020/07/15/kda-jie-dian-lcof/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>递归</tag>
        <tag>剑指Offer</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
        <tag>深度优先搜索</tag>
        <tag>中序遍历</tag>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>反转链表</title>
    <url>/blog/2020/07/16/reverse-linked-list/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>反转一个单链表。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
</blockquote>
<p><strong>进阶:</strong></p>
<blockquote>
<p>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p>
</blockquote>
<a id="more"></a>

<h1 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h1><p>假设存在链表 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL，我们想要把它改成 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL。在遍历列表时，将当前节点的 next 指针改为指向前一个元素。由于节点没有引用其上一个节点，因此必须事先存储其前一个元素。在更改引用之前，还需要另一个指针来存储下一个节点。不要忘记在最后返回新的头引用！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode next = curr.next;</span><br><span class="line">        curr.next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：Ο(N)，其中 N 是列表的长度。</li>
<li>空间复杂度：Ο(1)。</li>
</ul>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>假设节点n后面的链表均被反转，那么我需要将n的下一个节点指向n，于是有 <code>n.next.next = n</code> ，然后将n的下一个节点指向null，既 <code>n.next = null</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode res = reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：Ο(N)，其中 N 是列表的长度。</li>
<li>空间复杂度：Ο(N)。由于使用递归，将会使用隐式栈空间。递归深度可能会达到 N 层。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/reverse-linked-list/" title="反转链表 | 力扣（LeetCode）">反转链表 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-by-leetcode/" title="反转链表 | 题解（LeetCode）">反转链表 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/07/16/reverse-linked-list/' title='反转链表' >反转链表</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/07/16/reverse-linked-list/' title='反转链表' >http://www.cylong.com/blog/2020/07/16/reverse-linked-list/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>链表</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>最小路径和</title>
    <url>/blog/2020/07/23/minimum-path-sum/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p><strong>说明：</strong> 每次只能向下或者向右移动一步。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>此题是典型的动态规划问题，由于路径的方向只能是向下或向右，因此网格的第一行的每个元素只能从左上角元素开始向右移动到达，网格的第一列的每个元素只能从左上角元素开始向下移动到达，此时的路径是唯一的，因此每个元素对应的最小路径和即为对应的路径上的数字总和。对于不在第一行和第一列的元素，可以从其上方相邻元素向下移动一步到达，或者从其左方相邻元素向右移动一步到达，元素对应的最小路径和等于其上方相邻元素与其左方相邻元素两者对应的最小路径和中的最小值加上当前元素的值。</p>
<p>创建二维数组 dp，与原始网格的大小相同，dp[i][j] 表示从左上角出发到 (i, j) 位置的最小路径和。显然，dp[0][0]=grid[0][0]。对于 dp 中的其余元素，通过以下状态转移方程计算元素值。</p>
<ul>
<li>当 i &gt; 0 且 j = 0 时，dp[i][0] = dp[i − 1][0] + grid[i][0]。</li>
<li>当 i = 0 且 j &gt; 0 时，dp[0][j] = dp[0][j − 1] + grid[0][j]。</li>
<li>当 i &gt; 0 且 j &gt; 0 时，dp[i][j] = min(dp[i − 1][j], dp[i][j − 1]) + grid[i][j]。</li>
</ul>
<p>最后得到 dp[m − 1][n − 1] 的值即为从网格左上角到网格右下角的最小路径和。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> row = grid.length;</span><br><span class="line">    <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = grid[i][<span class="number">0</span>] + dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = grid[<span class="number">0</span>][j] + dp[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">            dp[i][j] = grid[i][j] + Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[row - <span class="number">1</span>][col - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：Ο(mn)，其中 m 和 n 分别是网格的行数和列数。需要对整个网格遍历一次，计算 dp 的每个元素的值。</li>
<li>空间复杂度：O(mn)，其中 m 和 n 分别是网格的行数和列数。创建一个二维数组 dp，和网格大小相同。空间复杂度可以优化，例如每次只存储上一行的 dp 值，则可以将空间复杂度优化到 O(n)。</li>
</ul>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>在我不会动态规划之前，其实第一次想到的会是递归处理，不过现在会了，还是动态规划香哈哈哈，在这里我仅仅说一下递归解题思路。</p>
<p>我们从 [0, 0] 坐标出发，最短路径是 <code>f[0][0] + min(f[0][1], f[1][0])</code> ，针对 f[0][1] 和 f[1][0] 继续进行递归处理。这里需要注意的一点是，我们在计算 f<a href="https://leetcode-cn.com/problems/minimum-path-sum/" title="最小路径和 | 力扣（LeetCode）">0</a> 和 f[1][0] 的时候，会重复计算 f[0][1]，所以我们使用一个 min[i][j] 数组保存 [i, j] 坐标到右下角的最小路径，这样就避免的重复计算。</p>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/minimum-path-sum/" title="最小路径和 | 力扣（LeetCode）">最小路径和 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/minimum-path-sum/solution/zui-xiao-lu-jing-he-by-leetcode-solution/" title="最小路径和 | 题解（LeetCode）">最小路径和 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/07/23/minimum-path-sum/' title='最小路径和' >最小路径和</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/07/23/minimum-path-sum/' title='最小路径和' >http://www.cylong.com/blog/2020/07/23/minimum-path-sum/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>数组</tag>
        <tag>递归</tag>
        <tag>记忆化</tag>
        <tag>动态规划</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>除数博弈</title>
    <url>/blog/2020/07/24/divisor-game/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：</p>
<ul>
<li>选出任一 x，满足 0 &lt; x &lt; N 且 N % x == 0 。</li>
<li>用 N - x 替换黑板上的数字 N 。</li>
</ul>
<p>如果玩家无法执行这些操作，就会输掉游戏。只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 False。假设两个玩家都以最佳状态参与游戏。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：2<br>输出：true<br>解释：爱丽丝选择 1，鲍勃无法进行操作。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：3<br>输出：false<br>解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= N &lt;= 1000</li>
</ul>
<a id="more"></a>

<h1 id="归纳法"><a href="#归纳法" class="headerlink" title="归纳法"></a>归纳法</h1><p>博弈类的问题常常让我们摸不着头脑。当我们没有解题思路的时候，不妨试着写几项试试：</p>
<ul>
<li>N = 1 的时候，区间 (0, 1) 中没有整数是 n 的因数，所以此时 Alice 败。</li>
<li>N = 2 的时候，Alice 只能拿 1，N 变成 1，Bob 无法继续操作，故 Alice 胜。</li>
<li>N = 3 的时候，Alice 只能拿 1，N 变成 2，根据 N = 2 的结论，我们知道此时 Bob 会获胜，Alice 败。</li>
<li>N = 4 的时候，Alice 能拿 1 或 2，如果 Alice 拿 1，根据 N = 3 的结论，Bob 会失败，Alice 会获胜。</li>
<li>N = 5 的时候，Alice 只能拿 1，根据 N = 4 的结论，Alice 会失败。</li>
<li>……</li>
</ul>
<p>写到这里，也许你有了一些猜想。没关系，请大胆地猜想，在这种情况下大胆地猜想是 AC 的第一步。也许你会发现这样一个现象：N 为奇数的时候 Alice（先手）必败，N 为偶数的时候 Alice 必胜。 这个猜想是否正确呢？下面我们来想办法证明它。</p>
<p><strong>证明</strong></p>
<ol>
<li>N = 1 和 N = 2 时结论成立。</li>
<li>N &gt; 2 时，假设 N ≤ k 时该结论成立，则 N = k + 1 时：<ul>
<li>如果 k 为偶数，则 k + 1 为奇数，x 是 k + 1 的因数，只可能是奇数，而奇数减去奇数等于偶数，且 k + 1 - x ≤ k，故轮到 Bob 的时候都是偶数。而根据我们的猜想假设 N ≤ k 的时候偶数的时候先手必胜，故此时无论 Alice 拿走什么，Bob 都会处于必胜态，所以 Alice 处于必败态。</li>
<li>如果 k 为奇数，则 k + 1 为偶数，x 可以是奇数也可以是偶数，若 Alice 减去一个奇数，那么 k + 1 - x 是一个小于等于 k 的奇数，此时 Bob 占有它，处于必败态，则 Alice 处于必胜态。</li>
</ul>
</li>
</ol>
<p>综上所述，这个猜想是正确的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">bool <span class="title">divisorGame</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：Ο(1)。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h1 id="递推"><a href="#递推" class="headerlink" title="递推"></a>递推</h1><p>上述方法中，我们写出了前面几项的答案，在这个过程中我们发现，Alice 处在 N = k 的状态时，他（她）做一步操作，必然使得 Bob 处于 N = m (m &lt; k) 的状态。因此我们只要看是否存在一个 m 是必败的状态，那么 Alice 直接执行对应的操作让当前的数字变成 m，Alice 就必胜了，如果没有任何一个是必败的状态的话，说明 Alice 无论怎么进行操作，最后都会让 Bob 处于必胜的状态，此时 Alice 是必败的。</p>
<p>结合以上我们定义 f[i] 表示当前数字 i 的时候先手是处于必胜态还是必败态，true 表示先手必胜，false 表示先手必败，从前往后递推，根据我们上文的分析，枚举 i 在 (0, i) 中 i 的因数 j，看是否存在 f[i-j] 为必败态即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">divisorGame</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[N + <span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="keyword">false</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i % j == <span class="number">0</span>) &amp;&amp; !dp[i - j]) &#123;</span><br><span class="line">                dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：Ο(n²)，递推的时候一共有 n 个状态要计算，每个状态需要 O(n) 的时间枚举因数。</li>
<li>空间复杂度：O(n)，我们需要 O(n) 的空间存储递推数组 f 的值。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/divisor-game/" title="除数博弈 | 力扣（LeetCode）">除数博弈 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/divisor-game/solution/chu-shu-bo-yi-by-leetcode-solution/" title="除数博弈 | 题解（LeetCode）">除数博弈 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/07/24/divisor-game/' title='除数博弈' >除数博弈</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/07/24/divisor-game/' title='除数博弈' >http://www.cylong.com/blog/2020/07/24/divisor-game/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>数学归纳法</tag>
      </tags>
  </entry>
  <entry>
    <title>判断子序列</title>
    <url>/blog/2020/07/27/is-subsequence/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ≈ 500,000），而 s 是个短字符串（长度 &lt;= 100）。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p>
<p><strong>示例 1:</strong></p>
<blockquote>
<p>s = “abc”, t = “ahbgdc”<br>返回 true.</p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p>s = “axc”, t = “ahbgdc”<br>返回 false.</p>
</blockquote>
<a id="more"></a>

<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><p>我们使用双指针i和j分别指向短的字符串和长的字符串，移动规则是，当<code>s[i] == t[j]</code>的时候，同时移动i和j，否则，我们不断的移动j指针，直到找到<code>s[i] == t[j]</code>，然后同时移动i和j，直到遍历完字符串s。最后，如果s是t的子串，那么j一定小于t.length。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubsequence</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] sArr = s.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] tArr = t.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; sArr.length; i++, j++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; tArr.length &amp;&amp; sArr[i] != tArr[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 题目中在for循环中同时操作i++和j++，所以此处是小于等于的关系</span></span><br><span class="line">    <span class="keyword">return</span> j &lt;= tArr.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(n + m)，其中 n 为 s 的长度，m 为 t 的长度。每次无论是匹配成功还是失败，都有至少一个指针发生右移，两指针能够位移的总距离为 n + m。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/is-subsequence/" title="判断子序列 | 力扣（LeetCode）">判断子序列 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/is-subsequence/solution/pan-duan-zi-xu-lie-by-leetcode-solution/" title="判断子序列 | 题解（LeetCode）">判断子序列 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/07/27/is-subsequence/' title='判断子序列' >判断子序列</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/07/27/is-subsequence/' title='判断子序列' >http://www.cylong.com/blog/2020/07/27/is-subsequence/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>字符串</tag>
        <tag>指针</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>验证二叉搜索树</title>
    <url>/blog/2020/07/15/validate-binary-search-tree/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。假设一个二叉搜索树具有如下特征：</p>
<ul>
<li>节点的左子树只包含小于当前节点的数。</li>
<li>节点的右子树只包含大于当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   4</span><br><span class="line">     &#x2F; \</span><br><span class="line">    3   6</span><br><span class="line">输出: false</span><br><span class="line">解释: 输入为: [5, 1, 4, null, null, 3, 6]。根节点的值为 5 ，但是其右子节点值为 4 。</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>由题目给出的信息我们可以知道：如果该二叉树的左子树不为空，则左子树上所有节点的值均小于它的根节点的值；若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；它的左右子树也为二叉搜索树。</p>
<p>于是我们设计一个递归函数 <code>isValidBST(root, lower, upper)</code> 来递归判断，函数表示考虑以 root 为根的子树，判断子树中所有节点的值是否都在 (l, r) 的范围内（注意是开区间）。如果 root 节点的值 val 不在 ((l, r) 的范围内说明不满足条件直接返回，否则我们要继续递归调用检查它的左右子树是否满足，如果都满足才说明这是一棵二叉搜索树。</p>
<p>那么根据二叉搜索树的性质，在递归调用左子树时，我们需要把上界 upper 改为 root.val，即调用 <code>isValidBST(root.left, lower, root.val)</code>，因为左子树里所有节点的值均小于它的根节点的值。同理递归调用右子树时，我们需要把下界 lower 改为 root.val，即调用 <code>isValidBST(root.right, root.val, upper)</code>。函数递归调用的入口为 <code>isValidBST(root, -inf, +inf)</code>， inf 表示一个无穷大的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 无穷大和无穷小用null表示，这里不能用Integer.MAX_VALUE和Integer.MIN_VALUE</span></span><br><span class="line">    <span class="keyword">return</span> isValidBST(root, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode node, Integer lower, Integer upper)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> val = node.val;</span><br><span class="line">    <span class="keyword">if</span> (lower != <span class="keyword">null</span> &amp;&amp; val &lt;= lower) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (upper != <span class="keyword">null</span> &amp;&amp; val &gt;= upper) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isValidBST(node.right, val, upper)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isValidBST(node.left, lower, val)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(n)，其中 n 为二叉树的节点个数。在递归调用的时候二叉树的每个节点最多被访问一次，因此时间复杂度为 O(n)。</li>
<li>空间复杂度：O(n)，其中 n 为二叉树的节点个数。递归函数在递归过程中需要为每一层递归函数分配栈空间，所以这里需要额外的空间且该空间取决于递归的深度，即二叉树的高度。最坏情况下二叉树为一条链，树的高度为 n ，递归最深达到 n 层，故最坏情况下空间复杂度为 O(n) 。</li>
</ul>
<h1 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h1><p>我们知道二叉搜索树「中序遍历」得到的值构成的序列一定是升序的，中序遍历是二叉树的一种遍历方式，它先遍历左子树，再遍历根节点，最后遍历右子树。而我们二叉搜索树保证了左子树的节点的值均小于根节点的值，根节点的值均小于右子树的值，因此中序遍历以后得到的序列一定是升序序列。这启示我们在中序遍历的时候实时检查当前节点的值是否大于前一个中序遍历到的节点的值即可。如果均大于说明这个序列是升序的，整棵树是二叉搜索树，否则不是。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> pre = Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 访问左子树</span></span><br><span class="line">    <span class="keyword">if</span> (!isValidBST(root.left)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 访问当前节点：如果当前节点小于等于中序遍历的前一个节点，说明不满足BST，返回 false；否则继续遍历。</span></span><br><span class="line">    <span class="keyword">if</span> (root.val &lt;= pre) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = root.val;</span><br><span class="line">    <span class="comment">// 访问右子树</span></span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(n)，其中 n 为二叉树的节点个数。在递归调用的时候二叉树的每个节点最多被访问一次，因此时间复杂度为 O(n)。</li>
<li>空间复杂度：O(n)，其中 n 为二叉树的节点个数。递归函数在递归过程中需要为每一层递归函数分配栈空间，所以这里需要额外的空间且该空间取决于递归的深度，即二叉树的高度。最坏情况下二叉树为一条链，树的高度为 n ，递归最深达到 n 层，故最坏情况下空间复杂度为 O(n) 。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" title="验证二叉搜索树 | 力扣（LeetCode）">验证二叉搜索树 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/solution/yan-zheng-er-cha-sou-suo-shu-by-leetcode-solution/" title="验证二叉搜索树 | 题解（LeetCode）">验证二叉搜索树 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/07/15/validate-binary-search-tree/' title='验证二叉搜索树' >验证二叉搜索树</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/07/15/validate-binary-search-tree/' title='验证二叉搜索树' >http://www.cylong.com/blog/2020/07/15/validate-binary-search-tree/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>递归</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
        <tag>深度优先搜索</tag>
        <tag>中序遍历</tag>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>有效的括号</title>
    <url>/blog/2020/07/27/valid-parentheses/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。有效字符串需满足：</p>
<ul>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
</ul>
<p><strong>注意：</strong> 空字符串可被认为是有效字符串。</p>
<p><strong>示例 1:</strong></p>
<blockquote>
<p>输入: “()”<br>输出: true</p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p>输入: “()[]{}”<br>输出: true</p>
</blockquote>
<p><strong>示例 3:</strong></p>
<blockquote>
<p>输入: “(]”<br>输出: false</p>
</blockquote>
<p><strong>示例 4:</strong></p>
<blockquote>
<p>输入: “([)]”<br>输出: false</p>
</blockquote>
<p><strong>示例 5:</strong></p>
<blockquote>
<p>输入: “{[]}”<br>输出: true</p>
</blockquote>
<a id="more"></a>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>括号匹配是典型的代码分析问题，我们遍历字符串，每次处理一个括号，使用栈来保存这个括号。同时我们使用一个map来保存三种括号的开括号和闭括号。每次处理当前括号的时候，我们判断当前栈顶的元素是否是此括号对应的开括号，是的话，我们将弹出栈顶元素。否则我们将当前括号入栈。最后，如果栈的元素为空，那么可知此字符串是有效的字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Character&gt; parenthesesStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    HashMap&lt;Character, Character&gt; parenthesesMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    parenthesesMap.put(<span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    parenthesesMap.put(<span class="string">&#x27;[&#x27;</span>, <span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">    parenthesesMap.put(<span class="string">&#x27;&#123;&#x27;</span>, <span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> parentheses : s.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!parenthesesStack.isEmpty() &amp;&amp; Character.valueOf(parentheses)</span><br><span class="line">                .equals(parenthesesMap.get(parenthesesStack.peek()))) &#123;</span><br><span class="line">            parenthesesStack.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parenthesesStack.push(parentheses);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parenthesesStack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(n)，因为我们一次只遍历给定的字符串中的一个字符并在栈上进行 O(1) 的推入和弹出操作。</li>
<li>空间复杂度：O(n)，当我们将所有的开括号都推到栈上时以及在最糟糕的情况下，我们最终要把所有括号推到栈上。例如 ((((((((((。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/valid-parentheses/" title="有效的括号 | 力扣（LeetCode）">有效的括号 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/valid-parentheses/solution/you-xiao-de-gua-hao-by-leetcode/" title="有效的括号 | 题解（LeetCode）">有效的括号 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/07/27/valid-parentheses/' title='有效的括号' >有效的括号</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/07/27/valid-parentheses/' title='有效的括号' >http://www.cylong.com/blog/2020/07/27/valid-parentheses/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>字符串</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的最大深度</title>
    <url>/blog/2020/07/28/maximum-depth-of-binary-tree/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定二叉树 [3, 9, 20, null, null, 15, 7]，</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">返回它的最大深度 3 。</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h1><p>我们可以发现，给定一个二叉树t，它的最大深度是左子树l和右子树r的最大深度中的较大值加一，针对左子树和右子树，同样进行递归处理。递归的终止条件是访问到空节点，此时返回深度0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(n)，其中 n 为二叉树节点的个数。每个节点在递归中只被遍历一次。</li>
<li>空间复杂度：O(h)，其中 h 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。</li>
</ul>
<h1 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h1><p>我们也可以用「广度优先搜索」的方法来解决这道题目，但我们需要对其进行一些修改，此时我们广度优先搜索的队列里存放的是「当前层的所有节点」。每次拓展下一层的时候，不同于广度优先搜索的每次只从队列里拿出一个节点，我们需要将队列里的所有节点都拿出来进行拓展，这样能保证每次拓展完的时候队列里存放的是当前层的所有节点，即我们是一层一层地进行拓展，最后我们用一个变量 ans 来维护拓展的次数，该二叉树的最大深度即为 ans。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(n)，其中 n 为二叉树节点的个数。每个节点只会被访问一次。</li>
<li>空间复杂度：O(n)，此方法空间的消耗取决于队列存储的元素数量，其在最坏情况下会达到 O(n)。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" title="二叉树的最大深度 | 力扣（LeetCode）">二叉树的最大深度 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/er-cha-shu-de-zui-da-shen-du-by-leetcode-solution/" title="二叉树的最大深度 | 题解（LeetCode）">二叉树的最大深度 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/07/28/maximum-depth-of-binary-tree/' title='二叉树的最大深度' >二叉树的最大深度</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/07/28/maximum-depth-of-binary-tree/' title='二叉树的最大深度' >http://www.cylong.com/blog/2020/07/28/maximum-depth-of-binary-tree/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>队列</tag>
        <tag>递归</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
        <tag>深度优先搜索</tag>
        <tag>广度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>扫雷游戏</title>
    <url>/blog/2020/07/28/minesweeper/</url>
    <content><![CDATA[<hr>
<h1 id="題目描述"><a href="#題目描述" class="headerlink" title="題目描述"></a>題目描述</h1><p>让我们一起来玩扫雷游戏！</p>
<p>给定一个代表游戏板的二维字符矩阵。 ‘M’ 代表一个未挖出的地雷，’E’ 代表一个未挖出的空方块，’B’ 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的已挖出的空白方块，数字（’1’ 到 ‘8’）表示有多少地雷与这块已挖出的方块相邻，’X’ 则表示一个已挖出的地雷。现在给出在所有未挖出的方块中（’M’或者’E’）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板：</p>
<ol>
<li>如果一个地雷（’M’）被挖出，游戏就结束了- 把它改为 ‘X’。</li>
<li>如果一个没有相邻地雷的空方块（’E’）被挖出，修改它为（’B’），并且所有和其相邻的未挖出方块都应该被递归地揭露。</li>
<li>如果一个至少与一个地雷相邻的空方块（’E’）被挖出，修改它为数字（’1’到’8’），表示相邻地雷的数量。</li>
<li>如果在此次点击中，若无更多方块可被揭露，则返回面板。</li>
</ol>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line"></span><br><span class="line">[[&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;],</span><br><span class="line"> [&#39;E&#39;, &#39;E&#39;, &#39;M&#39;, &#39;E&#39;, &#39;E&#39;],</span><br><span class="line"> [&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;],</span><br><span class="line"> [&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;]]</span><br><span class="line"></span><br><span class="line">Click : [3,0]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"></span><br><span class="line">[[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;1&#39;, &#39;M&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]</span><br></pre></td></tr></table></figure>

<p><strong>解释:</strong></p>
<img src="/blog/2020/07/28/minesweeper/minesweeper_example_1.png" class="" title="示例1">

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line"></span><br><span class="line">[[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;1&#39;, &#39;M&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]</span><br><span class="line"></span><br><span class="line">Click : [1,2]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"></span><br><span class="line">[[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;1&#39;, &#39;X&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]</span><br></pre></td></tr></table></figure>

<p><strong>解释:</strong></p>
<img src="/blog/2020/07/28/minesweeper/minesweeper_example_2.png" class="" title="示例2">

<p><strong>注意：</strong></p>
<ol>
<li>输入矩阵的宽和高的范围为 [1, 50]。</li>
<li>点击的位置只能是未被挖出的方块 (‘M’ 或者 ‘E’)，这也意味着面板至少包含一个可点击的方块。</li>
<li>输入面板不会是游戏结束的状态（即有地雷已被挖出）。</li>
<li>简单起见，未提及的规则在这个问题中可被忽略。例如，当游戏结束时你不需要挖出所有地雷，考虑所有你可能赢得游戏或标记方块的情况。</li>
</ol>
<a id="more"></a>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>根据题意，我们点击某个方块后，如果是地雷 M，则直接修改为 X 返回。否则我们计算以当前点击的方块为中心的九宫格内地雷的数量，如果没有地雷，则我们将当前节点标记为 B 并递归处理当前节点九宫格内的其他节点。否则我们将当前节点标记为周围地雷的数量，并结束递归。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">char</span>[][] updateBoard(<span class="keyword">char</span>[][] board, <span class="keyword">int</span>[] click) &#123;</span><br><span class="line">    <span class="keyword">if</span> (board[click[<span class="number">0</span>]][click[<span class="number">1</span>]] == <span class="string">&#x27;M&#x27;</span>) &#123;</span><br><span class="line">        board[click[<span class="number">0</span>]][click[<span class="number">1</span>]] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> board;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        checkBoard(board, click[<span class="number">0</span>], click[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> board;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkBoard</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = board.length;</span><br><span class="line">    <span class="keyword">int</span> col = board[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span> (board[x][y] != <span class="string">&#x27;M&#x27;</span> &amp;&amp; board[x][y] != <span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    board[x][y] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计算点击节点的九宫格内地雷数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x - <span class="number">1</span>; i &lt;= x + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = y - <span class="number">1</span>; j &lt;= y + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; i &lt; row &amp;&amp; j &lt; col) &#123;</span><br><span class="line">                board[x][y] += (board[i][j] == <span class="string">&#x27;M&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果点击节点九宫格内没有地雷，则递归处理九宫格内其他的节点</span></span><br><span class="line">    <span class="keyword">if</span> (board[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">        board[x][y] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x - <span class="number">1</span>; i &lt;= x + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = y - <span class="number">1</span>; j &lt;= y + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; i &lt; row &amp;&amp; j &lt; col) &#123;</span><br><span class="line">                    checkBoard(board, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        board[x][y] += <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/minesweeper/" title="扫雷游戏 | 力扣（LeetCode）">扫雷游戏 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/minesweeper/solution/" title="扫雷游戏 | 题解（LeetCode）">扫雷游戏 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/07/28/minesweeper/' title='扫雷游戏' >扫雷游戏</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/07/28/minesweeper/' title='扫雷游戏' >http://www.cylong.com/blog/2020/07/28/minesweeper/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>数组</tag>
        <tag>递归</tag>
        <tag>矩阵</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>黄金矿工</title>
    <url>/blog/2020/07/30/path-with-maximum-gold/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为 m * n 的网格 grid 进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 0。为了使收益最大化，矿工需要按以下规则来开采黄金：</p>
<ul>
<li>每当矿工进入一个单元，就会收集该单元格中的所有黄金。</li>
<li>矿工每次可以从当前位置向上下左右四个方向走。</li>
<li>每个单元格只能被开采（进入）一次。</li>
<li>不得开采（进入）黄金数目为 0 的单元格。</li>
<li>矿工可以从网格中任意一个有黄金的单元格出发或者是停止。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid &#x3D; [[0, 6, 0], [5, 8, 7], [0, 9, 0]]</span><br><span class="line">输出：24</span><br><span class="line">解释：</span><br><span class="line">[[0, 6, 0],</span><br><span class="line"> [5, 8, 7],</span><br><span class="line"> [0, 9, 0]]</span><br><span class="line">一种收集最多黄金的路线是：9 -&gt; 8 -&gt; 7。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid &#x3D; [[1, 0, 7], [2, 0, 6], [3, 4, 5], [0, 3, 0], [9, 0, 20]]</span><br><span class="line">输出：28</span><br><span class="line">解释：</span><br><span class="line">[[1, 0, 7],</span><br><span class="line"> [2, 0, 6],</span><br><span class="line"> [3, 4, 5],</span><br><span class="line"> [0, 3, 0],</span><br><span class="line"> [9, 0, 20]]</span><br><span class="line">一种收集最多黄金的路线是：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= grid.length, grid[i].length &lt;= 15</li>
<li>0 &lt;= grid[i][j] &lt;= 100</li>
<li>最多 25 个单元格中有黄金。</li>
</ul>
<a id="more"></a>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先矿工可以从网格中任意一个有黄金的单元格出发或者是停止。于是我们将循环遍历网格全部的有黄金的点，作为起点。接下来，我们进行递归处理，每次递归的时候记录 gold 的值，传到下一次递归中，同时有一个全局变量 max 记录最大的黄金数，每次递归的总黄金数就是 <code>gold + grid[i][j]</code>。递归终止的时候，我们用 gold 值来更新 max 值。现在的问题是，我们如何处理递归的终止条件。这里，我们同时使用回溯算法，定义 boolean 型的二维数组 visit，每次递归的时候，我们将当前节点置为 true 表示当前节点已经访问，递归回溯的时候，我们置为 false，表示当前节点没有被访问。于是我们得到递归的终止条件如下：</p>
<ul>
<li>i &lt; 0 || i &gt;= grid.length</li>
<li>j &lt; 0 || j &gt;= grid[0].length</li>
<li>grid[i][j] == 0</li>
<li>visit[i][j] == true</li>
</ul>
<p>所有节点为起点，进行深度优先搜索，最终的 max 值就是最大黄金数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaximumGold</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[][] visit = <span class="keyword">new</span> <span class="keyword">boolean</span>[grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                dfsGetMaximumGold(grid, i, j, <span class="number">0</span>, visit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfsGetMaximumGold</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> gold, <span class="keyword">boolean</span>[][] visit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((i &lt; <span class="number">0</span> || i &gt;= grid.length) || (j &lt; <span class="number">0</span> || j &gt;= grid[<span class="number">0</span>].length) || grid[i][j] == <span class="number">0</span> || visit[i][j]) &#123;</span><br><span class="line">        max = Math.max(max, gold);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    gold += grid[i][j];</span><br><span class="line">    visit[i][j] = <span class="keyword">true</span>;</span><br><span class="line">    dfsGetMaximumGold(grid, i + <span class="number">1</span>, j, gold, visit);</span><br><span class="line">    dfsGetMaximumGold(grid, i - <span class="number">1</span>, j, gold, visit);</span><br><span class="line">    dfsGetMaximumGold(grid, i, j + <span class="number">1</span>, gold, visit);</span><br><span class="line">    dfsGetMaximumGold(grid, i, j - <span class="number">1</span>, gold, visit);</span><br><span class="line">    visit[i][j] = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/path-with-maximum-gold/" title="黄金矿工 | 力扣（LeetCode）">黄金矿工 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/path-with-maximum-gold/solution/" title="黄金矿工 | 题解（LeetCode）">黄金矿工 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/07/30/path-with-maximum-gold/' title='黄金矿工' >黄金矿工</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/07/30/path-with-maximum-gold/' title='黄金矿工' >http://www.cylong.com/blog/2020/07/30/path-with-maximum-gold/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>数组</tag>
        <tag>递归</tag>
        <tag>回溯算法</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串相加</title>
    <url>/blog/2020/08/03/add-strings/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定两个字符串形式的非负整数 num1 和 num2 ，计算它们的和。</p>
<p><strong>提示：</strong></p>
<ul>
<li>num1 和 num2 的长度都小于 5100</li>
<li>num1 和 num2 都只包含数字 0-9</li>
<li>num1 和 num2 都不包含任何前导零</li>
<li>你不能使用任何內建 BigInteger 库，也不能直接将输入的字符串转换为整数形式</li>
</ul>
<a id="more"></a>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>我们只需要对两个大整数模拟「竖式加法」的过程。竖式加法就是我们平常学习生活中常用地对两个整数相加的方法，回想一下我们在纸上对两个整数相加的操作，是不是如下图将相同数位对齐，从低到高逐位相加，如果当前位和超过 10，则向高位进一位？因此我们只要将这个过程用代码写出来即可。我们使用两个变量分别指向两个数的末尾，进行加法操作，同时使用 carry 保存进位，若两个字符串不一样长，我们两个字符串遍历完成后，要继续遍历未计算的字符串，最后，别忘了，如果进位是 1 的话，要把进位加到最终的结果中。</p>
<img src="/blog/2020/08/03/add-strings/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0.png" class="" title="字符串相加">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index1 = num1.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index2 = num2.length() - <span class="number">1</span>;</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index1 &gt;=<span class="number">0</span> &amp;&amp; index2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = num1.charAt(index1) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">int</span> n2 = num2.charAt(index2) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        carry = addNum(n1, n2, carry, res);</span><br><span class="line">        index1--;</span><br><span class="line">        index2--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (index1 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = num1.charAt(index1) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        carry = addNum(n1, <span class="number">0</span>, carry, res);</span><br><span class="line">        index1--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (index2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> n2 = num2.charAt(index2) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        carry = addNum(<span class="number">0</span>, n2, carry, res);</span><br><span class="line">        index2--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        res.append(carry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2, <span class="keyword">int</span> carry, StringBuilder res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = n1 + n2 + carry;</span><br><span class="line">    res.append(sum % <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> sum / <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，我们其实不需要这么长的代码，判断最后哪个字符串更长，针对短的字符串，我们进行补 0 操作即可。也不需要判断是否有进位，最后还要记得加上去。我们可以简化代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index1 = num1.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index2 = num2.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span> (index1 &gt;= <span class="number">0</span> || index2 &gt;= <span class="number">0</span> || carry != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = index1 &gt;= <span class="number">0</span> ? num1.charAt(index1) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = index2 &gt;= <span class="number">0</span> ? num2.charAt(index2) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = x + y + carry;</span><br><span class="line">        res.append(sum % <span class="number">10</span>);</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        index1--;</span><br><span class="line">        index2--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：Ο(max(m, n))，其中 m 和 n 分别是两个字符串的长度。竖式加法的次数取决于较大数的位数。</li>
<li>空间复杂度：O(n)。除答案外我们只需要常数空间存放若干的变量。但是解法中使用到了 StringBuilder，空间复杂度为 O(n)。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/add-strings/" title="字符串相加 | 力扣（LeetCode）">字符串相加 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/add-strings/solution/zi-fu-chuan-xiang-jia-by-leetcode-solution/" title="字符串相加 | 题解（LeetCode）">字符串相加 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/08/03/add-strings/' title='字符串相加' >字符串相加</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/08/03/add-strings/' title='字符串相加' >http://www.cylong.com/blog/2020/08/03/add-strings/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>魔术索引</title>
    <url>/blog/2020/08/04/magic-index-lcci/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>魔术索引。 在数组 A[0…n-1] 中，有所谓的魔术索引，满足条件 A[i] = i 。给定一个有序整数数组，编写一种方法找出魔术索引，若有的话，在数组 A 中找出一个魔术索引，如果没有，则返回 -1。若有多个魔术索引，返回索引值最小的一个。</p>
<p><strong>示例1:</strong></p>
<blockquote>
<p>输入: nums = [0, 2, 3, 4, 5]<br>输出: 0<br>说明: 0 下标的元素为 0</p>
</blockquote>
<p><strong>示例2:</strong></p>
<blockquote>
<p>输入: nums = [1, 1, 1]<br>输出: 1</p>
</blockquote>
<p><strong>说明:</strong></p>
<blockquote>
<p>nums 长度在 [1, 1000000] 之间</p>
</blockquote>
<a id="more"></a>

<h1 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h1><p>最简单的方法，我们只要从头遍历整个数组，找到最小的 A[i] = i 返回即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMagicIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == i) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(n)，其中 n 为数组的长度。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h1 id="二分查找剪枝"><a href="#二分查找剪枝" class="headerlink" title="二分查找剪枝"></a>二分查找剪枝</h1><p>本方法我们是进行一定程度的优化，在一些情况下会达到较优的时间复杂度，在最差情况下仍会退化成线性的时间复杂度。现在我们假设，题目中的魔术索引仅有一个，我们假设这个答案为 i，那么意味着 [0…i−1] 的值均小于自身的下标，[i+1…n−1] 的值均大于自身的下标【不理解的同学用反证法即可证明】。那么我们只要使用二分法查找数组中的元素，在 O(log n) 的时间内找到答案 A[i] = i 所在的下标。但是题目中魔术索引可能有多个，我们就需要对二分查找做一些处理。针对二分查找做一下剪枝，策略如下：</p>
<ul>
<li>每次我们选择数组中间的元素，如果当前中间元素左半部分有满足条件的答案，那么这个位置往后的右半边元素我们都不再考虑，只要寻找左半部分满足条件的答案即可。</li>
<li>接下来我们继续查看左半部分是否有满足条件的答案，否则如果没有的话我们仍然需要在右半边寻找，使用的策略同上。</li>
</ul>
<p>显然，此剪枝策略在 [−1, 0, 1, 2, 4] 这种答案为数组的最后一个元素的情况下会退化成线性的时间复杂度，但是在一些情况下会有不错的表现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMagicIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findMagicIndex(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMagicIndex</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[start] == start ? start : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> index = findMagicIndex(nums, start, mid);</span><br><span class="line">    <span class="keyword">if</span> (index != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> findMagicIndex(nums, mid + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：最坏情况下会达到 O(n) 的时间复杂度，其中 n 为数组的长度。</li>
<li>空间复杂度：递归函数的空间取决于调用的栈深度，而最坏情况下我们会递归 n 层，即栈深度为 O(n)，因此空间复杂度最坏情况下为 O(n)。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/magic-index-lcci/" title="魔术索引 | 力扣（LeetCode）">魔术索引 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/magic-index-lcci/solution/mo-zhu-suo-yin-by-leetcode-solution/" title="魔术索引 | 题解（LeetCode）">魔术索引 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/08/04/magic-index-lcci/' title='魔术索引' >魔术索引</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/08/04/magic-index-lcci/' title='魔术索引' >http://www.cylong.com/blog/2020/08/04/magic-index-lcci/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>数组</tag>
        <tag>递归</tag>
        <tag>程序员面试金典</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>课程表</title>
    <url>/blog/2020/08/05/course-schedule/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse - 1 。在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0, 1]。给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？</p>
<p><strong>示例 1:</strong></p>
<blockquote>
<p>输入: 2, [[1, 0]]<br>输出: true<br>解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。</p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p>输入: 2, [[1, 0], [0, 1]]<br>输出: false<br>解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</p>
</blockquote>
<a id="more"></a>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>本题是一道经典的「拓扑排序」问题。给定一个包含 n 个节点的有向图 G，我们给出它的节点编号的一种排列，如果满足：</p>
<blockquote>
<p>对于图 G 中的任意一条有向边 (u, v)，u 在排列中都出现在 v 的前面。那么称该排列是图 G 的「拓扑排序」。</p>
</blockquote>
<p>根据上述的定义，我们可以得出两个结论：</p>
<ul>
<li>如果图 G 中存在环（即图 G 不是「有向无环图」），那么图 G 不存在拓扑排序。这是因为假设图中存在环 x₁，x₂，x₃，……xn，x₁，那么 x₁ 在排列中必须出现在 xn 的前面，但是 xn 同时也出现在 x₁ 前面，因此不存在一个满足要求的排列，也就不存在拓扑排序。</li>
<li>如果图 G 是有向无环图，那么它的拓扑排序可能不止一种。举一个最极端的例子，如果图 G 值包含 n 个节点却没有任何边，那么任意一种编号的排列都可以作为拓扑排序。</li>
</ul>
<p>有了上述的简单分析，我们就可以将本题建模成一个求拓扑排序的问题了：</p>
<ul>
<li>我们将每一门课程看成一个节点；</li>
<li>如果想要学习课程 A 之前必须完成课程 B，那么我们从 B 到 A 连接一条有向边。这样以来，在拓扑排序中，B 一定出现在 A 的前面。</li>
</ul>
<h1 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h1><p>对于图中的任意一个节点，它在搜索的过程中有三种状态，即：</p>
<ul>
<li>「未搜索」：我们还没有搜索到这个节点；</li>
<li>「搜索中」：我们搜索过这个节点，但还没有回溯到该节点，即该节点还没有入栈，还有相邻的节点没有搜索完成）；</li>
<li>「已完成」：我们搜索过并且回溯过这个节点，即该节点已经入栈，并且所有该节点的相邻节点都出现在栈的更底部的位置，满足拓扑排序的要求。</li>
</ul>
<p>通过上述的三种状态，我们就可以给出使用深度优先搜索得到拓扑排序的算法流程，在每一轮的搜索搜索开始时，我们任取一个「未搜索」的节点开始进行深度优先搜索。</p>
<ul>
<li>我们将当前搜索的节点 u 标记为「搜索中」，遍历该节点的每一个相邻节点 v：</li>
<li>如果 v 为「未搜索」，那么我们开始搜索 v，待搜索完成回溯到 u；</li>
<li>如果 v 为「搜索中」，那么我们就找到了图中的一个环，因此是不存在拓扑排序的；</li>
<li>如果 v 为「已完成」，那么说明 v 已经在栈中了，而 u 还不在栈中，因此 u 无论何时入栈都不会影响到 (u, v) 之前的拓扑关系，以及不用进行任何操作。</li>
<li>当 u 的所有相邻节点都为「已完成」时，我们将 u 放入栈中，并将其标记为「已完成」。</li>
</ul>
<p>在整个深度优先搜索的过程结束后，如果我们没有找到图中的环，那么栈中存储这所有的 n 个节点，从栈顶到栈底的顺序即为一种拓扑排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; edges;</span><br><span class="line"><span class="keyword">int</span>[] visited;</span><br><span class="line"><span class="keyword">boolean</span> valid = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">    edges = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">        edges.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] info : prerequisites) &#123;</span><br><span class="line">        edges.get(info[<span class="number">1</span>]).add(info[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            dfsCourse(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> valid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfsCourse</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    visited[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : edges.get(u)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[v] == <span class="number">0</span>) &#123;</span><br><span class="line">            dfsCourse(v);</span><br><span class="line">            <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) &#123;</span><br><span class="line">            valid = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[u] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度: O(n + m)，其中 n 为课程数，m 为先修课程的要求数。这其实就是对图进行深度优先搜索的时间复杂度。</li>
<li>空间复杂度: O(n + m)。题目中是以列表形式给出的先修课程关系，为了对图进行深度优先搜索，我们需要存储成邻接表的形式，空间复杂度为 O(n + m)。在深度优先搜索的过程中，我们需要最多 O(n) 的栈空间（递归）进行深度优先搜索，因此总空间复杂度为 O(n + m)。</li>
</ul>
<h1 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h1><p>拓扑排序也可以使用广度优先搜索实现。我们考虑拓扑排序中最前面的节点，该节点一定不会有任何入边，也就是它没有任何的先修课程要求。当我们将一个节点加入答案中后，我们就可以移除它的所有出边，代表着它的相邻节点少了一门先修课程的要求。如果某个相邻节点变成了「没有任何入边的节点」，那么就代表着这门课可以开始学习了。按照这样的流程，我们不断地将没有入边的节点加入答案，直到答案中包含所有的节点（得到了一种拓扑排序）或者不存在没有入边的节点（图中包含环）。</p>
<p>我们使用一个队列来进行广度优先搜索。初始时，所有入度为 0 的节点都被放入队列中，它们就是可以作为拓扑排序最前面的节点，并且它们之间的相对顺序是无关紧要的。在广度优先搜索的每一步中，我们取出队首的节点 u：</p>
<ul>
<li>我们将 u 放入答案中；</li>
<li>我们移除 u 的所有出边，也就是将 u 的所有相邻节点的入度减少 1。如果某个相邻节点 v 的入度变为 0，那么我们就将 v 放入队列中。</li>
</ul>
<p>在广度优先搜索的过程结束后。如果答案中包含了这 n 个节点，那么我们就找到了一种拓扑排序，否则说明图中存在环，也就不存在拓扑排序了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; edges = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] degree = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        edges.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] courseRelation : prerequisites) &#123;</span><br><span class="line">        edges.get(courseRelation[<span class="number">1</span>]).add(courseRelation[<span class="number">0</span>]);</span><br><span class="line">        degree[courseRelation[<span class="number">0</span>]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; degree.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (degree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            queue.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> visited = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        visited++;</span><br><span class="line">        <span class="keyword">int</span> beforeCourse = queue.poll();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> afterCourse : edges.get(beforeCourse)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--degree[afterCourse] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.offer(afterCourse);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> visited == numCourses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度: O(n + m)，其中 n 为课程数，m 为先修课程的要求数。这其实就是对图进行广度优先搜索的时间复杂度。</li>
<li>空间复杂度: O(n + m)。题目中是以列表形式给出的先修课程关系，为了对图进行广度优先搜索，我们需要存储成邻接表的形式，空间复杂度为 O(n + m)。在广度优先搜索的过程中，我们需要最多 O(n) 的队列空间（迭代）进行广度优先搜索。因此总空间复杂度为 O(n + m)。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/course-schedule/" title="课程表 | 力扣（LeetCode）">课程表 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/course-schedule/solution/ke-cheng-biao-by-leetcode-solution/" title="课程表 | 题解（LeetCode）">课程表 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/08/05/course-schedule/' title='课程表' >课程表</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/08/05/course-schedule/' title='课程表' >http://www.cylong.com/blog/2020/08/05/course-schedule/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>数组</tag>
        <tag>递归</tag>
        <tag>回溯算法</tag>
        <tag>深度优先搜索</tag>
        <tag>广度优先搜索</tag>
        <tag>图</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>计数二进制子串</title>
    <url>/blog/2020/08/10/count-binary-substrings/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。重复出现的子串要计算它们出现的次数。</p>
<p><strong>示例 1:</strong></p>
<blockquote>
<p>输入: “00110011”<br>输出: 6<br>解释: 有 6 个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。<br>请注意，一些重复出现的子串要计算它们出现的次数。<br>另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。</p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p>输入: “10101”<br>输出: 4<br>解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。</p>
</blockquote>
<p><strong>注意：</strong></p>
<blockquote>
<p>s.length 在1到50,000之间。<br>s 只包含“0”或“1”字符。</p>
</blockquote>
<a id="more"></a>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>刚开始看到，可能没什么思路，但是我们仔细阅读题目，可以慢慢找到规律，首先针对一个满足题意的子串，假如是“000111”，那么满足题意的子串就同时有三种，“000111”和“0011”和“01”。可以发现，满足条件的子串，是以01为中心，左边不断补0，右边不断补1而成，每补一次，就多一个满足条件的子串。针对以10为中心同理。所以我们只要找到位置 i 的字符串和位置 i + 1 的字符串不等，并以此为中心左右扩展，左边的字符等于位置 i 的字符，右边的字符等于位置 i + 1 的字符。扩展一次，满足条件的子串次数就加一。遍历完全部字符后，就能得到答案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countBinarySubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] sArr = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sArr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sArr[i] != sArr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = i;</span><br><span class="line">            <span class="keyword">int</span> n = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (m &gt;= <span class="number">0</span> &amp;&amp; n &lt; sArr.length &amp;&amp; sArr[m--] == sArr[i] &amp;&amp; sArr[n++] == sArr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(n)。</li>
<li>空间复杂度：O(n)。这里使用 <code>s.toCharArray()</code> 仅仅是为了效率，其实可以使用 s.charAt()，这样空间复杂度就是 O(1) 了。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/count-binary-substrings/" title="计数二进制子串 | 力扣（LeetCode）">计数二进制子串 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/count-binary-substrings/solution/ji-shu-er-jin-zhi-zi-chuan-by-leetcode-solution/" title="计数二进制子串 | 题解（LeetCode）">计数二进制子串 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/08/10/count-binary-substrings/' title='计数二进制子串' >计数二进制子串</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/08/10/count-binary-substrings/' title='计数二进制子串' >http://www.cylong.com/blog/2020/08/10/count-binary-substrings/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>字符串</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 博客和 NexT 主题版本升级</title>
    <url>/blog/2020/08/10/update-hexo-next/</url>
    <content><![CDATA[<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用 <a href="https://hexo.io/zh-cn/" title="Hexo">Hexo</a> 搭建博客也有4年之久，也是一直使用 <a href="http://theme-next.iissnan.com/" title="Next">NexT</a> 主题，NexT 的简洁大方美观，特别符合我的审美。最近 Hexo 更新到 5.0.0 版本了，也是临时起意，想要更新下 Hexo 的版本，同时也一起更新下 NexT 主题，毕竟从4年前开始使用后，就再也没有升级过这两个的版本了。经常看到很多的同学都升级到新版本的 NexT 主题，界面展示和功能都有较大提升。NexT 主题不仅由之前的 5.1.x 更新至 7.x，主仓库也从 <a href="https://github.com/iissnan/hexo-theme-next" title="iissnan">iissnan</a> 名下迁移至 <a href="https://github.com/theme-next" title="theme-next">theme-next</a> 组织。</p>
<a id="more"></a>

<h1 id="Hexo-搭建个人博客"><a href="#Hexo-搭建个人博客" class="headerlink" title="Hexo 搭建个人博客"></a>Hexo 搭建个人博客</h1><p>在这里可能有些小伙伴是第一次接触 Hexo 和 NexT，先给大家一些参考文档，助力大家搭建一个属于自己的博客。</p>
<blockquote>
<p><a href="/blog/2016/04/19/hexo-git/" title="Hexo + Git 搭建免费的个人博客 | 笑话人生">Hexo + Git 搭建免费的个人博客 | 笑话人生</a><br><a href="/categories/Hexo/" title="分类：Hexo | 笑话人生">分类：Hexo | 笑话人生</a></p>
</blockquote>
<h1 id="升级-Hexo"><a href="#升级-Hexo" class="headerlink" title="升级 Hexo"></a>升级 Hexo</h1><p>Hexo 版本升级可以通过 npm 实现，相关命令如下：</p>
<ol>
<li><p>全局升级 hexo-cli</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查系统中的插件是否有升级的，可以看到自己前面都安装了那些插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g npm-check</span><br><span class="line">npm-check</span><br></pre></td></tr></table></figure>
</li>
<li><p>升级系统中的插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g npm-upgrade</span><br><span class="line">npm-upgrade</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新全局包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm update -g</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新生产环境依赖包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm update --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看 Hexo 版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo v</span><br><span class="line">hexo: 5.0.2 # 升级到 5.0.2版本</span><br><span class="line">hexo-cli: 4.2.0</span><br><span class="line">os: Windows_NT 10.0.18362 win32 x64</span><br><span class="line">node: 14.7.0</span><br><span class="line">v8: 8.4.371.19-node.12</span><br><span class="line">uv: 1.38.1</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">brotli: 1.0.7</span><br><span class="line">ares: 1.16.0</span><br><span class="line">modules: 83</span><br><span class="line">nghttp2: 1.41.0</span><br><span class="line">napi: 6</span><br><span class="line">llhttp: 2.0.4</span><br><span class="line">openssl: 1.1.1g</span><br><span class="line">cldr: 37.0</span><br><span class="line">icu: 67.1</span><br><span class="line">tz: 2020a</span><br><span class="line">unicode: 13.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看 package.json</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;hexo-site&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.0.0&quot;,</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;hexo&quot;: &#123;</span><br><span class="line">    &quot;version&quot;: &quot;5.0.2&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;hexo&quot;: &quot;^5.0.2&quot;,</span><br><span class="line">    &quot;hexo-admin&quot;: &quot;^2.3.0&quot;,</span><br><span class="line">    &quot;hexo-deployer-git&quot;: &quot;^2.1.0&quot;,</span><br><span class="line">    &quot;hexo-generator-archive&quot;: &quot;^1.0.0&quot;,</span><br><span class="line">    &quot;hexo-generator-baidu-sitemap&quot;: &quot;^0.1.9&quot;,</span><br><span class="line">    &quot;hexo-generator-category&quot;: &quot;^1.0.0&quot;,</span><br><span class="line">    &quot;hexo-generator-feed&quot;: &quot;^3.0.0&quot;,</span><br><span class="line">    &quot;hexo-generator-index&quot;: &quot;^2.0.0&quot;,</span><br><span class="line">    &quot;hexo-generator-searchdb&quot;: &quot;^1.3.2&quot;,</span><br><span class="line">    &quot;hexo-generator-sitemap&quot;: &quot;^2.1.0&quot;,</span><br><span class="line">    &quot;hexo-generator-tag&quot;: &quot;^1.0.0&quot;,</span><br><span class="line">    &quot;hexo-renderer-ejs&quot;: &quot;^1.0.0&quot;,</span><br><span class="line">    &quot;hexo-renderer-marked&quot;: &quot;^3.0.0&quot;,</span><br><span class="line">    &quot;hexo-renderer-stylus&quot;: &quot;^1.1.0&quot;,</span><br><span class="line">    &quot;hexo-server&quot;: &quot;^2.0.0&quot;,</span><br><span class="line">    &quot;hexo-wordcount&quot;: &quot;^6.0.1&quot;,</span><br><span class="line">    &quot;particles.js&quot;: &quot;^2.0.0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="升级-NexT"><a href="#升级-NexT" class="headerlink" title="升级 NexT"></a>升级 NexT</h1><p>NexT 主题升级从 v5 升级到 v7，跨度很大，但是官方提供了升级指导：<a href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/UPDATE-FROM-5.1.X.md" title="从 NexT v5.1.x 更新">从 NexT v5.1.x 更新</a>，这里我把我的升级过程分享给大家，也是自己摸索的一种比较方便的升级方式，同时也方便后面继续进行升级。</p>
<ol>
<li><p>克隆新的仓库到任一异于 next 的目录（如 next-reloaded）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;cylong1016&#x2F;hexo-theme-next themes&#x2F;next-reloaded</span><br></pre></td></tr></table></figure>
<p>如此，你可以在不修改原有的 NexT v5.1.x 目录的同时使用 next-reloaded 目录中的新版本主题。这里，我是 Fork 了主仓库 theme-next/hexo-theme-next ，方便自己后续进行定制化修改，需要更新的时候，直接从主仓库拉取最新代码即可。</p>
</li>
<li><p>在 Hexo 的主配置文件中设置主题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: next-reloaded</span><br></pre></td></tr></table></figure>
<p>如此，你的 next-reloaded 主题将在生成站点时被加载。如果你遇到了任何错误、或只是不喜欢这一新版本，你可以随时切换回旧的 v5.1.x 版本。</p>
</li>
<li><p>更新语言配置<br>从 v6.0.3 版本起，zh-Hans 改名为 zh-CN：<a href="https://github.com/theme-next/hexo-theme-next/releases/tag/v6.0.3">https://github.com/theme-next/hexo-theme-next/releases/tag/v6.0.3</a><br>升级到 v6.0.3 及以后版本的用户，需要显式修改 Hexo 主配置文件 _config.yml 里的 language 配置，否则语言显示不正确。</p>
</li>
<li><p>修改主题的 _config.yml 文件<br>这里，我们不直接修改主题的_config.yml 文件，因为这样操作，后续 <code>git pull</code> 更新的时候，需要解决冲突问题，即使是手动下载 release 版本，也要手动合并 _config.yml 文件。所以我们选择 NexT 提供的方式2，创建自己单独的 next.yml 进行配置：</p>
<blockquote>
<p><a href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/DATA-FILES.md" title="数据文件">数据文件</a></p>
</blockquote>
</li>
<li><p>我大概花了几个小时时间将之前全部的配置搞定了，大家可以参考：</p>
<blockquote>
<p><a href="https://github.com/cylong1016/HexoBlog/blob/master/source/_data/next.yml">https://github.com/cylong1016/HexoBlog/blob/master/source/_data/next.yml</a></p>
</blockquote>
</li>
</ol>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>至此花了半天时间，把 Hexo 和 NexT 主题全部升级完成，主要还是刚开始用的时候不太熟悉，后续也过了4年都没更新，所以这次花了比较多的时间，相信后面熟悉后，紧随版本，更新就会很快了。</p>
<h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><p><a href="https://www.tanxiaoyao.com/post/59005" title="升级博客Hexo版本和Next主题版本踩坑记录 | 叹逍遥的博客">升级博客Hexo版本和Next主题版本踩坑记录 | 叹逍遥的博客</a><br><a href="https://blog.csdn.net/whjkm/article/details/81088518" title="Hexo版本升级和Next主题升级之坑 | HJ_彼岸">Hexo版本升级和Next主题升级之坑 | HJ_彼岸</a><br><a href="https://blog.tangbao.me/2019/08/update-hexo-next-and-add-comment-and-view-number/" title="升级Hexo及NexT主题及添加评论和阅读数 | tangbao&#39;s Blog">升级Hexo及NexT主题及添加评论和阅读数 | tangbao’s Blog</a></p>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/08/10/update-hexo-next/' title='Hexo 博客和 NexT 主题版本升级' >Hexo 博客和 NexT 主题版本升级</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/08/10/update-hexo-next/' title='Hexo 博客和 NexT 主题版本升级' >http://www.cylong.com/blog/2020/08/10/update-hexo-next/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>被围绕的区域</title>
    <url>/blog/2020/08/11/surrounded-regions/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line"></span><br><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br><span class="line"></span><br><span class="line">运行你的函数后，矩阵变为：</span><br><span class="line"></span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>解释:</strong> 被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</p>
<a id="more"></a>

<h1 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h1><p>遇到矩阵的问题，无非就是广度优先搜索或者深度优先搜索，我个人比较喜欢使用递归方式的深度优先搜索，也是比较容易理解的一种方式。本题要求将所有被字母 ‘X’ 包围的字母 ‘O’ 都变为字母 ‘X’ ，但很难判断哪些 ‘O’ 是被包围的，哪些 ‘O’ 不是被包围的。但是我们注意题目中的一句话：任何边界上的 ‘O’ 都不会被填充为 ‘X’。与边界上的 ‘O’ 相连的 ‘O’ 也都不会被填充为 ‘X’。根据这个思路，我们只要遍历矩阵的边界上的 ‘O’，以边界上的所有 ‘O’ 此为起点，找到所有与边界相连的字母 ‘O’，最后我们遍历整个矩阵，针对每个字母，如果这个字母被标记了，那么就保持原来的 ‘O’，如果没有被标记，那么就置为 ‘X’ 即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> rowLen = board.length;</span><br><span class="line">    <span class="keyword">int</span> colLen = board[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] direct = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> directIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> col = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rowLen][colLen];</span><br><span class="line">    <span class="comment">// 顺时针遍历矩阵的边界</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= ((rowLen + colLen) &lt;&lt; <span class="number">1</span>) - <span class="number">4</span>; i++) &#123;</span><br><span class="line">        updateBoard(board, row, col, visited);</span><br><span class="line">        <span class="keyword">int</span> nextRow = row + direct[directIndex][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> nextCol = col + direct[directIndex][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (nextRow &lt; <span class="number">0</span> || nextRow &gt;= rowLen || nextCol &lt; <span class="number">0</span> || nextCol &gt;= colLen) &#123;</span><br><span class="line">            directIndex = (directIndex + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        row += direct[directIndex][<span class="number">0</span>];</span><br><span class="line">        col += direct[directIndex][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 针对每个字母，如果这个字母被标记了，那么就保持原来的 &#x27;O&#x27;，如果没有被标记，那么就置为 &#x27;X&#x27;。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowLen; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; colLen; j++) &#123;</span><br><span class="line">            board[i][j] = visited[i][j] ? <span class="string">&#x27;O&#x27;</span> : <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateBoard</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">boolean</span>[][] visited)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= board.length || y &gt;= board[<span class="number">0</span>].length || visited[x][y] || board[x][y] == <span class="string">&#x27;X&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[x][y] = <span class="keyword">true</span>;</span><br><span class="line">    updateBoard(board, x + <span class="number">1</span>, y, visited);</span><br><span class="line">    updateBoard(board, x, y + <span class="number">1</span>, visited);</span><br><span class="line">    updateBoard(board, x - <span class="number">1</span>, y, visited);</span><br><span class="line">    updateBoard(board, x, y - <span class="number">1</span>, visited);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了 <code>visited[x][y]</code> 表示是否被标记，其实可以遍历到 ‘O’ 的时候，将此位置的字符改成任何其他字符，比如 ‘#’，之后遍历整个矩阵的时候，我们将其还原为 ‘O’ 即可，这样就不用使用额外的空间来标记了。另外遍历矩阵的边界，我使用的是从 <code>board[0][0]</code> 开始顺时针遍历矩阵的边界，其实不用这么麻烦，只要分别遍历矩阵的第一行，最后一行，第一列，最后一列即可，我这样做主要是为了复习下之前的一道题：</p>
<blockquote>
<p><a href="/blog/2020/06/05/shun-shi-zhen-da-yin-ju-zhen-lcof/" title="顺时针打印矩阵 | 笑话人生">顺时针打印矩阵 | 笑话人生</a></p>
</blockquote>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(n × m)，其中 n 和 m 分别为矩阵的行数和列数。深度优先搜索过程中，每一个点至多只会被标记一次。</li>
<li>空间复杂度：O(n × m)，其中 n 和 m 分别为矩阵的行数和列数。主要为深度优先搜索的栈的开销。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/surrounded-regions/" title="被围绕的区域 | 力扣（LeetCode）">被围绕的区域 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/surrounded-regions/solution/bei-wei-rao-de-qu-yu-by-leetcode-solution/" title="被围绕的区域 | 题解（LeetCode）">被围绕的区域 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/08/11/surrounded-regions/' title='被围绕的区域' >被围绕的区域</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/08/11/surrounded-regions/' title='被围绕的区域' >http://www.cylong.com/blog/2020/08/11/surrounded-regions/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>递归</tag>
        <tag>回溯算法</tag>
        <tag>矩阵</tag>
        <tag>深度优先搜索</tag>
        <tag>广度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串相乘</title>
    <url>/blog/2020/08/13/multiply-strings/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p>
<p><strong>示例 1:</strong></p>
<blockquote>
<p>输入: num1 = “2”, num2 = “3”<br>输出: “6”</p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p>输入: num1 = “123”, num2 = “456”<br>输出: “56088”</p>
</blockquote>
<p><strong>说明：</strong></p>
<ol>
<li>num1 和 num2 的长度小于 110。</li>
<li>num1 和 num2 只包含数字 0-9。</li>
<li>num1 和 num2 均不以零开头，除非是数字 0 本身。</li>
<li>不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。</li>
</ol>
<a id="more"></a>

<h1 id="竖式乘法"><a href="#竖式乘法" class="headerlink" title="竖式乘法"></a>竖式乘法</h1><p>第一种方式比较简单，我们只要回想起我们平时计算乘法的方法。如果 num1 和 num2 之一是 0，则直接返回 0 即可。如果 num1 和 num2 都不是 0，则可以通过模拟「竖式乘法」的方法计算乘积。从右往左遍历乘数，将乘数的每一位与被乘数相乘得到对应的结果，再将每次得到的结果累加。需要注意的是，num2 除了最低位以外，其余的每一位的运算结果都需要补 0。</p>
<img src="/blog/2020/08/13/multiply-strings/%E5%81%9A%E5%8A%A0%E6%B3%95.png" class="" title="做加法">

<p>关于字符串相加的代码，可以参考：<a href="/blog/2020/08/03/add-strings/" title="字符串相加 | 笑话人生">字符串相加 | 笑话人生</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;0&quot;</span>.equals(num1) || <span class="string">&quot;0&quot;</span>.equals(num2)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String result = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = num2.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = num2.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        StringBuilder tmpResult = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = num2.length() - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">            tmpResult.append(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = num1.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">int</span> n2 = num1.charAt(j) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">int</span> tmp = n1 * n2 + carry;</span><br><span class="line">            carry = tmp / <span class="number">10</span>;</span><br><span class="line">            tmpResult.append(tmp % <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            tmpResult.append(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        result = addString(result, tmpResult.reverse().toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addString</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index1 = num1.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index2 = num2.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span> (index1 &gt;= <span class="number">0</span> || index2 &gt;= <span class="number">0</span> || carry != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = index1 &gt;= <span class="number">0</span> ? num1.charAt(index1) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = index2 &gt;= <span class="number">0</span> ? num2.charAt(index2) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = x + y + carry;</span><br><span class="line">        res.append(sum % <span class="number">10</span>);</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        index1--;</span><br><span class="line">        index2--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(mn + n²)，其中 m 和 n 分别是 num1 和 num2 的长度。需要从右往左遍历 num2，对于 num2 的每一位，都要和 num1 的每一位计算乘积，因此计算乘积的总数是 mn，字符串相加操作共有 n 次，相加的字符串长度最长为 <code>m + n</code>，因此字符串相加的时间复杂度是O(mn + n²)。总时间复杂度是O(mn + n²)。</li>
<li>空间复杂度：O(m + n)，其中 m 和 n 分别是 num1 和 num2 的长度。空间复杂度取决于存储中间状态的字符串，由于乘积的最大长度为 <code>m + n</code>，因此存储中间状态的字符串的长度不会超过 <code>m + n</code>。</li>
</ul>
<h1 id="直接做乘积"><a href="#直接做乘积" class="headerlink" title="直接做乘积"></a>直接做乘积</h1><p>上一个方法从右往左遍历乘数，将乘数的每一位与被乘数相乘得到对应的结果，再将每次得到的结果累加，整个过程中涉及到较多字符串相加的操作。如果使用数组代替字符串存储结果，则可以减少对字符串的操作。令 m 和 n 分别表示 num1 和 num2 的长度，并且它们均不为 0，则 num1 和 num2 的乘积的长度为 <code>m + n - 1</code> 或 <code>m + n</code>。</p>
<p>由于 num1 和 num2 的乘积的最大长度为 <code>m + n</code>，因此创建长度为 <code>m + n</code> 的数组 ansArr 用于存储乘积。对于任意 <code>0 ≤ i &lt; m</code> 和 <code>0 ≤ j &lt; n</code>，<code>num1[i] × num2[j]</code> 的结果位于 <code>ansArr[i + j + 1]</code>，如果 <code>ansArr[i + j + 1] ≥ 10</code>，则将进位部分加到<code>ansArr[i + j]</code>。最后，将数组 ansArr 转成字符串，如果最高位是 0 则舍弃最高位。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;0&quot;</span>.equals(num1) || <span class="string">&quot;0&quot;</span>.equals(num2)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m = num1.length();</span><br><span class="line">    <span class="keyword">int</span> n = num2.length();</span><br><span class="line">    <span class="keyword">int</span>[] ansArr = <span class="keyword">new</span> <span class="keyword">int</span>[m + n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = num1.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = num2.charAt(j) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            ansArr[i + j + <span class="number">1</span>] += x * y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m + n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        ansArr[i - <span class="number">1</span>] += ansArr[i] / <span class="number">10</span>;</span><br><span class="line">        ansArr[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = ansArr[<span class="number">0</span>] == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>; i &lt; m + n; i++) &#123;</span><br><span class="line">        ans.append(ansArr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(mn)，其中 m 和 n 分别是 num1 和 num2 的长度。需要计算 num1 的每一位和 num2 的每一位的乘积。</li>
<li>空间复杂度：O(m + n)，其中 m 和 n 分别是 num1 和 num2 的长度。需要创建一个长度为 <code>m + n</code> 的数组存储乘积。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/multiply-strings/" title="字符串相乘 | 力扣（LeetCode）">字符串相乘 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/multiply-strings/solution/zi-fu-chuan-xiang-cheng-by-leetcode-solution/" title="字符串相乘 | 题解（LeetCode）">字符串相乘 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/08/13/multiply-strings/' title='字符串相乘' >字符串相乘</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/08/13/multiply-strings/' title='字符串相乘' >http://www.cylong.com/blog/2020/08/13/multiply-strings/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>数组</tag>
        <tag>字符串</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>区间列表的交集</title>
    <url>/blog/2020/08/15/interval-list-intersections/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定两个由一些闭区间组成的列表，每个区间列表都是成对不相交的，并且已经排序。返回这两个区间列表的交集。<br>（形式上，闭区间 [a, b]（其中 <code>a &lt;= b</code>）表示实数 x 的集合，而 <code>a &lt;= x &lt;= b</code>。两个闭区间的交集是一组实数，要么为空集，要么为闭区间。例如，[1, 3] 和 [2, 4] 的交集为 [2, 3]。）</p>
<p><strong>示例：</strong></p>
<img src="/blog/2020/08/15/interval-list-intersections/%E9%97%AD%E5%8C%BA%E9%97%B4%E5%88%97%E8%A1%A8.png" class="" title="闭区间列表">

<blockquote>
<p>输入：A = [[0, 2], [5, 10], [13, 23], [24, 25]], B = [[1, 5], [8, 12], [15, 24], [25, 26]]<br>输出：[[1, 2], [5, 5], [8, 10], [15, 23], [24, 24], [25, 25]]</p>
</blockquote>
<p>提示：</p>
<ul>
<li>0 &lt;= A.length &lt; 1000</li>
<li>0 &lt;= B.length &lt; 1000</li>
<li>0 &lt;= A[i].start, A[i].end, B[i].start, B[i].end &lt; 10^9</li>
</ul>
<a id="more"></a>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>最开始我的想法是使用一个指针 start 扫描两个闭区间的值，判断当前 start 的值是否在 A[indexA] 和 B[indexB] 的区间内，发现进入到区间后，那么我们再引入 end 指针，值为 start 的值，然后移动 end 指针，直到出了 A[indexA] 或者 B[indexB] 的区间范围，那么 start 和 end - 1 的值就是两个区间的交集。然后将 end 的值赋值给 start 并判断 start ，如果超出了 A[indexA] 或者 B[indexB] 的区间，则分别进行 <code>indexA++</code> 或者 <code>indexB++</code> 的操作。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] intervalIntersection(<span class="keyword">int</span>[][] A, <span class="keyword">int</span>[][] B) &#123;</span><br><span class="line">    <span class="keyword">if</span> (A == <span class="keyword">null</span> || B == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][];</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> indexA = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> indexB = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] common = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">while</span> (indexA &lt; A.length &amp;&amp; indexB &lt; B.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[indexA][<span class="number">0</span>] &lt;= start &amp;&amp; start &lt;= A[indexA][<span class="number">1</span>] &amp;&amp; B[indexB][<span class="number">0</span>] &lt;= start &amp;&amp; start &lt;= B[indexB][<span class="number">1</span>]) &#123;</span><br><span class="line">            common[<span class="number">0</span>] = start;</span><br><span class="line">            <span class="keyword">int</span> end = start;</span><br><span class="line">            <span class="keyword">while</span> (A[indexA][<span class="number">0</span>] &lt;= end &amp;&amp; end &lt;= A[indexA][<span class="number">1</span>] &amp;&amp; B[indexB][<span class="number">0</span>] &lt;= end &amp;&amp; end &lt;= B[indexB][<span class="number">1</span>]) &#123;</span><br><span class="line">                end++;</span><br><span class="line">            &#125;</span><br><span class="line">            common[<span class="number">1</span>] = end - <span class="number">1</span>;</span><br><span class="line">            ans.add(common.clone());</span><br><span class="line">            start = end;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; A[indexA][<span class="number">1</span>]) &#123;</span><br><span class="line">            indexA++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; B[indexB][<span class="number">1</span>]) &#123;</span><br><span class="line">            indexB++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的方法在提交后超时了，分析用例和代码发现，上面的代码有以下两个问题：</p>
<ul>
<li>start 的值从 0 开始，如果 A[0] 和 B[0] 的起始值比较大，那么就做了很多无用的 <code>start++</code> 操作。</li>
<li>end 的值从 start 开始，遍历到区间的最大值，如果区间范围过大，也会导致频繁的 <code>end++</code>。</li>
</ul>
<p>于是我们根据上面的问题进行优化，先从 A[0] 和 B[0] 开始找规律，假设两个闭区间有交集，那么我们可以发现，交集的起始值 <code>start = max(A[0][0], B[0][0])</code>，交集的终止值 <code>end = min(A[0][1], B[0][1])</code>。这样我们相比上面的方法，减少了很多无用的 <code>++</code> 操作。延申而来，对于任意的 A[indexA] 和 B[indexB] 都可以这样求出交集。但是如果求出 <code>start &gt; end</code> 则认为这两个区间没有交集，然后我们对于提前结束的集合，即集合的最大值等于 end 的集合，我们对其指针进行 <code>index++</code> 操作。因为较早结束的集合，已经计算完交集了，而另外一个范围比较大的集合，还有有值没有计算是否相交。下面看代码将会更好的理解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] intervalIntersection(<span class="keyword">int</span>[][] A, <span class="keyword">int</span>[][] B) &#123;</span><br><span class="line">    <span class="keyword">if</span> (A == <span class="keyword">null</span> || B == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][];</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> indexA = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> indexB = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (indexA &lt; A.length &amp;&amp; indexB &lt; B.length) &#123;</span><br><span class="line">        <span class="keyword">int</span> start = Math.max(A[indexA][<span class="number">0</span>], B[indexB][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> end = Math.min(A[indexA][<span class="number">1</span>], B[indexB][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (start &lt;= end) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;start, end&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (A[indexA][<span class="number">1</span>] == end) &#123;</span><br><span class="line">            indexA++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (B[indexB][<span class="number">1</span>] == end) &#123;</span><br><span class="line">            indexB++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进一步我们使用条件运算符优化下 16 行开始的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] intervalIntersection(<span class="keyword">int</span>[][] A, <span class="keyword">int</span>[][] B) &#123;</span><br><span class="line">    <span class="keyword">if</span> (A == <span class="keyword">null</span> || B == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][];</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> indexA = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> indexB = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (indexA &lt; A.length &amp;&amp; indexB &lt; B.length) &#123;</span><br><span class="line">        <span class="keyword">int</span> start = Math.max(A[indexA][<span class="number">0</span>], B[indexB][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> end = A[indexA][<span class="number">1</span>] &lt; B[indexB][<span class="number">1</span>] ? A[indexA++][<span class="number">1</span>] : B[indexB++][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (start &lt;= end) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;start, end&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(M + N)，其中 M, N 分别是数组 A 和 B 的长度。</li>
<li>空间复杂度：O(M + N)，答案中区间数量的上限。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/interval-list-intersections/" title="区间列表的交集 | 力扣（LeetCode）">区间列表的交集 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/interval-list-intersections/solution/qu-jian-lie-biao-de-jiao-ji-by-leetcode/" title="区间列表的交集 | 题解（LeetCode）">区间列表的交集 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/08/15/interval-list-intersections/' title='区间列表的交集' >区间列表的交集</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/08/15/interval-list-intersections/' title='区间列表的交集' >http://www.cylong.com/blog/2020/08/15/interval-list-intersections/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>数组</tag>
        <tag>指针</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>平衡二叉树</title>
    <url>/blog/2020/08/17/balanced-binary-tree/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树，判断它是否是高度平衡的二叉树。本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定二叉树 [3, 9, 20, null, null, 15, 7]</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">返回 true 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定二叉树 [1, 2, 2, 3, 3, null, null, 4, 4]</span><br><span class="line">       1</span><br><span class="line">      &#x2F; \</span><br><span class="line">     2   2</span><br><span class="line">    &#x2F; \</span><br><span class="line">   3   3</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 4   4</span><br><span class="line">返回 false 。</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>根据题意一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1。那么我们可以递归的判断一棵树的左右子树，判断是否是平衡二叉树。对于当前遍历到的节点，先递归地判断其左右子树是否平衡，再判断以当前节点为根的子树是否平衡。如果一棵子树是平衡的，则返回其高度（高度一定是非负整数），否则返回 -1。如果存在一棵子树不平衡，则整个二叉树一定不平衡。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> height(root) != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> leftHeight = height(node.left);</span><br><span class="line">    <span class="keyword">int</span> rightHeight = height(node.right);</span><br><span class="line">    <span class="keyword">if</span> (leftHeight == -<span class="number">1</span> || rightHeight == -<span class="number">1</span> || Math.abs(leftHeight - rightHeight) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上述代码，我们还可以简单优化下，如果左子树不是平衡的，那么也就不需要再递归的求右子树是否平衡了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> height(root) != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> leftHeight;</span><br><span class="line">    <span class="keyword">int</span> rightHeight;</span><br><span class="line">    <span class="keyword">if</span> ((leftHeight = height(node.left)) == -<span class="number">1</span></span><br><span class="line">            || (rightHeight = height(node.right)) == -<span class="number">1</span></span><br><span class="line">            || Math.abs(leftHeight - rightHeight) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外也可以先看一道简单的求树的高度的题：<a href="/blog/2020/07/28/maximum-depth-of-binary-tree/">二叉树的最大深度 | 笑话人生</a></p>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(n)，其中 n 是二叉树中的节点个数。使用自底向上的递归，每个节点的计算高度和判断是否平衡都只需要处理一次，最坏情况下需要遍历二叉树中的所有节点，因此时间复杂度是 O(n)。</li>
<li>空间复杂度：O(n)，其中 n 是二叉树中的节点个数。空间复杂度主要取决于递归调用的层数，递归调用的层数不会超过 n。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/balanced-binary-tree/" title="平衡二叉树 | 力扣（LeetCode）">平衡二叉树 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/balanced-binary-tree/solution/ping-heng-er-cha-shu-by-leetcode-solution/" title="平衡二叉树 | 题解（LeetCode）">平衡二叉树 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/08/17/balanced-binary-tree/' title='平衡二叉树' >平衡二叉树</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/08/17/balanced-binary-tree/' title='平衡二叉树' >http://www.cylong.com/blog/2020/08/17/balanced-binary-tree/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>递归</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
        <tag>深度优先搜索</tag>
        <tag>平衡二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>将二叉搜索树变平衡</title>
    <url>/blog/2020/08/20/balance-a-binary-search-tree/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一棵二叉搜索树，请你返回一棵平衡后的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过 1 ，我们就称这棵二叉搜索树是平衡的。如果有多种构造方法，请你返回任意一种。</p>
<p><strong>示例：</strong></p>
<img src="/blog/2020/08/20/balance-a-binary-search-tree/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.png" class="" title="二叉搜索树">
<img src="/blog/2020/08/20/balance-a-binary-search-tree/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.png" class="" title="平衡二叉搜索树">

<blockquote>
<p>输入：root = [1, null, 2, null, 3, null, 4, null, null]<br>输出：[2, 1, 3, null, null, null, 4]<br>解释：这不是唯一的正确答案，[3, 1, 4, null, 2, null, null] 也是一个可行的构造方案。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>树节点的数目在 1 到 10^4 之间。</li>
<li>树节点的值互不相同，且在 1 到 10^5 之间。</li>
</ul>
<a id="more"></a>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>「平衡」要求它是一棵空树或它的左右两个子树的高度差的绝对值不超过 1，这很容易让我们产生这样的想法——左右子树的大小越「平均」，这棵树会不会越平衡？于是一种贪心策略就形成了：我们可以通过中序遍历将原来的二叉搜索树转化为一个有序序列，然后对这个有序序列递归建树，对于区间 [L, R]：</p>
<ul>
<li>取 <code>mid = (L + R) / 2</code>，即中心位置做为当前节点的值。</li>
<li>如果 <code>L ≤ mid − 1</code>，那么递归地将区间 <code>[L, mid − 1]</code> 作为当前节点的左子树。</li>
<li>如果 <code>mid + 1 ≤ R</code>，那么递归地将区间 <code>[mid + 1, R]</code> 作为当前节点的右子树。</li>
</ul>
<p>经过证明此方法是可行的，关于证明方式在此不做赘述，想要了解的同学可以参考下面官方的题解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; treeValList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">balanceBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    dfsGetTreeValList(root);</span><br><span class="line">    <span class="keyword">return</span> buildBalanceBST(<span class="number">0</span>, treeValList.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildBalanceBST</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = right - ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    TreeNode node = <span class="keyword">new</span> TreeNode(treeValList.get(mid));</span><br><span class="line">    node.left = left &lt; mid ? buildBalanceBST(left, mid - <span class="number">1</span>) : <span class="keyword">null</span>;</span><br><span class="line">    node.right = mid &lt; right ? buildBalanceBST(mid + <span class="number">1</span>, right) : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfsGetTreeValList</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfsGetTreeValList(node.left);</span><br><span class="line">    treeValList.add(node.val);</span><br><span class="line">    dfsGetTreeValList(node.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(n)，获得中序遍历的时间代价是 O(n)；建立平衡二叉树的时建立每个点的时间代价为 O(1)，总时间也是 O(n)。故渐进时间复杂度为 O(n)。</li>
<li>空间复杂度：O(n)，这里使用了一个数组作为辅助空间，存放中序遍历后的有序序列，故渐进空间复杂度为 O(n)。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/balance-a-binary-search-tree/" title="将二叉搜索树变平衡 | 力扣（LeetCode）">将二叉搜索树变平衡 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/balance-a-binary-search-tree/solution/jiang-er-cha-sou-suo-shu-bian-ping-heng-by-leetcod/" title="将二叉搜索树变平衡 | 题解（LeetCode）">将二叉搜索树变平衡 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/08/20/balance-a-binary-search-tree/' title='将二叉搜索树变平衡' >将二叉搜索树变平衡</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/08/20/balance-a-binary-search-tree/' title='将二叉搜索树变平衡' >http://www.cylong.com/blog/2020/08/20/balance-a-binary-search-tree/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>贪心算法</tag>
        <tag>递归</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
        <tag>深度优先搜索</tag>
        <tag>中序遍历</tag>
        <tag>二叉搜索树</tag>
        <tag>平衡二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>数字范围按位与</title>
    <url>/blog/2020/08/26/bitwise-and-of-numbers-range/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定范围 [m, n]，其中 0 &lt;= m &lt;= n &lt;= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。</p>
<p><strong>示例 1:</strong> </p>
<blockquote>
<p>输入: [5, 7]<br>输出: 4</p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p>输入: [0, 1]<br>输出: 0</p>
</blockquote>
<a id="more"></a>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>我们观察按位与运算的性质。对于一系列的位，例如 [1, 1, 0, 1, 1]，只要有一个零的位，那么这一系列位的按位与运算结果都将为零。对于此题，我们将一系列数字变成二进制展示，如下：</p>
<table>
<thead>
<tr>
<th align="center">-</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">13</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">15</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">16</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>上面表格中，我将[0, 16] 全部展开成8进制展示，上图中，我们任意取出一个范围，比如[9, 12]，我们可以发现，对所有数字执行按位与运算的结果是所有对应二进制字符串的公共前缀再用零补上后面的剩余位。那么这个规律是否正确呢？我们可以进行简单的证明。假设对于所有这些二进制串，前 i 位均相同，第 i + 1 位开始不同，由于 [m, n] 连续，所以第 i + 1 位在 [m, n] 的数字范围从小到大列举出来一定是前面全部是 0，后面全部是 1，在上图中对应 [9, 11] 均为 0，[12, 12] 均为 1。并且一定存在连续的两个数 x 和 x + 1，满足 x 的第 i + 1 位为 0，后面全为 1，x + 1 的第 i + 1 位为 1，后面全为 0，对应上图中的例子即为 11 和 12。这种形如 0111… 和 1000… 的二进制串的按位与的结果一定为 0000…，因此第 i + 1 位开始的剩余位均为 0，前 i 位由于均相同，因此按位与结果不变。最后的答案即为二进制字符串的公共前缀再用零补上后面的剩余位。</p>
<p>进一步来说，所有这些二进制字符串的公共前缀也即指定范围的起始和结束数字 m 和 n 的公共前缀（即在上面的示例中分别为 9 和 12）。因此，最终我们可以将问题重新表述为：给定两个整数，我们要找到它们对应的二进制字符串的公共前缀。</p>
<h1 id="位移操作"><a href="#位移操作" class="headerlink" title="位移操作"></a>位移操作</h1><p>我们的想法是将两个数字不断向右移动，直到数字相等，即数字被缩减为它们的公共前缀。计算移动的次数，然后，通过将公共前缀向左移动相同次数，将零添加到公共前缀的右边以获得最终结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (m != n) &#123;</span><br><span class="line">        m = m &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m &lt;&lt; count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(logn)。算法的时间复杂度取决于 m 和 n 的二进制位数，由于 m ≤ n，因此时间复杂度取决于 n 的二进制位数。</li>
<li>空间复杂度：O(1)。我们只需要常数空间存放若干变量。</li>
</ul>
<h1 id="Brian-Kernighan-算法"><a href="#Brian-Kernighan-算法" class="headerlink" title="Brian Kernighan 算法"></a>Brian Kernighan 算法</h1><p>还有一个位移相关的算法叫做「Brian Kernighan 算法」，它用于清除二进制串中最右边的 1。Brian Kernighan 算法的关键在于我们每次对 n 和 n − 1 之间进行按位与运算后，n 中最右边的 1 会被抹去变成 0。</p>
<img src="/blog/2020/08/26/bitwise-and-of-numbers-range/BK%E7%AE%97%E6%B3%95.png" class="" title="BK算法">

<p>基于上述技巧，我们可以用它来计算两个二进制字符串的公共前缀。其思想是，对于给定的范围 [m, n]（m &lt; n），我们可以对数字 n 迭代地应用上述技巧，清除最右边的 1，直到它小于或等于 m，此时非公共前缀部分的 1 均被消去。因此最后我们返回 n 即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (m &lt; n) &#123;</span><br><span class="line">        n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(logn)。和位移方法类似，算法的时间复杂度取决于 m 和 n 二进制展开的位数。尽管和位移方法具有相同的渐近复杂度，但 Brian Kernighan 的算法需要的迭代次数会更少，因为它跳过了两个数字之间的所有零位。</li>
<li>空间复杂度：O(1)。我们只需要常数空间存放若干变量。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/" title="数字范围按位与 | 力扣（LeetCode）">数字范围按位与 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/solution/shu-zi-fan-wei-an-wei-yu-by-leetcode-solution/" title="数字范围按位与 | 题解（LeetCode）">数字范围按位与 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/08/26/bitwise-and-of-numbers-range/' title='数字范围按位与' >数字范围按位与</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/08/26/bitwise-and-of-numbers-range/' title='数字范围按位与' >http://www.cylong.com/blog/2020/08/26/bitwise-and-of-numbers-range/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>数学</tag>
        <tag>位运算</tag>
        <tag>Brian Kernighan 算法</tag>
      </tags>
  </entry>
  <entry>
    <title>相同的树</title>
    <url>/blog/2020/08/07/same-tree/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定两个二叉树，编写一个函数来检验它们是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line"></span><br><span class="line">    1         1</span><br><span class="line">   &#x2F; \       &#x2F; \</span><br><span class="line">  2   3     2   3</span><br><span class="line"></span><br><span class="line">[1, 2, 3], [1, 2, 3]</span><br><span class="line"></span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line"></span><br><span class="line">   1          1</span><br><span class="line">  &#x2F;           \</span><br><span class="line"> 2             2</span><br><span class="line"></span><br><span class="line">[1, 2],  [1, null, 2]</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line"></span><br><span class="line">    1         1</span><br><span class="line">   &#x2F; \       &#x2F; \</span><br><span class="line">  2   1     1   2</span><br><span class="line"></span><br><span class="line">[1, 2, 1], [1, 1, 2]</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>此题是另外一道题的一个子解题步骤：<a href="/blog/2020/06/22/subtree-of-another-tree/" title="另一个树的子树">另一个树的子树</a>，根据题目描述，我们可以使用深度优先搜索，首先判断如果两个二叉树都为空，则两个二叉树相同。如果两个二叉树中有且只有一个为空，则两个二叉树一定不相同【这也是递归的终止条件】。然后判断两个树的根节点值是否相同，接下来递归的方式处理两个树的左子树和右子树，如果都相同，则为相同的树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p.val == q.val &amp;&amp; isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(min(m, n))，其中 m 和 n 分别是两个二叉树的节点数。对两个二叉树同时进行深度优先搜索，只有当两个二叉树中的对应节点都不为空时才会访问到该节点，因此被访问到的节点数不会超过较小的二叉树的节点数。</li>
<li>空间复杂度：O(min(m, n))，其中 m 和 n 分别是两个二叉树的节点数。空间复杂度取决于递归调用的层数，递归调用的层数不会超过较小的二叉树的最大高度，最坏情况下，二叉树的高度等于节点数。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/same-tree/" title="另一个树的子树 | 力扣（LeetCode）">相同的树 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/same-tree/solution/xiang-tong-de-shu-by-leetcode-solution/" title="另一个树的子树 | 题解（LeetCode）">相同的树 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/08/07/same-tree/' title='相同的树' >相同的树</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/08/07/same-tree/' title='相同的树' >http://www.cylong.com/blog/2020/08/07/same-tree/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>递归</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的遍历</title>
    <url>/blog/2020/09/02/binary-tree-traverse/</url>
    <content><![CDATA[<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近一直在刷 Leetcode ，其中涉及了很多二叉树相关的题，二叉树是一种很重要的数据结构，很多其他的数据结构都是以二叉树为基础，二叉树的遍历涉及很多种，包括前序遍历、中序遍历、后序遍历、层次遍历。开始一直分不清这些遍历是如何工作的，随着后面题刷的越来越多，也渐渐熟悉了二叉树的遍历方式，在这里做一个总结分享给大家。</p>
<p>四种遍历的主要方式为：</p>
<ul>
<li>前序遍历：根节点 -&gt; 左子树 -&gt; 右子树</li>
<li>中序遍历：左子树 -&gt; 根节点 -&gt; 右子树</li>
<li>后序遍历：左子树 -&gt; 右子树 -&gt; 根节点</li>
<li>层次遍历：从上到下按照层遍历</li>
</ul>
<p>接下来使用以下的二叉树做样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">        1</span><br><span class="line">       &#x2F; \</span><br><span class="line">      2   3</span><br><span class="line">     &#x2F; \   \</span><br><span class="line">    4   5   6</span><br><span class="line">       &#x2F; \</span><br><span class="line">      7   8</span><br><span class="line"></span><br><span class="line">前序遍历：1  2  4  5  7  8  3  6 </span><br><span class="line">中序遍历：4  2  7  5  8  1  3  6</span><br><span class="line">后序遍历：4  7  8  5  2  6  3  1</span><br><span class="line">层次遍历：1  2  3  4  5  6  7  8</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h1><p>前序遍历：根节点 -&gt; 左子树 -&gt; 右子树。前序遍历是先输出根节点的值，再去递归的输出左子树和右子树。代码实现也包括递归和非递归两个版本。</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>树的结构定义本身就是递归的定义，所以使用递归版本实现树的遍历会使代码更加简洁易于理解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfsPreOrderTraverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    dfsPreOrderTraverse(root.left);</span><br><span class="line">    dfsPreOrderTraverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h2><p>非递归版本，就没有递归版本那么好理解，代码也比较多，我们这里引入栈来保存每个节点，首先将根节点加入栈中，接下来我们遍历此栈，根据栈的后进先出特性，每次将栈顶元素退出，并输出其值，接下来，我们将此节点的右节点和左节点依次加入到栈中，根据栈的后进先出特性，永远都是先输出左子树，然后输出右子树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderTraverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = stack.pop();</span><br><span class="line">        System.out.print(node.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h1><p>中序遍历：左子树 -&gt; 根节点 -&gt; 右子树。中序遍历是中间输出根节点的值，先递归左子树，然后输出根节点的值，再递归右子树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfsInOrderTraverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfsInOrderTraverse(root.left);</span><br><span class="line">    System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    dfsInOrderTraverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h1><p>后序遍历：左子树 -&gt; 右子树 -&gt; 根节点。后续遍历是先递归左子树和右子树，最后输出根节点的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfsPostOrderTraverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfsPostOrderTraverse(root.left);</span><br><span class="line">    dfsPostOrderTraverse(root.right);</span><br><span class="line">    System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h1><p>层次遍历：从上到下按照层遍历。这里不是递归的去遍历，而是横向的遍历每一层，这里我们引入队列，我们先把根节点加入到队列中，接下来，根据队列的先进先出特性，我们先从队列中取出最先加入的节点，输出其值，然后将此节点的左右节点分别加入到队列中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelTraverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = queue.poll();</span><br><span class="line">        System.out.print(node.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外一种比较复杂的按层遍历是每层当成一个列表输出，这个时候我们只要增加另外一个队列，同时记录当时遍历的层数即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelTraverse(TreeNode root) &#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; item = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Queue&lt;Integer&gt; queueLevel = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> curLevel = <span class="number">1</span>;</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    queueLevel.offer(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = queue.poll();</span><br><span class="line">        <span class="keyword">int</span> level = queueLevel.poll();</span><br><span class="line">        <span class="keyword">if</span> (level != curLevel) &#123;</span><br><span class="line">            curLevel = level;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(item));</span><br><span class="line">            item.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        item.add(node.val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(node.left);</span><br><span class="line">            queueLevel.offer(curLevel + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(node.right);</span><br><span class="line">            queueLevel.offer(curLevel + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!item.isEmpty()) &#123;</span><br><span class="line">        ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(item));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出样例：[[1], [2, 3], [4, 5, 6], [7, 8]]</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实写完代码就可以发现很多有意思的事情，之前模糊不清的概念也都搞清楚了。</p>
<ol>
<li>前序、中序、后序遍历其实是针对根节点来说的，对于左右子节点，都是先左后右。另外无论是哪种遍历方式，都是先遍历（访问）根节点，区别就是什么时候处理根节点（比如输出根节点的值）。</li>
<li>广度优先搜索对于树来说，其实就是层次遍历，深度优先搜索对于树来说，其实就是先序遍历。</li>
<li>树的层次遍历和树的先序遍历的非递归版本，其实代码一样，只不过一个使用的是队列，一个使用的是栈。</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://blog.csdn.net/My_Jobs/article/details/43451187" title="二叉树遍历（前序、中序、后序、层次遍历、深度优先、广度优先）">二叉树遍历（前序、中序、后序、层次遍历、深度优先、广度优先）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/09/02/binary-tree-traverse/' title='二叉树的遍历' >二叉树的遍历</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/09/02/binary-tree-traverse/' title='二叉树的遍历' >http://www.cylong.com/blog/2020/09/02/binary-tree-traverse/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
        <tag>队列</tag>
        <tag>递归</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
        <tag>深度优先搜索</tag>
        <tag>栈</tag>
        <tag>中序遍历</tag>
        <tag>广度优先搜索</tag>
        <tag>前序遍历</tag>
        <tag>后序遍历</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>JStack 使用介绍</title>
    <url>/blog/2019/09/10/jstack/</url>
    <content><![CDATA[<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在项目中遇到一个问题，我们服务提供给外部的一个接口 queryXXX 一直返回 429 错误（Too Many Requests），接口没有返回值，而且服务越用越卡，要重启一下才能恢复。于是马上就想到是不是因为这个接口产生了死循环，导致接口无法正确返回，同时导致后台 CPU 和内存占用飙升，顺着这个思路定位下去，确实顺利的找到的问题所在。</p>
<a id="more"></a>

<h1 id="定位思路"><a href="#定位思路" class="headerlink" title="定位思路"></a>定位思路</h1><ol>
<li>执行 <code>free -m/free -h</code> 查看服务的后台 CPU 和内存占用，发现服务占用的内存和 CPU 过高。</li>
<li>执行 <code>jps/ps/top</code> 命令找到 CPU 和内存占用高的进程 ID(32033)。</li>
<li>执行 <code>top -H -p 32033</code>，找到 %CPU 和 %MEM 占用高的 PID(60958)，转换成16进制 ee1e。</li>
<li>执行 <code>jstack -l 32033 &gt; stack.txt</code>，打印调用栈信息。</li>
<li>找到 stack.txt 日志里面的 <code>nid=0xee1e</code>（注意第三步的是十进制，日志里的是十六进制）对应接口服务，分析调用栈，发现 queryXXX 接口的状态一直是 RUNNING 状态，卡死。</li>
<li>定位后发现代码中使用了流 API 的 parallelStream 导致的问题，原因是 parallelStream 是并行操作，我们这边使用了 HashMap，HashMap 是非线程安全的，并发插入数据在 resize() 方法中产生循环链表导致死循环（JDK8 已经解决），导致 queryXXX 接口的状态一直是 RUNNING，无返回值，CPU 和内存飙升。调用服务方在没有接受到返回的时候不断请求这个服务，于是产生了 429 错误。</li>
<li>我们这边 HashMap 是局部变量，解决方法是将 parallelStream 并行流修改为 stream 串行流。如果此 HashMap 是那种全局变量，涉及并发操作，则可以改成使用 ConcurrentHashMap。</li>
</ol>
<p>关于 HashMap 的介绍可以参考：</p>
<blockquote>
<p><a href="/blog/2019/09/10/hashmap/" title="浅谈 HashMap | 笑话人生">浅谈 HashMap | 笑话人生</a></p>
</blockquote>
<h1 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍"></a>使用介绍</h1><p>JStack 是 java 自带的工具，在 jdk\bin\jstack.exe 位置。以下是 Windows 的示范，在 Linux 系统上功能更多。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PS C:\Program Files\Java\jdk-11.0.2\bin&gt; .\jstack</span><br><span class="line">Usage:</span><br><span class="line">    jstack [-l][-e] &lt;pid&gt;</span><br><span class="line">        (to connect to running process)</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">    -l  long listing. Prints additional information about locks</span><br><span class="line">    -e  extended listing. Prints additional information about threads</span><br><span class="line">    -? -h --<span class="built_in">help</span> -<span class="built_in">help</span> to <span class="built_in">print</span> this <span class="built_in">help</span> message</span><br></pre></td></tr></table></figure>

<p>一般常用的是以下的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jstack -l [PID]</span><br><span class="line">jstack -F [PID]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-l</code> 选项会打印额外的信息，比如说锁信息。</li>
<li>当进程挂起(hung)时，上面的命令可能没有响应，这时需要使用 <code>-F</code> 参数来强制执行 thread dump。</li>
</ul>
<p>接下来我们就可以分析打印的堆栈信息进行分析，比如我上面列举的那个问题：</p>
<table>
<thead>
<tr>
<th>Section</th>
<th>Example</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>线程名字</td>
<td>main 和 Reference Handler</td>
<td>可读的线程名字，这个名字可以通过 Thread 方法 setName 设定</td>
</tr>
<tr>
<td>线程 ID</td>
<td>#1</td>
<td>每一个 Thread 对象的唯一 ID，这个 ID 是自动生成的，从 1 开始，通过 getId 方法获得</td>
</tr>
<tr>
<td>是否守护线程</td>
<td>daemon</td>
<td>这个标签用来标记线程是否是守护线程，如果是会有标记，如果不是这没有</td>
</tr>
<tr>
<td>优先级</td>
<td>prio=10</td>
<td>Java 线程的优先级，可以通过 setPriority 方法设置</td>
</tr>
<tr>
<td>OS 线程的优先级</td>
<td>os_prio</td>
<td></td>
</tr>
<tr>
<td>CPU 时间</td>
<td>cpu=94.43ms</td>
<td>线程获得 CPU 的时间</td>
</tr>
<tr>
<td>elapsed</td>
<td>elapsed=509136.51s</td>
<td>线程启动后经过的 wall clock time</td>
</tr>
<tr>
<td>Address</td>
<td>tid</td>
<td>Java 线程的地址，这个地址表示的是 JNI native Thread Object 的指针地址</td>
</tr>
<tr>
<td>OS 线程 ID</td>
<td>nid</td>
<td>The unique ID of the OS thread to which the Java Thread is mapped</td>
</tr>
<tr>
<td>线程状态</td>
<td>Running</td>
<td>线程当前状态，线程状态下面就是线程的堆栈信息</td>
</tr>
</tbody></table>
<p>线程的运行状态：</p>
<ul>
<li>New: 线程对象创建，不可执行。</li>
<li>Runnable: 调用 thread.start() 进入 runnable，获得 CPU 时间即可执行。</li>
<li>Running: 执行状态。</li>
<li>Waiting: thread.join() 或调用锁对象 wait() 进入该状态，当前线程会保持该状态直到其他线程发送通知到该对象。</li>
<li>Timed_Waiting：执行 Thread.sleep(long)、thread.join(long) 或 obj.wait(long) 等就会进该状态，与 Waiting 的区别在于 Timed_Waiting 的等待有时间限制；</li>
<li>Blocked: 等待锁，进入同步方法，同步代码块，如果没有获取到锁会进入该状态。该线程尝试进入一个被其他线程占用的 synchronized 块，当前线程直到锁被释放之前一直都是 blocked 状态。</li>
<li>Dead：执行结束，或者抛出了未捕获的异常之后。</li>
<li>Deadlock: 死锁。</li>
<li>Waiting on condition：等待某个资源或条件发生来唤醒自己。</li>
<li>Waiting on monitor entry：在等待获取锁。</li>
<li>terminated: 线程已经结束 run() 并且通知其他线程 joining。</li>
</ul>
<p>此文开头解决的问题，由于是公司项目，不方便贴上定位的过程日志和代码，所以就先记录下定位的思路和基本概念。</p>
<h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><blockquote>
<p><a href="https://www.cnblogs.com/kongzhongqijing/articles/3630264.html" title="java命令--jstack 工具 | milkty">java命令–jstack 工具 | milkty</a><br><a href="http://einverne.github.io/post/2017/09/jstack-usage.html" title="每天学习一个命令：jstack 打印 Java 进程堆栈信息 | Ein Verne">每天学习一个命令：jstack 打印 Java 进程堆栈信息 | Ein Verne</a><br><a href="https://skyao.gitbooks.io/leaning-java-performance-tuning/content/cpu/threaddump/dump/jstack.html" title="Java 性能调优学习笔记">Java 性能调优学习笔记</a><br><a href="https://docs.oracle.com/cd/E13150_01/jrockit_jvm/jrockit/geninfo/diagnos/using_threaddumps.html" title="Using Thread Dumps | Oracle">Using Thread Dumps | Oracle</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2019/09/10/jstack/' title='JStack 使用介绍' >JStack 使用介绍</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2019/09/10/jstack/' title='JStack 使用介绍' >http://www.cylong.com/blog/2019/09/10/jstack/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jstack</tag>
        <tag>调试工具</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈 HashMap</title>
    <url>/blog/2019/09/10/hashmap/</url>
    <content><![CDATA[<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>HashMap 是 Java 编程中非常常用的一种数据结构，在各种面试中也是频繁出现的问题。我是一次定位问题，发现了服务后台 CPU 和内存飙升，原因是使用 HashMap 的时候，并发插入数据在 resize() 方法中产生循环链表导致死循环（JDK8 已经解决）。看到代码中大量的 HashMap，不自然的就想先了解下 HashMap 的实现原理和其线程安全问题。此文主要是介绍 HashMap 的实现原理，关于如何定位 CPU 和内存飙升问题，可以看另外一篇博客：</p>
<blockquote>
<p><a href="/blog/2019/09/10/jstack/" title="Jstack 使用介绍 | 笑话人生">Jstack 使用介绍 | 笑话人生</a></p>
</blockquote>
<a id="more"></a>

<h1 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h1><p>HashMap 是一种存储 <code>key -&gt; value </code>键值对的数据结构，每一个键值对称为 Entry，这些 Entry 存储在一个 table 数组中，每个 Entry 是一个链表结构，有一个 next 指针指向下一个元素。接下来我们看一下比较重要的代码。</p>
<img src="/blog/2019/09/10/hashmap/%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.jpg" class="" title="存储结构">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Basic hash bin node, used for most entries.  (See below for</span></span><br><span class="line"><span class="comment"> * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment"> * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment"> * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment"> * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of times this HashMap has been structurally modified</span></span><br><span class="line"><span class="comment"> * Structural modifications are those that change the number of mappings in</span></span><br><span class="line"><span class="comment"> * the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class="line"><span class="comment"> * rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class="line"><span class="comment"> * the HashMap fail-fast.  (See ConcurrentModificationException).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The next size value at which to resize (capacity * load factor).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (The javadoc description is true upon serialization.</span></span><br><span class="line"><span class="comment">// Additionally, if the table array has not been allocated, this</span></span><br><span class="line"><span class="comment">// field holds the initial array capacity, or zero signifying</span></span><br><span class="line"><span class="comment">// DEFAULT_INITIAL_CAPACITY.)</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor for the hash table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>

<ul>
<li>Node 就是上面说的 Entry 的实现，用来保存键值对，实现了 Map.Entry 接口。其中 hash 的值是通过 hash() 方法计算出来，key 和 value 是存入的值，next 是出现哈希冲突的时候，会使用 next 指向链表中的下一个元素对象。</li>
<li>table 存储 Entry 的数组，初始长度是 DEFAULT_INITIAL_CAPACITY = 16。</li>
<li>size 是实际存储的键值对数量。</li>
<li>modCount 记录内部结构发生的次数，比如 put、remove 操作等。常见的一边遍历元素一边删除元素的操作就会报 java.util.ConcurrentModificationException。</li>
<li>loadFactor 负载因子，默认是 DEFAULT_LOAD_FACTOR = 0.75f。</li>
<li>threshold 允许存储的最大元素数量是通过 table 数组长度 * loadFactor 负载因子得出。</li>
</ul>
<h1 id="put-操作"><a href="#put-操作" class="headerlink" title="put 操作"></a>put 操作</h1><p>在 put 操作中，将元素 key 进行 hash 计算并找到 table 的数组下标，将 Entry 直接放入数组中，作为头元素，若通过算法得到的该数组元素已经有了元素（俗称 hash 冲突，链表结构出现的实际意义也就是为了解决 hash 冲突的问题）。当新来的 Entry 映射到冲突的数组位置时，只需要插入到对应的链表即可。接下来直接在源码上解释。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 首先判断 table 数组是否为空，为空则创建 table。</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 如果通过 (n - 1) &amp; hash 找到的数组元素为空，则直接创建新的 node，作为头节点。</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 找到数组元素，判断是相同的 key 值。</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 如果是红黑树结构，则向树插入数据</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 该数组元素 hash 相等，key 不等，同时链表长度 &lt; 8。进行遍历寻找元素，有就覆盖无则新建</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 向链表尾插入数据</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">// 链表长度 &gt;=8 结构转为红黑树</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是存在的元素，则根据条件是否覆盖之前的值。</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部结构变化次数 +1</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 当 map 的实际大小大于了 threshold 则进行 resize 操作，将最大存储数量变为原来的两倍。</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里确定 table 的数组下标使用的 hash 算法是 <code>(n - 1) &amp; hash(key)</code>，相对于取模运算，使用位运算效率更高。key 值的 hash 计算是高 16bit 不变，低 16bit 和高 16bit 做了一个异或。主要是为了保证 n 太小的时候，高低位均能参与下标的计算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Computes key.hashCode() and spreads (XORs) higher bits of hash</span></span><br><span class="line"><span class="comment"> * to lower.  Because the table uses power-of-two masking, sets of</span></span><br><span class="line"><span class="comment"> * hashes that vary only in bits above the current mask will</span></span><br><span class="line"><span class="comment"> * always collide. (Among known examples are sets of Float keys</span></span><br><span class="line"><span class="comment"> * holding consecutive whole numbers in small tables.)  So we</span></span><br><span class="line"><span class="comment"> * apply a transform that spreads the impact of higher bits</span></span><br><span class="line"><span class="comment"> * downward. There is a tradeoff between speed, utility, and</span></span><br><span class="line"><span class="comment"> * quality of bit-spreading. Because many common sets of hashes</span></span><br><span class="line"><span class="comment"> * are already reasonably distributed (so don&#x27;t benefit from</span></span><br><span class="line"><span class="comment"> * spreading), and because we use trees to handle large sets of</span></span><br><span class="line"><span class="comment"> * collisions in bins, we just XOR some shifted bits in the</span></span><br><span class="line"><span class="comment"> * cheapest possible way to reduce systematic lossage, as well as</span></span><br><span class="line"><span class="comment"> * to incorporate impact of the highest bits that would otherwise</span></span><br><span class="line"><span class="comment"> * never be used in index calculations because of table bounds.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="get-操作"><a href="#get-操作" class="headerlink" title="get 操作"></a>get 操作</h1><p>get 方法通过 hash 寻找到 Entry 数组下标，找到头节点，然后顺着对应链表的头节点，一个一个向下来查找。由于 JDK8 引用了红黑树结构，在链表元素过多时，JDK8 的实现将比 JDK7 在 get 和 put 操作上效率高上很多。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.get and related methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="resize-操作"><a href="#resize-操作" class="headerlink" title="resize 操作"></a>resize 操作</h1><p>当 map 的实际大小大于了 threshold 则进行 resize 操作，将最大存储数量变为原来的两倍。接下来我们看一下源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment"> * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment"> * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment"> * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment"> * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大限制，不进行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 进行原始长度2倍扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一次初始化</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一次初始化</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新的最大允许元素数量值</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    <span class="comment">// 新的 table 数组 </span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历老数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 直接按照原始索引放入新数组中</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 遍历链表</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>HashMap 是非线程安全的，在多线程环境下对某个 HashMap 进行并行操作，可能会产生很多不可预期的情况。</p>
<h2 id="多线程-put-导致元素丢失"><a href="#多线程-put-导致元素丢失" class="headerlink" title="多线程 put 导致元素丢失"></a>多线程 put 导致元素丢失</h2><p>实验代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    list.forEach(i -&gt; map.put(i, i));</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10000</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">            map.put(i, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20000</span>; i &lt; <span class="number">30000</span>; i++) &#123;</span><br><span class="line">            map.put(i, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    System.out.println(map.entrySet().size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：29402，元素少了很多。</p>
<p>这里很好理解，我们看 put 的代码，假设我们的线程1和线程2同时在执行 put 方法。其中的的 key 值计算后落入了 table 的同一个位置。这个时候，两个线程同时执行<code>p.next = newNode(hash, key, value, null);</code>，此时两个线程的元素值就会互相覆盖掉。</p>
<h2 id="put-的同时-get-数据，可能会导致-get-的数据为-null"><a href="#put-的同时-get-数据，可能会导致-get-的数据为-null" class="headerlink" title="put 的同时 get 数据，可能会导致 get 的数据为 null"></a>put 的同时 get 数据，可能会导致 get 的数据为 null</h2><p>put 的时候，可能会产生 resize 操作，我们发现 resize 有如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">table = newTab;</span><br></pre></td></tr></table></figure>

<p>这段代码会让新的 table 为空，这个时候调用 get 方法会获取到 null 数据。</p>
<h2 id="JDK7-中并发-put-会造成循环链表"><a href="#JDK7-中并发-put-会造成循环链表" class="headerlink" title="JDK7 中并发 put 会造成循环链表"></a>JDK7 中并发 put 会造成循环链表</h2><p>此问题在 JDK8 中已经解决，在这里是提醒下自己 JDK7 中的 resize 操作会产生循环链表导致死循环，毕竟之前项目中确确实实遇到了死循环的问题。</p>
<blockquote>
<p><a href="/blog/2019/09/10/jstack/" title="Jstack 使用介绍 | 笑话人生">Jstack 使用介绍 | 笑话人生</a></p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><p><strong>什么时候会使用 HashMap？他有什么特点？</strong><br>是基于 Map 接口的实现，存储键值对时，它可以接收 null 的键值，HashMap 存储着 Entry 对象。HashMap 是非线程安全的。如果需要线程安全，则使用 ConcurrentHashMap，否则使用 HashMap 就足够了。</p>
</li>
<li><p><strong>你知道 HashMap 的工作原理吗？equals() 和 hashCode() 的都有什么作用？</strong><br>通过对 key 的 hashCode() 计算下标 <code>n - 1 &amp; hash</code>，从而获得 table 下标的位置，然后用 key.equals() 方法去链表或树中去查找对应的节点。get 和 put 方法如上介绍。</p>
</li>
<li><p><strong>你知道 hash 的实现吗？为什么要这样实现？</strong><br>在 Java 1.8 的实现中，是通过 key.hashCode() 的高16位异或低16位实现的：<code>(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，主要是从速度、功效、质量来考虑的，这么做可以在 table 的长度 n 比较小的时候，也能保证考虑到高低 bit 都参与到 hash 的计算中，同时不会有太大的开销。</p>
</li>
<li><p><strong>如果 HashMap 的大小超过了负载因子(load factor)定义的容量，怎么办？</strong><br>如果超过了负载因子(默认0.75)，则会重新 resize 一个原来长度两倍的 HashMap，并且重新调用 hash 方法。</p>
</li>
</ol>
<h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><blockquote>
<p><a href="https://juejin.im/post/6844903744711163911" title="HashMap底层实现原理 | 忆逝">HashMap 底层实现原理 | 忆逝</a><br><a href="https://zhuanlan.zhihu.com/p/31610616" title="什么是HashMap | 小灰">什么是HashMap | 小灰</a><br><a href="https://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" title="Java HashMap工作原理及实现 | Yikun">Java HashMap工作原理及实现 | Yikun</a><br><a href="https://juejin.im/post/6844903796225605640" title="深入解读HashMap线程安全性问题 | Mr羽墨青衫">深入解读HashMap线程安全性问题 | Mr羽墨青衫</a><br><a href="https://crossoverjie.top/2018/07/23/java-senior/ConcurrentHashMap/" title="HashMap? ConcurrentHashMap? 相信看完这篇没人能难住你！ | crossoverJie">HashMap? ConcurrentHashMap? 相信看完这篇没人能难住你！ | crossoverJie</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2019/09/10/hashmap/' title='浅谈 HashMap' >浅谈 HashMap</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2019/09/10/hashmap/' title='浅谈 HashMap' >http://www.cylong.com/blog/2019/09/10/hashmap/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>数组</tag>
        <tag>链表</tag>
        <tag>数据结构与算法</tag>
        <tag>hashmap</tag>
        <tag>红黑树</tag>
        <tag>线程安全</tag>
        <tag>面试总结</tag>
      </tags>
  </entry>
  <entry>
    <title>重新安排行程</title>
    <url>/blog/2020/08/28/reconstruct-itinerary/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个机票的字符串二维数组 [from, to]，子数组中的两个成员分别表示飞机出发和降落的机场地点，对该行程进行重新规划排序。所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。</p>
<p><strong>提示：</strong></p>
<ul>
<li>如果存在多种有效的行程，请你按字符自然排序返回最小的行程组合。例如，行程 [“JFK”, “LGA”] 与 [“JFK”, “LGB”] 相比就更小，排序更靠前。</li>
<li>所有的机场都用三个大写字母表示（机场代码）。</li>
<li>假定所有机票至少存在一种合理的行程。</li>
<li>所有的机票必须都用一次且只能用一次。</li>
</ul>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：[[“MUC”, “LHR”], [“JFK”, “MUC”], [“SFO”, “SJC”], [“LHR”, “SFO”]]<br>输出：[“JFK”, “MUC”, “LHR”, “SFO”, “SJC”]</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：[[“JFK”, “SFO”],[“JFK”, “ATL”],[“SFO”, “ATL”],[“ATL”, “JFK”],[“ATL”, “SFO”]]<br>输出：[“JFK”, “ATL”, “JFK”, “SFO”, “ATL”, “SFO”]<br>解释：另一种有效的行程是 [“JFK”, “SFO”, “ATL”, “JFK”, “ATL”, “SFO”]。但是它自然排序更大更靠后。</p>
</blockquote>
<a id="more"></a>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>本题是一道求解欧拉回路/欧拉通路的问题。也叫「一笔画」问题，下面给出定义。</p>
<ul>
<li>通过图中所有边恰好一次且行遍所有顶点的通路称为欧拉通路。</li>
<li>通过图中所有边恰好一次且行遍所有顶点的回路称为欧拉回路。</li>
<li>具有欧拉回路的无向图称为欧拉图。</li>
<li>具有欧拉通路但不具有欧拉回路的无向图称为半欧拉图。</li>
</ul>
<p>因为本题保证至少存在一种合理的路径，也就告诉了我们，这张图是一个欧拉图或者半欧拉图。我们只需要输出这条欧拉通路的路径即可。如果没有保证至少存在一种合理的路径，我们需要判别这张图是否是欧拉图或者半欧拉图，具体地：</p>
<ul>
<li>对于无向图 G，G 是欧拉图当且仅当 G 是连通的且没有奇度顶点。</li>
<li>对于无向图 G，G 是半欧拉图当且仅当 G 是连通的且 G 中恰有 2 个奇度顶点。</li>
<li>对于有向图 G，G 是欧拉图当且仅当 G 的所有顶点属于同一个强连通分量且每个顶点的入度和出度相同。</li>
<li>对于有向图 G，G 是半欧拉图当且仅当 G 的所有顶点属于同一个强连通分量且。<ul>
<li>恰有一个顶点的出度与入度差为 1；</li>
<li>恰有一个顶点的入度与出度差为 1；</li>
<li>所有其他顶点的入度和出度相同。</li>
</ul>
</li>
</ul>
<p>接下来我们考虑如下的行程：合法路径为 JFK→BBB→JFK→AAA</p>
<img src="/blog/2020/08/28/reconstruct-itinerary/%E6%AC%A7%E6%8B%89%E9%80%9A%E8%B7%AF.png" class="" title="欧拉通路">

<p>算法 Hierholzer 算法用于在连通图中寻找欧拉路径，其流程如下：</p>
<ol>
<li>从起点出发，进行深度优先搜索。</li>
<li>每次沿着某条边从某个顶点移动到另外一个顶点的时候，都需要删除这条边。</li>
<li>如果没有可移动的路径，则将所在节点加入到栈中，并返回。</li>
</ol>
<p>当我们顺序地考虑该问题时，我们也许很难解决该问题，根据上图我们可以发现，如果我们先走到 AAA 的顶点，就回不去了，我们走入了「死胡同」，从而导致无法遍历到其他还未访问的边。于是我们希望能够遍历完当前节点所连接的其他节点后再进入「死胡同」。</p>
<blockquote>
<p>注意对于每一个节点，它只有最多一个「死胡同」分支。依据前言中对于半欧拉图的描述，只有那个入度与出度差为 1 的节点会导致死胡同。</p>
</blockquote>
<p>不妨倒过来思考。我们注意到只有那个入度与出度差为 1 的节点会导致死胡同。而该节点必然是最后一个遍历到的节点。我们可以改变入栈的规则，当我们遍历完一个节点所连的所有节点后，我们才将该节点入栈（即逆序入栈）。对于当前节点而言，从它的每一个非「死胡同」分支出发进行深度优先搜索，都将会搜回到当前节点。而从它的「死胡同」分支出发进行深度优先搜索将不会搜回到当前节点。也就是说当前节点的死胡同分支将会优先于其他非「死胡同」分支入栈。另外为了保证我们能够快速找到当前节点所连的节点中字典序最小的那一个，我们可以使用优先队列存储当前节点所连到的点。</p>
<p>这样就能保证我们可以「一笔画」地走完所有边，最终的栈中逆序地保存了「一笔画」的结果。我们只要将栈中的内容反转，即可得到答案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, PriorityQueue&lt;String&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">List&lt;String&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findItinerary</span><span class="params">(List&lt;List&lt;String&gt;&gt; tickets)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (List&lt;String&gt; ticket : tickets) &#123;</span><br><span class="line">        <span class="keyword">if</span> (graph.containsKey(ticket.get(<span class="number">0</span>))) &#123;</span><br><span class="line">            graph.get(ticket.get(<span class="number">0</span>)).add(ticket.get(<span class="number">1</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            PriorityQueue&lt;String&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">            queue.add(ticket.get(<span class="number">1</span>));</span><br><span class="line">            graph.put(ticket.get(<span class="number">0</span>), queue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buildEulerPath(<span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">    Collections.reverse(ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildEulerPath</span><span class="params">(String travel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (graph.containsKey(travel) &amp;&amp; graph.get(travel).size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        String tmpTravel = graph.get(travel).poll();</span><br><span class="line">        buildEulerPath(tmpTravel);</span><br><span class="line">    &#125;</span><br><span class="line">    ans.add(travel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(mlogm)，其中 m 是边的数量。对于每一条边我们需要 O(logm) 地删除它，最终的答案序列长度为 m + 1。</li>
<li>空间复杂度：O(m)，其中 m 是边的数量。我们需要存储每一条边。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/reconstruct-itinerary/" title="重新安排行程 | 力扣（LeetCode）">重新安排行程 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/reconstruct-itinerary/solution/zhong-xin-an-pai-xing-cheng-by-leetcode-solution/" title="重新安排行程 | 题解（LeetCode）">重新安排行程 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/08/28/reconstruct-itinerary/' title='重新安排行程' >重新安排行程</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/08/28/reconstruct-itinerary/' title='重新安排行程' >http://www.cylong.com/blog/2020/08/28/reconstruct-itinerary/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>递归</tag>
        <tag>回溯算法</tag>
        <tag>深度优先搜索</tag>
        <tag>图</tag>
        <tag>优先队列</tag>
        <tag>欧拉路径</tag>
      </tags>
  </entry>
  <entry>
    <title>钥匙和房间</title>
    <url>/blog/2020/08/31/keys-and-rooms/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>有 N 个房间，开始时你位于 0 号房间。每个房间有不同的号码：0，1，2，…，N - 1，并且房间里可能有一些钥匙能使你进入下一个房间。在形式上，对于每个房间 i 都有一个钥匙列表 rooms[i]，每个钥匙 rooms[i][j] 由 [0, 1，…，N - 1] 中的一个整数表示，其中 N = rooms.length。 钥匙 rooms[i][j] = v 可以打开编号为 v 的房间。</p>
<p>最初，除 0 号房间外的其余所有房间都被锁住。你可以自由地在房间之间来回走动。如果能进入每个房间返回 true，否则返回 false。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入: [[1], [2], [3], []]<br>输出: true<br>解释:<br>我们从 0 号房间开始，拿到钥匙 1。<br>之后我们去 1 号房间，拿到钥匙 2。<br>然后我们去 2 号房间，拿到钥匙 3。<br>最后我们去了 3 号房间。<br>由于我们能够进入每个房间，我们返回 true。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：[[1, 3], [3, 0, 1], [2], [0]]<br>输出：false<br>解释：我们不能进入 2 号房间。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= rooms.length &lt;= 1000</li>
<li>0 &lt;= rooms[i].length &lt;= 1000</li>
<li>所有房间中的钥匙数量总计不超过 3000。</li>
</ul>
<a id="more"></a>

<h1 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h1><p>此题我们将房间理解成节点，房间 A 到房间 B 理解成边，这样这道题就变成了，我们从图的 0 点出发，能否到达所有节点的问题。</p>
<p>具体实现上，我们使用一个变量 count 记录访问过的房间数，每次访问过一个房间后就标记为访问过 <code>visited[room] = true</code>，并将 <code>count++</code> ，如果最后 count 等于房间的数量，那么就说明可以访问所有的房间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">boolean</span>[] visited;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canVisitAllRooms</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; rooms)</span> </span>&#123;</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rooms.size()];</span><br><span class="line">    visitRooms(rooms, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> count == rooms.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">visitRooms</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; rooms, Integer room)</span> </span>&#123;</span><br><span class="line">    visited[room] = <span class="keyword">true</span>;</span><br><span class="line">    count++;</span><br><span class="line">    List&lt;Integer&gt; keyList = rooms.get(room);</span><br><span class="line">    <span class="keyword">for</span> (Integer nextRoom : keyList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[nextRoom]) &#123;</span><br><span class="line">            visitRooms(rooms, nextRoom);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(n + m)，其中 n 是房间的数量，m 是所有房间中的钥匙数量的总数。</li>
<li>空间复杂度：O(n)，其中 n 是房间的数量。主要为栈空间的开销。</li>
</ul>
<h1 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h1><p>同样的，我们可以使用广度优先搜索解决此问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canVisitAllRooms</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; rooms)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = rooms.size();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    visited[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    queue.offer(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> room = queue.poll();</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> key : rooms.get(room)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[key]) &#123;</span><br><span class="line">                visited[key] = <span class="keyword">true</span>;</span><br><span class="line">                queue.offer(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count == n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(n + m)，其中 n 是房间的数量，m 是所有房间中的钥匙数量的总数。</li>
<li>空间复杂度：O(n)，其中 n 是房间的数量。主要为队列的开销。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/keys-and-rooms/" title="钥匙和房间 | 力扣（LeetCode）">钥匙和房间 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/keys-and-rooms/solution/yao-chi-he-fang-jian-by-leetcode-solution/" title="钥匙和房间 | 题解（LeetCode）">钥匙和房间 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/08/31/keys-and-rooms/' title='钥匙和房间' >钥匙和房间</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/08/31/keys-and-rooms/' title='钥匙和房间' >http://www.cylong.com/blog/2020/08/31/keys-and-rooms/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>队列</tag>
        <tag>递归</tag>
        <tag>深度优先搜索</tag>
        <tag>广度优先搜索</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>预测赢家</title>
    <url>/blog/2020/09/01/predict-the-winner/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个表示分数的非负整数数组。 玩家 1 从数组任意一端拿取一个分数，随后玩家 2 继续从剩余数组任意一端拿取分数，然后玩家 1 拿，…… 。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：[1, 5, 2]<br>输出：False<br>解释：一开始，玩家1可以从1和2中进行选择。<br>如果他选择 2（或者 1 ），那么玩家 2 可以从 1（或者 2 ）和 5 中进行选择。如果玩家 2 选择了 5 ，那么玩家 1 则只剩下 1（或者 2 ）可选。<br>所以，玩家 1 的最终分数为 1 + 2 = 3，而玩家 2 为 5 。<br>因此，玩家 1 永远不会成为赢家，返回 False 。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：[1, 5, 233, 7]<br>输出：True<br>解释：玩家 1 一开始选择 1 。然后玩家 2 必须从 5 和 7 中进行选择。无论玩家 2 选择了哪个，玩家 1 都可以选择 233 。最终，玩家 1（234 分）比玩家 2（12 分）获得更多的分数，所以返回 True，表示玩家 1 可以成为赢家。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= 给定的数组长度 &lt;= 20.</li>
<li>数组里所有分数都为非负数且不会大于 10000000 。</li>
<li>如果最终两个玩家的分数相等，那么玩家 1 仍为赢家。</li>
</ul>
<a id="more"></a>

<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>为了判断哪个玩家可以获胜，需要计算一个得分差值，即先手得分赢过后手的得分。当数组中的所有数字都被拿取时，如果先手与后手得分之差大于或等于 0，则先手获胜，反之则后手获胜。</p>
<p>由于每次只能从数组的任意一端拿取数字，因此可以保证数组中剩下的部分一定是连续的。假设数组当前剩下的部分为下标 start 到下标 end，其中 0 ≤ start ≤ end &lt; nums.length。如果 start = end，则只剩一个数字，当前玩家只能拿取这个数字。如果 start &lt; end，则当前玩家可以选择 nums[start] 或 nums[end]，然后轮到另一个玩家在数组剩下的部分选取数字。这是一个递归的过程。递归时记录当前做选择的玩家赢过对手的分数。如果大于等于 0，则代表他在这个子问题中赢了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> calculate(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[start];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> selectStart = nums[start] - calculate(nums, start + <span class="number">1</span>, end);</span><br><span class="line">    <span class="keyword">int</span> selectEnd = nums[end] - calculate(nums, start, end - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> Math.max(selectStart, selectEnd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的递归，其实有很多重复的计算，比如你先选 1，我再选 7，和你先选 7，我再选 1，这两种所带来的子问题是一样的，都是剩下 [5, 233]。我们用数组或哈希表去存储计算过的子问题的解，遇到重复的子问题，就不用再次递归计算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[][] maxScore;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    maxScore = <span class="keyword">new</span> Integer[nums.length][nums.length];</span><br><span class="line">    <span class="keyword">return</span> calculate(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxScore[start][end] != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> maxScore[start][end];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">        <span class="keyword">return</span> maxScore[start][end] = nums[start];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> selectStart = nums[start] - calculate(nums, start + <span class="number">1</span>, end);</span><br><span class="line">    <span class="keyword">int</span> selectEnd = nums[end] - calculate(nums, start, end - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> maxScore[start][end] = Math.max(selectStart, selectEnd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(2^n)，其中 n 是数组的长度。</li>
<li>空间复杂度：O(n)，其中 n 是数组的长度。空间复杂度取决于递归使用的栈空间。</li>
</ul>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>定义二维数组 dp，其行数和列数都等于数组的长度，dp[i][j] 表示当数组剩下的部分为下标 i 到下标 j 时，当前玩家与另一个玩家的分数之差的最大值，注意当前玩家不一定是先手。</p>
<ul>
<li>只有当 i ≤ j 时，数组剩下的部分才有意义，因此当 i &gt; j 时，dp[i][j] = 0。</li>
<li>当 i = j 时，只剩一个数字，当前玩家只能拿取这个数字，因此对于所有 0 ≤ i &lt; nums.length，都有 dp[i][i] = nums[i]。</li>
<li>当 i &lt; j 时，当前玩家可以选择 nums[i] 或 nums[j]，然后轮到另一个玩家在数组剩下的部分选取数字。在两种方案中，当前玩家会选择最优的方案，使得自己的分数最大化。因此可以得到如下状态转移方程：<blockquote>
<p>dp[i][j] = max(nums[i] − dp[i+1][j], nums[j] − dp[i][j − 1])</p>
</blockquote>
</li>
</ul>
<p>最后判断 dp[0][nums.length − 1] 的值，如果大于或等于 0，则先手得分大于或等于后手得分，因此先手成为赢家，否则后手成为赢家。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length][nums.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        dp[i][i] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            dp[i][j] = Math.max(nums[i] - dp[i + <span class="number">1</span>][j], nums[j] - dp[i][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][nums.length - <span class="number">1</span>] &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中使用了二维数组 dp。分析状态转移方程可以看到，dp[i][j] 的值只和 dp[i + 1][j] 与 dp[i][j − 1] 有关，即在计算 dp 的第 i 行的值时，只需要使用到 dp 的第 i 行和第 i + 1 行的值，因此可以使用一维数组代替二维数组，对空间进行优化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        dp[i] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            dp[j] = Math.max(nums[i] - dp[j], nums[j] - dp[j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[nums.length - <span class="number">1</span>] &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(n²)，其中 n 是数组的长度。需要计算每个子数组对应的 dp 的值，共有 n * (n + 1) / 2 个子数组。</li>
<li>空间复杂度：O(n)，其中 n 是数组的长度。空间复杂度取决于额外创建的数组 dp，如果不优化空间，则空间复杂度是 O(n²)，使用一维数组优化之后空间复杂度可以降至 O(n)。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/predict-the-winner/" title="预测赢家 | 力扣（LeetCode）">预测赢家 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/predict-the-winner/solution/yu-ce-ying-jia-by-leetcode-solution/" title="预测赢家 | 题解（LeetCode）">预测赢家 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/09/01/predict-the-winner/' title='预测赢家' >预测赢家</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/09/01/predict-the-winner/' title='预测赢家' >http://www.cylong.com/blog/2020/09/01/predict-the-winner/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>递归</tag>
        <tag>记忆化</tag>
        <tag>动态规划</tag>
        <tag>滚动数组</tag>
        <tag>零和博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>汉明距离</title>
    <url>/blog/2020/09/08/hamming-distance/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。给出两个整数 x 和 y，计算它们之间的汉明距离。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: x = 1, y = 4<br>输出: 2<br>解释:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1   (0 0 0 1)</span><br><span class="line">4   (0 1 0 0)</span><br><span class="line">       ↑   ↑</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="位移运算"><a href="#位移运算" class="headerlink" title="位移运算"></a>位移运算</h1><p>根据题意，我们直接使用异或运算两个整数，结果是相同位为 1，不同位为 0，这样我们直接计算异或后整数的 1 的位数，就是汉明距离。检查某一位是否是 1， 可以使用取模运算(i % 2)或者 AND 与运算(i &amp; 1)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xor = x ^ y;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (xor != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xor % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            ans += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        xor = xor &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(1)，在 Java 中 Integer 的大小是固定的，处理时间也是固定的。 32 位整数需要 32 次迭代。</li>
<li>空间复杂度：O(1)，使用恒定大小的空间。</li>
</ul>
<h1 id="Brian-Kernighan-算法"><a href="#Brian-Kernighan-算法" class="headerlink" title="Brian Kernighan 算法"></a>Brian Kernighan 算法</h1><p>上面例子中，遇到最右边的 1 后，如果可以跳过中间的 0，直接跳到下一个 1，效率会高很多。这是布赖恩·克尼根位计数算法的基本思想。该算法使用特定比特位和算术运算移除等于 1 的最右比特位。</p>
<p>当我们在 number 和 number - 1 上做 AND 位运算时，原数字 number 的最右边等于 1 的比特会被移除。</p>
<img src="/blog/2020/09/08/hamming-distance/BrianKernighan%E7%AE%97%E6%B3%95.png" class="" title="Brian Kernighan 算法">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xor = x ^ y;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (xor != <span class="number">0</span>) &#123;</span><br><span class="line">        ans += <span class="number">1</span>;</span><br><span class="line">        xor = xor &amp; (xor - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(1)，在 Java 中 Integer 的大小是固定的，处理时间也是固定的。 但是该方法需要的迭代操作更少。</li>
<li>空间复杂度：O(1)，使用恒定大小的空间。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/hamming-distance/" title="汉明距离 | 力扣（LeetCode）">汉明距离 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/hamming-distance/solution/yi-ming-ju-chi-by-leetcode/" title="汉明距离 | 题解（LeetCode）">汉明距离 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/09/08/hamming-distance/' title='汉明距离' >汉明距离</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/09/08/hamming-distance/' title='汉明距离' >http://www.cylong.com/blog/2020/09/08/hamming-distance/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>数学</tag>
        <tag>位运算</tag>
        <tag>Brian Kernighan 算法</tag>
      </tags>
  </entry>
  <entry>
    <title>组合</title>
    <url>/blog/2020/09/17/combinations/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: n = 4, k = 2<br>输出:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>从 n 个当中选 k 个的所有方案对应的枚举是组合型枚举。思路很简单，针对 1 … n 中的每个数，在组合的结果中，我们都有两种结果，选择或者不选择。于是我们从第一个数开始进行递归的判断。详细分析在代码注释中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">LinkedList&lt;Integer&gt; item = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    dfsCombine(n, k, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfsCombine</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (item.size() == k) &#123;</span><br><span class="line">        <span class="comment">// 如果长度达到k，保存结果。</span></span><br><span class="line">        ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(item));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (item.size() + n - index + <span class="number">1</span> &lt; k) &#123;</span><br><span class="line">        <span class="comment">// 如果剩下的数字不够组合成k个数，则不满足要求。</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 选择当前元素，然后进行递归。 </span></span><br><span class="line">    item.add(index);</span><br><span class="line">    dfsCombine(n, k, index + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不选择当前元素，然后进行递归，也是一种回溯。</span></span><br><span class="line">    item.removeLast();</span><br><span class="line">    dfsCombine(n, k, index + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/combinations/" title="组合 | 力扣（LeetCode）">组合 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/combinations/solution/zu-he-by-leetcode-solution/" title="组合 | 题解（LeetCode）">组合 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/09/17/combinations/' title='组合' >组合</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/09/17/combinations/' title='组合' >http://www.cylong.com/blog/2020/09/17/combinations/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>递归</tag>
        <tag>回溯算法</tag>
        <tag>深度优先搜索</tag>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title>删除排序数组中的重复项</title>
    <url>/blog/2020/09/18/remove-duplicates-from-sorted-array/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<p><strong>示例1:</strong></p>
<blockquote>
<p>给定数组 nums = [1, 1, 2],<br>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<p><strong>示例2:</strong></p>
<blockquote>
<p>给定 nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4],<br>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<p><strong>说明:</strong></p>
<blockquote>
<p>为什么返回数值是整数，但输出的答案是数组呢?<br>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。<br>你可以想象内部操作如下:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span></span><br><span class="line"><span class="keyword">int</span> len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>题目中是一个排序后的数组，那么相同的元素一定是排列在一起的，我们可以使用两个指针 i 和 j，我们不断的移动j指针，只要 nums[i]=nums[j]，我们就进行 j++ 操作，跳过重复项，直到 nums[i]≠nums[j] 的时候，说明遇到了下一个非重复项，于是我们就将 num[j] 的值复制到 num[i + 1] 的位置，接着重复此流程，遍历完全部数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int removeDuplicates(int[] nums) &#123;</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    for (int j &#x3D; 1; j &lt; nums.length; j++) &#123;</span><br><span class="line">        if (nums[i] !&#x3D; nums[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            nums[i] &#x3D; nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return i + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(n)，假设数组的长度是 n，那么 i 和 j 分别最多遍历 n 步。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" title="删除排序数组中的重复项 | 力扣（LeetCode）">删除排序数组中的重复项 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/shan-chu-pai-xu-shu-zu-zhong-de-zhong-fu-xiang-by-/" title="删除排序数组中的重复项 | 题解（LeetCode）">删除排序数组中的重复项 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/09/18/remove-duplicates-from-sorted-array/' title='删除排序数组中的重复项' >删除排序数组中的重复项</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/09/18/remove-duplicates-from-sorted-array/' title='删除排序数组中的重复项' >http://www.cylong.com/blog/2020/09/18/remove-duplicates-from-sorted-array/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>环形链表</title>
    <url>/blog/2020/10/09/linked-list-cycle/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个链表，判断链表中是否有环。如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p>
<p><strong>进阶：</strong></p>
<p>你能用 O(1)（即，常量）内存解决此问题吗？</p>
<p><strong>示例 1：</strong></p>
<img src="/blog/2020/10/09/linked-list-cycle/circularlinkedlist.png" class="" title="环形链表">
<blockquote>
<p>输入：head = [3, 2, 0, -4], pos = 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。</p>
</blockquote>
<a id="more"></a>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>比较简单的方法是遍历整个链表，将每个元素都加入到 HashSet 中，根据 HashSet 的没有重复元素的特性，当遇到重复的元素，说明遍历这个链表访问了重复的元素，即链表中有环。HashSet 是使用 HashMap 实现的，关于实现细节可以直接看源码。</p>
<blockquote>
<p><a href="/blog/2019/09/10/hashmap/" title="浅谈 HashMap | 笑话人生">浅谈 HashMap | 笑话人生</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    HashSet&lt;ListNode&gt; visit = <span class="keyword">new</span> HashSet&lt;ListNode&gt;();</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visit.add(head)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> val;</span><br><span class="line">   ListNode next;</span><br><span class="line">   ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">       val = x;</span><br><span class="line">       next = <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(N)，其中 N 是链表中的节点数。最坏情况下我们需要遍历每个节点一次。</li>
<li>空间复杂度：O(N)，其中 N 是链表中的节点数。主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次。</li>
</ul>
<h1 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h1><p>我们定义两个指针，一快一慢。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head.next;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(N)，其中 N 是链表中的节点数。<ul>
<li>当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。</li>
<li>当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动 N 轮。</li>
</ul>
</li>
<li>空间复杂度：O(1)。我们只使用了两个指针的额外空间。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/linked-list-cycle/" title="环形链表 | 力扣（LeetCode）">环形链表 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/linked-list-cycle/solution/huan-xing-lian-biao-by-leetcode-solution/" title="环形链表 | 题解（LeetCode）">环形链表 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/10/09/linked-list-cycle/' title='环形链表' >环形链表</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/10/09/linked-list-cycle/' title='环形链表' >http://www.cylong.com/blog/2020/10/09/linked-list-cycle/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>哈希表</tag>
        <tag>链表</tag>
        <tag>指针</tag>
        <tag>双指针</tag>
        <tag>hashset</tag>
      </tags>
  </entry>
  <entry>
    <title>填充每个节点的下一个右侧节点指针</title>
    <url>/blog/2020/10/15/populating-next-right-pointers-in-each-node/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。初始状态下，所有 next 指针都被设置为 NULL。</p>
<p><strong>示例：</strong></p>
<img src="/blog/2020/10/15/populating-next-right-pointers-in-each-node/116_sample.png" class="" title="完美二叉树">

<blockquote>
<p>输入：{“$id”:”1”,”left”:{“$id”:”2”,”left”:{“$id”:”3”,”left”:null,”next”:null,”right”:null,”val”:4},”next”:null,”right”:{“$id”:”4”,”left”:null,”next”:null,”right”:null,”val”:5},”val”:2},”next”:null,”right”:{“$id”:”5”,”left”:{“$id”:”6”,”left”:null,”next”:null,”right”:null,”val”:6},”next”:null,”right”:{“$id”:”7”,”left”:null,”next”:null,”right”:null,”val”:7},”val”:3},”val”:1}<br>输出：{“$id”:”1”,”left”:{“$id”:”2”,”left”:{“$id”:”3”,”left”:null,”next”:{“$id”:”4”,”left”:null,”next”:{“$id”:”5”,”left”:null,”next”:{“$id”:”6”,”left”:null,”next”:null,”right”:null,”val”:7},”right”:null,”val”:6},”right”:null,”val”:5},”right”:null,”val”:4},”next”:{“$id”:”7”,”left”:{“$ref”:”5”},”next”:null,”right”:{“$ref”:”6”},”val”:3},”right”:{“$ref”:”4”},”val”:2},”next”:null,”right”:{“$ref”:”7”},”val”:1}<br>解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>你只能使用常量级额外空间。</li>
<li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li>
</ul>
<a id="more"></a>

<h1 id="按层遍历"><a href="#按层遍历" class="headerlink" title="按层遍历"></a>按层遍历</h1><p>按层遍历是常规的思路，基本框架就是二叉树的按层遍历，这里使用两个队列 queue 记录二叉树的节点，queueLevel 记录二叉树节点所在的层。每次往 queue 队列添加节点的时候，同时记录当前节点所在的层数，遍历层的时候，如果当前节点的层等于下一个节点的层，则执行操作 node.next = nextNode 。最后层次遍历完全部节点后，即完成了填充每个节点的下一个右侧节点的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; queueLevel = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> curLevel = <span class="number">1</span>;</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        queueLevel.offer(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            Node node = queue.poll();</span><br><span class="line">            Node nextNode = queue.peek();</span><br><span class="line">            Integer level = queueLevel.poll();</span><br><span class="line">            Integer nextLevel = queueLevel.peek();</span><br><span class="line">            <span class="keyword">if</span> (level != <span class="keyword">null</span> &amp;&amp; level != curLevel) &#123;</span><br><span class="line">                curLevel = level;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (level == nextLevel) &#123;</span><br><span class="line">                node.next = nextNode;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">                queueLevel.offer(curLevel + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">                queueLevel.offer(curLevel + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val, Node _left, Node _right, Node _next)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        left = _left;</span><br><span class="line">        right = _right;</span><br><span class="line">        next = _next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(N)。每个节点会被访问一次且只会被访问一次，即从队列中弹出，并建立 next 指针。</li>
<li>空间复杂度：O(N)。这是一棵完美二叉树，它的最后一个层级包含 N/2 个节点。广度优先遍历的复杂度取决于一个层级上的最大元素数量。这种情况下空间复杂度为 O(N)。</li>
</ul>
<h1 id="使用已有的-next-指针"><a href="#使用已有的-next-指针" class="headerlink" title="使用已有的 next 指针"></a>使用已有的 next 指针</h1><p>一棵树中，存在两种类型的 next 指针。</p>
<ol>
<li>第一种情况是连接同一个父节点的两个子节点。它们可以通过同一个节点直接访问到，因此执行下面操作即可完成连接。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">node.left.next = node.right</span><br></pre></td></tr></table></figure>
<img src="/blog/2020/10/15/populating-next-right-pointers-in-each-node/node1.png" class="" title="情况1"></li>
<li>第二种情况在不同父亲的子节点之间建立连接，这种情况不能直接连接。我们可以发现当前节点右节点的指针指向的是当前节点父节点 next 节点的左节点，如果父节点没有 next 节点，则指向 null。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">node.right.next = node.next != <span class="keyword">null</span> ? node.next.left : <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<img src="/blog/2020/10/15/populating-next-right-pointers-in-each-node/node2.png" class="" title="情况2">

</li>
</ol>
<p>这里我们使用递归可以很方便的解决上述问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        root.left.next = root.right;</span><br><span class="line">        root.right.next = root.next != <span class="keyword">null</span> ? root.next.left : <span class="keyword">null</span>;</span><br><span class="line">        connect(root.left);</span><br><span class="line">        connect(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(N)，每个节点只访问一次。</li>
<li>空间复杂度：O((logn)，不需要存储额外的节点。这里只有递归占用的空间，满足题目要求。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/" title="填充每个节点的下一个右侧节点指针 | 力扣（LeetCode）">填充每个节点的下一个右侧节点指针 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/solution/tian-chong-mei-ge-jie-dian-de-xia-yi-ge-you-ce-2-4/" title="填充每个节点的下一个右侧节点指针 | 题解（LeetCode）">填充每个节点的下一个右侧节点指针 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/10/15/populating-next-right-pointers-in-each-node/' title='填充每个节点的下一个右侧节点指针' >填充每个节点的下一个右侧节点指针</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/10/15/populating-next-right-pointers-in-each-node/' title='填充每个节点的下一个右侧节点指针' >http://www.cylong.com/blog/2020/10/15/populating-next-right-pointers-in-each-node/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>队列</tag>
        <tag>递归</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
        <tag>深度优先搜索</tag>
        <tag>广度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>有序数组的平方</title>
    <url>/blog/2020/10/16/squares-of-a-sorted-array/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：[-4, -1, 0, 3, 10]<br>输出：[0, 1, 9, 16, 100]</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：[-7, -3, 2, 3, 11]<br>输出：[4, 9, 9, 49, 121]</p>
</blockquote>
<a id="more"></a>

<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><p>最简单的方法，我们可以将数组中的元素全部求平方，然后进行排序即可，但是这样操作空间复杂度和时间复杂度都较大，在此我们不多做赘述。我们观察数组的特性可以发现，数组是排序好的，这样我们就可以使用一个比较巧妙的方法进行计算，具体的，对于全正数的数组，直接平方后即满足题意，但是有负数的情况下，负数中越小的负数，计算的结果越大。正数中越大的正数计算的结果越大，题目要求平方后的数组依然是非递减顺序排序，于是我们可以定义两个指针分别指向 0 和 len - 1。不断的移动这两个指针，每次我们将平方后的较大的值逆序的放入数组中。最后完成计算，结果也将是非递减顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortedSquares(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">    <span class="keyword">int</span> len = A.length;</span><br><span class="line">    <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = len - <span class="number">1</span>, pos = len - <span class="number">1</span>; i &lt;= j;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] * A[i] &gt; A[j] * A[j]) &#123;</span><br><span class="line">            ans[pos] = A[i] * A[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans[pos] = A[j] * A[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        pos--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(n)，其中 n 是数组 A 的长度。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/" title="有序数组的平方 | 力扣（LeetCode）">有序数组的平方 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/solution/you-xu-shu-zu-de-ping-fang-by-leetcode-solution/" title="有序数组的平方 | 题解（LeetCode）">有序数组的平方 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/10/16/squares-of-a-sorted-array/' title='有序数组的平方' >有序数组的平方</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/10/16/squares-of-a-sorted-array/' title='有序数组的平方' >http://www.cylong.com/blog/2020/10/16/squares-of-a-sorted-array/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>数组</tag>
        <tag>指针</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>划分字母区间</title>
    <url>/blog/2020/10/22/partition-labels/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p>
<p><strong>示例：</strong></p>
<blockquote>
<p>输入：S = “ababcbacadefegdehijhklij”<br>输出：[9, 7, 8]<br>解释：<br>划分结果为 “ababcbaca”, “defegde”, “hijhklij”。<br>每个字母最多出现在一个片段中。像 “ababcbacadefegde”, “hijhklij” 的划分是错误的，因为划分的片段数较少。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>S的长度在 [1, 500] 之间。</li>
<li>S只包含小写字母 ‘a’ 到 ‘z’。</li>
</ul>
<a id="more"></a>

<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><p>由于同一个字母只能出现在同一个片段，显然同一个字母的第一次出现的下标位置和最后一次出现的下标位置必须出现在同一个片段。我们从第一个字母开始遍历，初始的时候，我们认为划分的字符串就是当前字母，即 <code>maxLen = 1</code>，然后我们求当前字母的最后一次出现的下标 index。并更新当前划分的字符串最长长度为 <code>maxLen = Math.max(index + 1, maxLen)</code>。遍历的截止条件就是 <code>i &lt; maxLen</code>。说明已经满足了题目条件。接下来，我们只要递归的处理剩下的字符串即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">partitionLabels</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S == <span class="keyword">null</span> || S.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxLen; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = S.lastIndexOf(S.charAt(i));</span><br><span class="line">        maxLen = Math.max(index + <span class="number">1</span>, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans.add(maxLen);</span><br><span class="line">    partitionLabels(S.substring(maxLen));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考官方的解法后发现，其实以上代码有几处可以优化的点，首先就是，我们可以先遍历一遍字符串，求出每个字符最后一次出现的下标位置。在得到每个字母最后一次出现的下标位置之后，可以使用贪心算法和双指针的方法将字符串划分为尽可能多的片段，具体做法如下。</p>
<ul>
<li>从左到右遍历字符串，遍历的同时维护当前片段的开始下标 start 和结束下标 end，初始时 <code>start = end = 0</code>。</li>
<li>对于每个访问到的字母 c，得到当前字母的最后一次出现的下标位置 end_c，则当前片段的结束下标一定不会小于 end_c，因此令 <code>end = max(end, end_c)</code>。</li>
<li>当访问到下标 end 时，当前片段访问结束，当前片段的下标范围是 [start, end]，长度为 <code>end − start + 1</code>，将当前片段的长度添加到返回值，然后令 <code>start = end + 1</code>，继续寻找下一个片段。</li>
<li>重复上述过程，直到遍历完字符串。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">partitionLabels</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] last = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span> length = S.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        last[S.charAt(i) - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        end = Math.max(end, last[S.charAt(i) - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">        <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">            ans.add(end - start + <span class="number">1</span>);</span><br><span class="line">            start = end + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(n)，其中 n 是字符串的长度。需要遍历字符串两次，第一次遍历时记录每个字母最后一次出现的下标位置，第二次遍历时进行字符串的划分。</li>
<li>空间复杂度：O(Σ)，其中 Σ 是字符串中的字符集大小。这道题中，字符串只包含小写字母，因此 Σ = 26。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/partition-labels/" title="划分字母区间 | 力扣（LeetCode）">划分字母区间 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/partition-labels/solution/hua-fen-zi-mu-qu-jian-by-leetcode-solution/" title="划分字母区间 | 题解（LeetCode）">划分字母区间 | 题解（LeetCode）</a></p>
</blockquote>
<hr>
<blockquote>
<p>文章标题：<a href='http://www.cylong.com/blog/2020/10/22/partition-labels/' title='划分字母区间' >划分字母区间</a><br>文章作者：<a href="http://www.cylong.com/about/" title="cylong">cylong</a><br>文章链接：<a href='http://www.cylong.com/blog/2020/10/22/partition-labels/' title='划分字母区间' >http://www.cylong.com/blog/2020/10/22/partition-labels/</a><br>有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●’◡’●)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>学习笔记</tag>
        <tag>字符串</tag>
        <tag>指针</tag>
        <tag>双指针</tag>
        <tag>贪心算法</tag>
        <tag>递归</tag>
      </tags>
  </entry>
</search>
